import combinatorics.quiver.basic
import combinatorics.quiver.single_obj
import group_theory.group_action.basic
import group_theory.group_action.group
import combinatorics.quiver.covering
import group_theory.subgroup.basic
import group_theory.coset
import group_theory.quotient_group
import group_theory.group_action.quotient
import combinatorics.quiver.iso
import group_theory.free_group

/-

## TODO

* Should `action_graph` be defined just for `[has_smul M V]` without the `Œπ : S ‚Üí M`, and then
  specialized when talking about group actions ?

-/

universes u v w

namespace quiver

section basic

/--
Alias for the Schreier graph vertex type.
-/
def action_graph (V : Type*) {M : Type*} [has_smul M V] {S : Type*} (Œπ : S ‚Üí M) := V

/--
Converting between the original vertex type and the alias.
-/
@[simps] def equiv_action_graph {V : Type*} {M : Type*} [has_smul M V] {S : Type*} {Œπ : S ‚Üí M} :
  V ‚âÉ action_graph V Œπ := equiv.refl V

variables (V : Type*) {M : Type*} [has_smul M V] {S : Type*} (Œπ : S ‚Üí M)

/-- Transporting the action to the alias -/
instance : has_smul M (action_graph V Œπ) :=
{ smul := Œª x y, equiv_action_graph $ x ‚Ä¢ (equiv_action_graph.symm y)}

/--
The `quiver` instance on `action_graph V Œπ`.
The set of arrow from `x` to `y` is the subset of `S` such that `(Œπ s) x = y`.
-/
instance action_graph.quiver : quiver (action_graph V Œπ) :=
{ hom := Œª x y, {s : S // (Œπ s) ‚Ä¢ x = y} }

abbreviation mk_hom (x : action_graph V Œπ) (s : S) : x ‚ü∂ Œπ s ‚Ä¢ x := ‚ü®s, rfl‚ü©

lemma cast_mk_hom {x x' : action_graph V Œπ} (h : x = x') {s : S} (h' : Œπ s ‚Ä¢ x = Œπ s ‚Ä¢ x') :
  (mk_hom V Œπ x s).cast h h' = mk_hom V Œπ x' s :=
by { cases h, cases h', refl, }

/--
The star around a vertex is just `S`.
-/
@[simps] def action_graph.star_equiv (x : action_graph V Œπ) : star x ‚âÉ S :=
{ to_fun := Œª p, p.2,
  inv_fun := Œª s, ‚ü®Œπ s ‚Ä¢ x, ‚ü®s, rfl‚ü©‚ü©,
  left_inv := Œª ‚ü®_, ‚ü®s, rfl‚ü©‚ü©, rfl,
  right_inv := Œª s, rfl }

def action_graph.path_star_equiv (x : action_graph V Œπ) : path_star x ‚âÉ list S :=
{ to_fun := Œª p, @quiver.path.rec_on _ _ x (Œª y p, list S) p.1 p.2 [] (Œª _ _ q e ih, ih.cons e.1),
  inv_fun := @list.rec _ (Œª l, path_star x) ‚ü®x, path.nil‚ü© (Œª h l ih, ‚ü®_, ih.2.cons ‚ü®h, rfl‚ü©‚ü©),
  left_inv :=
    begin
      rintro ‚ü®v, p‚ü©,
      induction p with y z q e ih, { refl, },
      { obtain ‚ü®s, rfl‚ü© := e,
        simp only [path_star_eq_iff] at ih,
        obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ih,
        dsimp at h‚ÇÅ,
        simp only [‚Üêh‚ÇÅ, ‚Üêh‚ÇÇ],
        refine ‚ü®rfl, _‚ü©,
        rw [‚Üêpath.eq_cast_iff_heq rfl (congr_arg (Œª x, Œπ s ‚Ä¢ x) h‚ÇÅ.symm),
            path.cast_cons, path.cast_cast],
        fapply cons_eq_cons_of_exist_cast h‚ÇÅ,
        { rw [hom.cast_eq_iff_eq_cast, hom.cast_cast, cast_mk_hom], refl, },
        { apply path.cast_irrelevant, }, },
    end,
  right_inv :=
    begin
      rintro l,
      induction l with s l ih,
      { refl, },
      { simp only [subtype.val_eq_coe, eq_self_iff_true, true_and, ‚Üêih], },
    end }

/--
Any arrow in `action_graph V Œπ` is labelled by an element of `S`.
This is encoded as mapping to the `single_obj S` quiver.
-/
@[simps] def action_graph_labelling : (action_graph V Œπ) ‚•§q single_obj S :=
{ obj := Œª (x : action_graph V Œπ), single_obj.star S,
  map := Œª x y e, action_graph.star_equiv V Œπ x ‚ü®y, e‚ü©, }

notation `ùë®` := action_graph
notation `ùë®l` := action_graph_labelling

lemma action_graph.labelling_star_bijective (x : ùë® V Œπ) : ((ùë®l V Œπ).star x).bijective :=
begin
  split,
  { rintro ‚ü®_, ‚ü®_, rfl‚ü©‚ü© ‚ü®_, ‚ü®_, rfl‚ü©‚ü© h,
    simp only [prefunctor.star_apply, action_graph_labelling_map, action_graph.star_equiv_apply,
               subtype.coe_mk, eq_iff_true_of_subsingleton, heq_iff_eq, true_and] at h,
    subst h, },
  { rintro ‚ü®‚ü®‚ü©, s‚ü©, refine ‚ü®‚ü®_, ‚ü®s, rfl‚ü©‚ü©, rfl‚ü©, }
end

end basic

section group_action
/-!
### Schreier graphs for group actions.

In that case, the labelling is a covering, meaning that the stars and costars around each vertex
are in bijection with `S`.
-/

variables (V : Type*) {M : Type*} [group M] [mul_action M V] {S : Type*} (Œπ : S ‚Üí M)

instance : mul_action M (ùë® V Œπ) :=
{ smul := has_smul.smul,
  one_smul := mul_action.one_smul,
  mul_smul := mul_action.mul_smul }

@[simps] def action_graph.costar_equiv (x : action_graph V Œπ) : costar x ‚âÉ S :=
{ to_fun := Œª p, p.2,
  inv_fun := Œª s, ‚ü®(Œπ s)‚Åª¬π ‚Ä¢ x, ‚ü®s, by simp‚ü©‚ü©,
  left_inv := by { rintro ‚ü®y, ‚ü®s, rfl‚ü©‚ü©, simp [subtype.heq_iff_coe_eq], },
  right_inv := Œª s, rfl }

lemma action_graph.labelling_costar_bijective (x : ùë® V Œπ) : ((ùë®l V Œπ).costar x).bijective :=
begin
  split,
  { rintro ‚ü®y, ‚ü®s, hy‚ü©‚ü© ‚ü®z, ‚ü®t, hz‚ü©‚ü© h,
    subst_vars,
    simp only [prefunctor.costar_apply, action_graph_labelling_map, action_graph.star_equiv_apply,
               subtype.coe_mk, eq_iff_true_of_subsingleton, heq_iff_eq, true_and] at h,
    subst h,
    simp only [smul_eq_iff_eq_inv_smul, inv_smul_smul] at hz,
    subst hz, },
  { rintro ‚ü®‚ü®‚ü©, s‚ü©, refine ‚ü®‚ü®(Œπ s)‚Åª¬π ‚Ä¢ x, ‚ü®s, _‚ü©‚ü©, _‚ü©, simp, simp, },
end

lemma action_graph_labelling_is_covering : (ùë®l V Œπ).is_covering :=
‚ü®action_graph.labelling_star_bijective V Œπ, action_graph.labelling_costar_bijective V Œπ‚ü©


notation `ùë®c` := action_graph_labelling_is_covering

@[simps] def _root_.equiv.sum {Œ±‚ÇÄ Œ±‚ÇÅ Œ≤‚ÇÄ Œ≤‚ÇÅ : Type*} (hŒ± : Œ±‚ÇÄ ‚âÉ Œ±‚ÇÅ) (hŒ≤ : Œ≤‚ÇÄ ‚âÉ Œ≤‚ÇÅ) :
  Œ±‚ÇÄ ‚äï Œ≤‚ÇÄ ‚âÉ Œ±‚ÇÅ ‚äï Œ≤‚ÇÅ :=
{ to_fun := sum.elim (@sum.inl _ Œ≤‚ÇÅ ‚àò hŒ±) (@sum.inr Œ±‚ÇÅ _ ‚àò hŒ≤),
  inv_fun := sum.elim (@sum.inl _ Œ≤‚ÇÄ ‚àò hŒ±.symm) (@sum.inr Œ±‚ÇÄ _ ‚àò hŒ≤.symm),
  left_inv := by
  { rintro (_|_);
    simp only [sum.elim_inl, sum.elim_inr, function.comp_app, equiv.symm_apply_apply], },
  right_inv :=  by
  { rintro (_|_);
    simp only [sum.elim_inl, sum.elim_inr, function.comp_app, equiv.apply_symm_apply], } }

/-
The sorry should be easy but would benefit from infrastructure:
* `symmetrify (single_obj Œ±)` is isomorphic to `single_obj (Œ± ‚äï Œ±)`
* need a usable def of isomorphisms
* isomorphisms induce equivalence of `star` and `star_path` etc
-/
@[simps] def action_graph.symmetrify_star_equiv (x : ùë® V Œπ ) :
  star (symmetrify.of.obj x) ‚âÉ S ‚äï S :=
begin
  transitivity,
  apply quiver.symmetrify_star,
  apply equiv.sum,
  apply action_graph.star_equiv,
  apply action_graph.costar_equiv,
end

noncomputable def action_graph.symmetrify_path_star_equiv (x : ùë® V Œπ) :
  path_star (symmetrify.of.obj x) ‚âÉ list (S ‚äï S) :=
{ to_fun := by
  begin
    rintros ‚ü®y, p‚ü©,
    induction p with a b p e ih,
    exact list.nil,
    exact ih.append [(action_graph.symmetrify_star_equiv V Œπ a).to_fun ‚ü®_, e‚ü©],
  end,
  inv_fun :=
  begin
    rintros l,
    induction l with a l ih,
    exact ‚ü®_, path.nil‚ü©,
    exact ‚ü®_, ih.2.cons $ ((action_graph.symmetrify_star_equiv V Œπ ih.1).inv_fun a).2‚ü©,
  end,
  left_inv :=
  begin
    rintros ‚ü®y, p‚ü©,
    induction p with a b p e ih,
    { simp, },
    sorry
  end,
  right_inv := sorry }

/-
Need to fine a usable def probably in `free_group`
* `free_group.lift.aux`, but `free_group` uses `bool √ó S` ‚Ä¶
 -/
@[simp] def val : list (S ‚äï S) ‚Üí M
| list.nil := 1
| (list.cons (sum.inl s) l) := (Œπ s) * (val l)
| (list.cons (sum.inr s) l) := (Œπ s) ‚Åª¬π * (val l)

lemma _root_.subgroup.closure_eq_range_val :
  (subgroup.closure $ set.range Œπ).carrier = set.range (val Œπ) :=
begin
  apply subset_antisymm,
  { rintro x hx, apply subgroup.closure_induction hx,
    { rintro _ ‚ü®s, rfl‚ü©, refine ‚ü®[sum.inl s], mul_one _‚ü©, },
    { refine ‚ü®[], rfl‚ü©, },
    { rintro _ _ ‚ü®x, rfl‚ü© ‚ü®y, rfl‚ü©, refine ‚ü®x.append y, _‚ü©, sorry, },
    { rintro _ ‚ü®x, rfl‚ü©, refine ‚ü®x.reverse, _‚ü©,  sorry, }, },
  { rintro _ ‚ü®x, rfl‚ü©, induction x,
    simp only [subgroup.one_mem, val, subgroup.mem_carrier],
    cases x_hd,
    sorry,
    sorry, },
end

/-
I'm using `id p.1` because `symmetrify` has no converse to `of`
That should be remedied.
-/
lemma action_graph.path_star_equiv_end_eq_mul
  (x : ùë® V Œπ) (p : path_star $ symmetrify.of.obj x) :
  (id p.1 : ùë® V Œπ) = (val Œπ $ (action_graph.symmetrify_path_star_equiv V Œπ x) p) ‚Ä¢ x := sorry


/--
Using the equivalence above:
* paths starting at `x` are in bijection with words over `S`
* this bijection maps the end of the path to the value of the path applied to `x`
Thus:
* Now use `_root_.subgroup.closure_eq_range_val`
-/
lemma action_graph.reachable_iff (x y : ùë® V Œπ) :
  nonempty (path (symmetrify.of.obj x) (symmetrify.of.obj y)) ‚Üî
  ‚àÉ g ‚àà (subgroup.closure $ set.range Œπ), g ‚Ä¢ x = y := sorry

/- A endomorphism of the graph (with labelling) commutes with the `smul`. -/
lemma action_graph.action_commute (œÜ : ùë® V Œπ ‚•§q ùë® V Œπ) (œÜm : œÜ ‚ãôq ùë®l V Œπ = ùë®l V Œπ)
  (v : ùë® V Œπ) (s : S) : œÜ.obj (Œπ s ‚Ä¢ v) = Œπ s ‚Ä¢ (œÜ.obj v) :=
begin
  let e : v ‚ü∂ Œπ s ‚Ä¢ v := ‚ü®_, rfl‚ü©,
  let e' : œÜ.obj v ‚ü∂ Œπ s ‚Ä¢ (œÜ.obj v) := ‚ü®_, rfl‚ü©,
  have : œÜ.star _ ‚ü®_, e‚ü© = ‚ü®_, e'‚ü©, by
  { suffices : (œÜ ‚ãôq ùë®l _ _).star _ ‚ü®_, e‚ü© = (ùë®l _ _).star _ ‚ü®_, e'‚ü©,
    { dsimp only [prefunctor.star_comp] at this,
      apply ((ùë®c _ _).1 _).left this, },
    rw [œÜm],
    refl },
  simp only [prefunctor.star_apply] at this,
  exact this.1,
end

/--
Given a pretransitive action, and assuming `set.range Œπ` generates the group,
any automorphism is uniquely determined by where it sends one vertex.
Barring those two conditions, the statement would be that the choice of image of a vertex determines
the automorphism on the weakly connected component of the vertex.
-/
lemma eq_of_eq_on  (œÜ œà : ùë®l V Œπ ‚âÉqc ùë®l V Œπ) (v‚ÇÄ : V)
  (ha : mul_action.is_pretransitive M V)
  (hv‚ÇÄ : œÜ.to_prefunctor.obj v‚ÇÄ = œà.to_prefunctor.obj v‚ÇÄ)
  (h : subgroup.closure (set.range Œπ) = (‚ä§ : subgroup M)) : œÜ = œà :=
begin
  apply covering_iso.ext,
  apply iso.to_prefunctor_ext,
  apply (ùë®c _ _).eq_of_eq_of_preconnected _ _ hv‚ÇÄ,
  { rw [œÜ.commute_left, œà.commute_left], },
  { rintro u v,
    refine (action_graph.reachable_iff V Œπ u v).mpr _,
    simp only [h, subgroup.mem_top, exists_true_left],
    exact ha.exists_smul_eq u v, },
end

section schreier_graph

/--
A¬†Schreier coset graph is the Schreier graph of the action of a group `M` on the cosets `M ‚ß∏ H`.
-/
abbreviation schreier_graph (H : subgroup M) := ùë® (M ‚ß∏ H) Œπ
abbreviation schreier_graph_labelling (H : subgroup M) := ùë®l (M ‚ß∏ H) Œπ

notation `ùë∫` := schreier_graph
notation `ùë∫l` := schreier_graph_labelling

@[simps] noncomputable def from_coset_graph (v‚ÇÄ : V) :
  ùë∫ Œπ (mul_action.stabilizer M v‚ÇÄ) ‚•§q ùë® (mul_action.orbit M v‚ÇÄ) Œπ :=
{ obj := (mul_action.orbit_equiv_quotient_stabilizer M v‚ÇÄ).symm,
  map := Œª X Y e, ‚ü®e.val, by obtain ‚ü®e,rfl‚ü© := e;
                          simp only [mul_action.smul_orbit_equiv_quotient_stabilizer_symm_apply]‚ü© }

lemma from_coset_graph_labelling (v‚ÇÄ : V) :
  (from_coset_graph V Œπ v‚ÇÄ) ‚ãôq ùë®l (mul_action.orbit M v‚ÇÄ) Œπ =
  ùë®l (M ‚ß∏ mul_action.stabilizer M v‚ÇÄ) Œπ :=
begin
  dsimp only [from_coset_graph, action_graph_labelling],
  fapply prefunctor.ext,
  { simp only [eq_iff_true_of_subsingleton, implies_true_iff], },
  { rintros _ _ ‚ü®e, he‚ü©,
    simp only [prefunctor.comp_map, eq_rec_constant, action_graph.star_equiv_apply, subtype.coe_mk], },
end

@[simps] noncomputable def to_coset_graph (v‚ÇÄ : V) :
  ùë® (mul_action.orbit M v‚ÇÄ) Œπ ‚•§q ùë∫ Œπ (mul_action.stabilizer M v‚ÇÄ) :=
{ obj := (mul_action.orbit_equiv_quotient_stabilizer M v‚ÇÄ),
  map := Œª X Y e, ‚ü®e.val, by obtain ‚ü®e,rfl‚ü© := e;
                          simp only [mul_action.smul_orbit_equiv_quotient_stabilizer_apply]‚ü© }

lemma to_coset_graph_labelling (v‚ÇÄ : V) :
  (to_coset_graph V Œπ v‚ÇÄ) ‚ãôq ùë®l (M ‚ß∏ mul_action.stabilizer M v‚ÇÄ) Œπ =
  ùë®l (mul_action.orbit M v‚ÇÄ) Œπ:=
begin
  dsimp only [to_coset_graph, action_graph_labelling],
  fapply prefunctor.ext,
  { simp only [eq_iff_true_of_subsingleton, implies_true_iff], },
  { rintros _ _ ‚ü®_,_‚ü©,
    simp only [prefunctor.comp_map, eq_rec_constant, action_graph.star_equiv_apply, subtype.coe_mk], },
end

lemma from_coset_graph_to_coset_graph (v‚ÇÄ : V) :
  from_coset_graph V Œπ v‚ÇÄ ‚ãôq to_coset_graph V Œπ v‚ÇÄ = ùü≠q _ :=
begin
  apply (ùë®c _ _).eq_of_eq_obj,
  { simp only [to_coset_graph_labelling, from_coset_graph_labelling, prefunctor.comp_assoc,
               prefunctor.id_comp], },
  { ext ‚ü®_‚ü©,
    simp only [prefunctor.comp_obj, from_coset_graph_obj, to_coset_graph_obj,
               equiv.apply_symm_apply, prefunctor.id_obj, id.def], },
end

lemma to_coset_graph_from_coset_graph (v‚ÇÄ : V) :
  to_coset_graph V Œπ v‚ÇÄ ‚ãôq from_coset_graph V Œπ v‚ÇÄ = ùü≠q _ :=
begin
  apply (ùë®c _ _).eq_of_eq_obj,
  { simp only [to_coset_graph_labelling, from_coset_graph_labelling, prefunctor.comp_assoc,
               prefunctor.id_comp], },
  { ext _,
    simp only [prefunctor.comp_obj, to_coset_graph_obj, from_coset_graph_obj,
               equiv.symm_apply_apply, prefunctor.id_obj, id.def], },
end

noncomputable def orbit_stabilizer_covering_iso (v‚ÇÄ : V) :
  ùë®l (mul_action.orbit M v‚ÇÄ) Œπ ‚âÉqc ùë∫l Œπ (mul_action.stabilizer M v‚ÇÄ) :=
{ inv_prefunctor := from_coset_graph V Œπ v‚ÇÄ,
  to_prefunctor := to_coset_graph V Œπ v‚ÇÄ,
  right_inv := from_coset_graph_to_coset_graph V Œπ v‚ÇÄ,
  left_inv := to_coset_graph_from_coset_graph V Œπ v‚ÇÄ,
  commute_left := to_coset_graph_labelling V Œπ v‚ÇÄ,
  commute_right := from_coset_graph_labelling V Œπ v‚ÇÄ }

section automs

variables {N : subgroup M} [Nn : N.normal]
include Nn

@[simps] def as_autom (g : M) : ùë∫ Œπ N ‚•§q ùë∫ Œπ N :=
{ obj := Œª x, equiv_action_graph ((equiv_action_graph.symm x) * (g‚Åª¬π)),
  map := Œª x y a, ‚ü®a.val, by
    begin
      obtain ‚ü®a,rfl‚ü© := a,
      obtain ‚ü®x‚ü© := x,
      change Œπ a ‚Ä¢ ((‚Üëx : M ‚ß∏ N) * (‚Üëg)‚Åª¬π) = Œπ a ‚Ä¢ (‚Üëx : M ‚ß∏ N) * (‚Üëg)‚Åª¬π,
      simpa only [mul_action.quotient.smul_coe, smul_eq_mul, quotient_group.coe_mul, mul_assoc],
    end‚ü© }

lemma as_autom_labelling (g : M) :
  as_autom Œπ g ‚ãôq ùë∫l Œπ N = ùë∫l Œπ N :=
begin
  dsimp only [as_autom, action_graph_labelling],
  fapply prefunctor.ext,
  { simp only [eq_iff_true_of_subsingleton, implies_true_iff], },
  { rintro _ _ ‚ü®_, rfl‚ü©,
    simp [subtype.coe_mk, prefunctor.comp_map, action_graph_labelling_map,
    eq_rec_constant], },
end

lemma as_autom_one : as_autom Œπ 1 = ùü≠q (ùë∫ Œπ N) :=
begin
  fapply (ùë®c _ _).eq_of_eq_obj,
  { rw [as_autom_labelling, prefunctor.id_comp], },
  { ext x,
    simp only [equiv_action_graph_symm_apply, quotient_group.coe_one, inv_one, mul_one,
               equiv_action_graph_apply, prefunctor.id_obj, id.def, as_autom], },
end

lemma as_autom_mul (g h : M) :
  (as_autom Œπ (g * h) : ùë∫ Œπ N ‚•§q  ùë∫ Œπ N) = (as_autom Œπ h) ‚ãôq (as_autom Œπ g) :=
begin
  fapply (ùë®c _ _).eq_of_eq_obj,
  { simp_rw [prefunctor.comp_assoc, as_autom_labelling], },
  { ext x,
    simp only [equiv_action_graph_symm_apply, equiv_action_graph_apply, as_autom,
               quotient_group.coe_mul, mul_inv_rev, prefunctor.comp_obj, mul_assoc], },
end

def as_autom_covering_iso (g : M) : ùë∫l Œπ N ‚âÉqc ùë∫l Œπ N :=
{ to_prefunctor := as_autom Œπ g,
  inv_prefunctor := as_autom Œπ (g‚Åª¬π),
  left_inv := by simp [‚Üêas_autom_mul, ‚Üêas_autom_one],
  right_inv := by simp [‚Üêas_autom_mul, ‚Üêas_autom_one],
  commute_left := as_autom_labelling Œπ g,
  commute_right := as_autom_labelling Œπ (g‚Åª¬π), }

lemma as_autom_eq_iff (g‚ÇÅ g‚ÇÇ : M) :
  (as_autom Œπ g‚ÇÅ : ùë∫ Œπ N ‚•§q ùë∫ Œπ N) = (as_autom Œπ g‚ÇÇ : ùë∫ Œπ N ‚•§q ùë∫ Œπ N) ‚Üî g‚ÇÅ / g‚ÇÇ ‚àà N :=
begin
  refine ‚ü®Œª h, _, Œª h, _‚ü©,
  { dsimp only [as_autom] at h,
    simp only [subtype.val_eq_coe, equiv_action_graph_symm_apply,
               equiv_action_graph_apply] at h ‚ä¢,
    simpa [‚Üêquotient_group.coe_one, quotient_group.eq_iff_div_mem] using
            (congr_fun h.left (equiv_action_graph 1)), },
  { fapply (ùë®c _ _).eq_of_eq_obj,
    { simp_rw [as_autom_labelling], },
    { ext ‚ü®x‚ü©,
      change (‚Üëx : M ‚ß∏ N) * (g‚ÇÅ)‚Åª¬π = (‚Üëx : M ‚ß∏ N) * (‚Üëg‚ÇÇ)‚Åª¬π,
      simpa [quotient_group.eq_iff_div_mem] using h, }, },
end

lemma exists_as_autom {œÜ : ùë∫l Œπ N ‚âÉqc ùë∫l Œπ N} {g : M}
  (h : subgroup.closure (set.range Œπ) = (‚ä§ : subgroup M))
  (hv : œÜ.obj (1 : M ‚ß∏ N) = quotient_group.mk g) : œÜ = as_autom_covering_iso Œπ (g‚Åª¬π) :=
begin
  apply covering_iso.ext,
  apply iso.to_prefunctor_ext,
  fapply (ùë®c _ _).eq_of_eq_of_preconnected,
  { simp [covering_iso.commute_left], },
  { rintro ‚ü®x‚ü© ‚ü®y‚ü©,
    refine (action_graph.reachable_iff _ _ _ _).mpr _,
    simp only [h, subgroup.mem_top, exists_true_left],
    refine ‚ü®y * x‚Åª¬π, _‚ü©,
    change (y * x‚Åª¬π) ‚Ä¢ quotient_group.mk x = quotient_group.mk y,
    simp only [mul_action.quotient.smul_mk, smul_eq_mul, inv_mul_cancel_right], },
  { exact (1 : M ‚ß∏ N), },
  { simpa [hv, as_autom_covering_iso], },
end

end automs

end schreier_graph

/--
The Cayley graph of `M` w.r.t. `Œπ : S ‚Üí M` is the Schreier coset graph where `H` is the trivial
subgroup of `M`.
-/
abbreviation cayley_graph := ùë∫ Œπ (‚ä• : subgroup M)
abbreviation cayley_graph_labelling := ùë∫l Œπ (‚ä• : subgroup M)

notation `ùë™` := cayley_graph
notation `ùë™l` := cayley_graph_labelling

namespace cayley_graph

variables {N : subgroup M} [Nn : N.normal]
include Nn

-- Maybe there is an official mathlib way to state that `Œπ` generates the group.
lemma preconnected_iff : is_preconnected (symmetrify $ ùë™ Œπ) ‚Üî subgroup.closure (set.range Œπ) = ‚ä§ := sorry

def cayley_iso_schreier : ùë™l ((quotient_group.mk : M ‚Üí M ‚ß∏ N) ‚àò Œπ) ‚âÉqc (ùë∫l Œπ N) := sorry


end cayley_graph

end group_action

end quiver
