/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import topology.uniform_space.uniform_convergence
import topology.uniform_space.pi
import topology.uniform_space.equiv

/-!
# Topology and uniform structure of uniform convergence

This files endows `α → β` with the topologies / uniform structures of
- uniform convergence on `α` (in the `uniform_convergence` namespace)
- uniform convergence on a specified family `𝔖` of sets of `α`
  (in the `uniform_convergence_on` namespace), also called `𝔖`-convergence

Usual examples of the second construction include :
- the topology of compact convergence, when `𝔖` is the set of compacts of `α`
- the strong topology on the dual of a topological vector space (TVS) `E`, when `𝔖` is the set of
  Von Neuman bounded subsets of `E`
- the weak-* topology on the dual of a TVS `E`, when `𝔖` is the set of singletons of `E`.

This file contains a lot of technical facts, so it is heavily commented, proofs included!

## Main definitions

* `uniform_convergence.gen`: basis sets for the uniformity of uniform convergence. These are sets
  of the form `S(V) := {(f, g) | ∀ x : α, (f x, g x) ∈ V}` for some `V : set (β × β)`
* `uniform_convergence.uniform_space`: uniform structure of uniform convergence. This is the
  `uniform_space` on `α → β` whose uniformity is generated by the sets `S(V)` for `V ∈ 𝓤 β`.
  We will denote this uniform space as `𝒰(α, β, uβ)`, both in the comments and as a local notation
  in the Lean code, where `uβ` is the uniform space structure on `β`.
* `uniform_convergence_on.uniform_space`: uniform structure of 𝔖-convergence, where
  `𝔖 : set (set α)`. This is the infimum, for `S ∈ 𝔖`, of the pullback of `𝒰 S β` by the map of
  restriction to `S`. We will denote it `𝒱(α, β, 𝔖, uβ)`, where `uβ` is the uniform space structure
  on `β`.

## Main statements

### Basic properties

* `uniform_convergence.uniform_continuous_eval`: evaluation is uniformly continuous for `𝒰(α, uβ)`.
* `uniform_convergence.t2_space`: the topology of uniform convergence on `α → β` is T₂ if
  `β` is T₂.
* `uniform_convergence.tendsto_iff_tendsto_uniformly`: `𝒰(α, β, uβ)` is
  indeed the uniform structure of uniform convergence
* `uniform_convergence_on.uniform_continuous_eval_of_mem`: evaluation at a point contained in a
  set of `𝔖` is uniformly continuous for `𝒱(α, β, 𝔖 uβ)`
* `uniform_convergence.t2_space`: the topology of `𝔖`-convergence on `α → β` is T₂ if
  `β` is T₂ and `𝔖` covers `α`
* `uniform_convergence_on.tendsto_iff_tendsto_uniformly_on`:
  `𝒱(α, β, 𝔖 uβ)` is indeed the uniform structure of `𝔖`-convergence

### Functoriality and compatibility with product of uniform spaces

In order to avoid the need for filter bases as much as possible when using these definitions,
we develop an extensive API for manipulating these structures abstractly. As usual in the topology
section of mathlib, we first state results about the complete lattices of `uniform_space`s on
fixed types, and then we use these to deduce categorical-like results about maps between two
uniform spaces.

We only describe these in the harder case of `𝔖`-convergence, as the names of the corresponding
results for uniform convergence can easily be guessed.

#### Order statements

* `uniform_convergence_on.mono`: let `u₁`, `u₂` be two uniform structures on `γ` and
  `𝔖₁ 𝔖₂ : set (set α)`. If `u₁ ≤ u₂` and `𝔖₂ ⊆ 𝔖₁` then `𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)`.
* `uniform_convergence_on.infi_eq`: if `u` is a family of uniform structures on `γ`, then
  `𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)`.
* `uniform_convergence_on.comap_eq`: if `u` is a uniform structures on `β` and `f : γ → β`, then
  `𝒱(α, γ, 𝔖, comap f u) = comap (λ g, f ∘ g) 𝒱(α, γ, 𝔖, u₁)`.

An interesting note about these statements is that they are proved without ever unfolding the basis
definition of the uniform structure of uniform convergence! Instead, we build a
(not very interesting) Galois connection `uniform_convergence.gc` and then rely on the Galois
connection API to do most of the work.

#### Morphism statements (unbundled)

* `uniform_convergence_on.postcomp_uniform_continuous`: if `f : (γ, uγ) → (β, uβ)` is uniformly
  continuous, then `(λ g, f ∘ g) : (α → γ, 𝒱(α, γ, 𝔖, uγ)) → (α → β, 𝒱(α, β, 𝔖, uβ))` is
  uniformly continuous.
* `uniform_convergence_on.postcomp_uniform_inducing`: if `f : (γ, uγ) → (β, uβ)` is a uniform
  inducing, then `(λ g, f ∘ g) : (α → γ, 𝒱(α, γ, 𝔖, uγ)) → (α → β, 𝒱(α, β, 𝔖, uβ))` is a
  uniform inducing.
* `uniform_convergence_on.precomp_uniform_continuous`: let `f : γ → α`, `𝔖 : set (set α)`,
  `𝔗 : set (set γ)`, and assume that `∀ T ∈ 𝔗, f '' T ∈ 𝔖`. Then, the function
  `(λ g, g ∘ f) : (α → β, 𝒱(α, β, 𝔖, uβ)) → (γ → β, 𝒱(γ, β, 𝔗 uβ))` is uniformly continuous.

#### Isomorphism statements (bundled)

* `uniform_convergence_on.congr_right`: turn a uniform isomorphism `(γ, uγ) ≃ᵤ (β, uβ)` into a
  uniform isomorphism `(α → γ, 𝒱(α, γ, 𝔖, uγ)) ≃ᵤ (α → β, 𝒱(α, β, 𝔖, uβ))` by post-composing.
* `uniform_convergence_on.congr_left`: turn a bijection `e : γ ≃ α` such that we have both
  `∀ T ∈ 𝔗, e '' T ∈ 𝔖` and `∀ S ∈ 𝔖, e ⁻¹' S ∈ 𝔗` into a uniform isomorphism
  `(γ → β, 𝒰(γ, β, uβ)) ≃ᵤ (α → β, 𝒰(α, β, uβ))` by pre-composing.
* `uniform_convergence_on.uniform_equiv_Pi_comm`: the natural bijection between `α → Π i, δ i`
  and `Π i, α → δ i`, upgraded to a uniform isomorphism between
  `(α → (Π i, δ i), 𝒱(α, (Π i, δ i), 𝔖, (Π i, uδ i)))` and
  `((Π i, α → δ i), (Π i, 𝒱(α, δ i, 𝔖, uδ i)))`.

#### Important use cases

* If `(G, uG)` is a uniform group, then `(α → G, 𝒱(α, G, 𝔖, uG))` is a uniform group: since
  `(/) : G × G → G` is uniformly continuous, `uniform_convergence_on.postcomp_uniform_continuous`
  tells us that `((/) ∘ —) : (α → G × G) → (α → G)` is uniformly continuous. By precomposing with
  `uniform_convergence_on.uniform_equiv_prod_arrow`, this gives that
  `(/) : (α → G) × (α → G) → (α → G)` is also uniformly continuous
* The transpose of a continuous linear map is continuous for the strong topologies: since
  continuous linear maps are uniformly continuous and map bounded sets to bounded sets,
  this is just a special case of `uniform_convergence_on.precomp_uniform_continuous`.

## Implementation details

We do not declare these structures as instances, since they would conflict with `Pi.uniform_space`.

## TODO

* Show that the uniform structure of `𝔖`-convergence is exactly the structure of `𝔖'`-convergence,
  where `𝔖'` is the ***noncovering*** bornology (i.e ***not*** what `bornology` currently refers
  to in mathlib) generated by `𝔖`.
* Add a type synonym for `α → β` endowed with the structures of uniform convergence?

## References

* [N. Bourbaki, *General Topology, Chapter X*][bourbaki1966]

## Tags

uniform convergence
-/

noncomputable theory
open_locale topological_space classical uniformity filter

local attribute [-instance] Pi.uniform_space
local attribute [-instance] Pi.topological_space

open set filter

namespace uniform_convergence

variables (α β : Type*) {γ ι : Type*}
variables {F : ι → α → β} {f : α → β} {s s' : set α} {x : α} {p : filter ι} {g : ι → α}

/-- Basis sets for the uniformity of uniform convergence: `gen α β V` is the set of pairs `(f, g)`
of functions `α → β` such that `∀ x, (f x, g x) ∈ V`. -/
protected def gen (V : set (β × β)) : set ((α → β) × (α → β)) :=
  {uv : (α → β) × (α → β) | ∀ x, (uv.1 x, uv.2 x) ∈ V}

/-- If `𝓕` is a filter on `β × β`, then the set of all `uniform_convergence.gen α β V` for
`V ∈ 𝓕` is too. This will only be applied to `𝓕 = 𝓤 β` when `β` is equipped with a `uniform_space`
structure, but it is useful to define it for any filter in order to be able to state that it
has a lower adjoint (see `uniform_convergence.gc`). -/
protected lemma is_basis_gen (𝓑 : filter $ β × β) :
  is_basis (λ V : set (β × β), V ∈ 𝓑) (uniform_convergence.gen α β) :=
⟨⟨univ, univ_mem⟩, λ U V hU hV, ⟨U ∩ V, inter_mem hU hV, λ uv huv,
  ⟨λ x, (huv x).left, λ x, (huv x).right⟩⟩⟩

/-- For `𝓕 : filter (β × β)`, this is the set of all `uniform_convergence.gen α β V` for
`V ∈ 𝓕` is as a bundled `filter_basis`. This will only be applied to `𝓕 = 𝓤 β` when `β` is
equipped with a `uniform_space` structure, but it is useful to define it for any filter in order
to be able to state that it has a lower adjoint (see `uniform_convergence.gc`). -/
protected def basis (𝓕 : filter $ β × β) : filter_basis ((α → β) × (α → β)) :=
(uniform_convergence.is_basis_gen α β 𝓕).filter_basis

/-- For `𝓕 : filter (β × β)`, this is the filter generated by the filter basis
`uniform_convergence.basis α β 𝓕`. For `𝓕 = 𝓤 β`, this will be the uniformity of uniform
convergence on `α`. -/
protected def filter (𝓕 : filter $ β × β) : filter ((α → β) × (α → β)) :=
(uniform_convergence.basis α β 𝓕).filter

local notation `Φ` :=
λ (α β : Type*) (uvx : ((α → β) × (α → β)) × α), (uvx.1.1 uvx.2, uvx.1.2 uvx.2)

/- This is a lower adjoint to `uniform_convergence.filter` (see `uniform_convergence.gc`).
The exact definition of the lower adjoint `l` is not interesting; we will only use that it exists
(in `uniform_convergence.mono` and `uniform_convergence.infi_eq`) and that
`l (filter.map (prod.map f f) 𝓕) = filter.map (prod.map ((∘) f) ((∘) f)) (l 𝓕)` for each
`𝓕 : filter (γ × γ)` and `f : γ → α` (in `uniform_convergence.comap_eq`). -/
local notation `lower_adjoint` :=
λ 𝓐, map (Φ α β) (𝓐 ×ᶠ ⊤)

/-- The function `uniform_convergence.filter α β : filter (β × β) → filter ((α → β) × (α → β))`
has a lower adjoint `l` (in the sense of `galois_connection`). The exact definition of `l` is not
interesting; we will only use that it exists (in `uniform_convergence.mono` and
`uniform_convergence.infi_eq`) and that
`l (filter.map (prod.map f f) 𝓕) = filter.map (prod.map ((∘) f) ((∘) f)) (l 𝓕)` for each
`𝓕 : filter (γ × γ)` and `f : γ → α` (in `uniform_convergence.comap_eq`). -/
protected lemma gc : galois_connection lower_adjoint
  (λ 𝓕, uniform_convergence.filter α β 𝓕) :=
begin
  intros 𝓐 𝓕,
  symmetry,
  calc 𝓐 ≤ uniform_convergence.filter α β 𝓕
      ↔ (uniform_convergence.basis α β 𝓕).sets ⊆ 𝓐.sets :
        by rw [uniform_convergence.filter, ← filter_basis.generate, sets_iff_generate]
  ... ↔ ∀ U ∈ 𝓕, uniform_convergence.gen α β U ∈ 𝓐 : image_subset_iff
  ... ↔ ∀ U ∈ 𝓕, {uv | ∀ x, (uv, x) ∈
          {t : ((α → β) × (α → β)) × α | (t.1.1 t.2, t.1.2 t.2) ∈ U}} ∈ 𝓐 : iff.rfl
  ... ↔ ∀ U ∈ 𝓕, {uvx : ((α → β) × (α → β)) × α | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) ∈ U} ∈
          𝓐 ×ᶠ (⊤ : filter α) : forall₂_congr (λ U hU, mem_prod_top.symm)
  ... ↔ lower_adjoint 𝓐 ≤ 𝓕 : iff.rfl,
end

variables [uniform_space β]

/-- Core of the uniform structure of uniform convergence. -/
protected def uniform_core : uniform_space.core (α → β) :=
uniform_space.core.mk_of_basis (uniform_convergence.basis α β (𝓤 β))
  (λ U ⟨V, hV, hVU⟩ f, hVU ▸ λ x, refl_mem_uniformity hV)
  (λ U ⟨V, hV, hVU⟩, hVU ▸ ⟨uniform_convergence.gen α β (prod.swap ⁻¹' V),
    ⟨prod.swap ⁻¹' V, tendsto_swap_uniformity hV, rfl⟩, λ uv huv x, huv x⟩)
  (λ U ⟨V, hV, hVU⟩, hVU ▸ let ⟨W, hW, hWV⟩ := comp_mem_uniformity_sets hV in
    ⟨uniform_convergence.gen α β W, ⟨W, hW, rfl⟩, λ uv ⟨w, huw, hwv⟩ x, hWV
      ⟨w x, by exact ⟨huw x, hwv x⟩⟩⟩)

/-- Uniform structure of uniform convergence. We will denote it `𝒰(α, β, uβ)`. -/
protected def uniform_space : uniform_space (α → β) :=
uniform_space.of_core (uniform_convergence.uniform_core α β)

local attribute [instance] uniform_convergence.uniform_space
local notation `𝒰(` α `,` β `,` u `)` := @uniform_convergence.uniform_space α β u

/-- By definition, the uniformity of `α → β` endowed with the structure of uniform convergence on
`α` admits the family `{(f, g) | ∀ x, (f x, g x) ∈ V}` for `V ∈ 𝓤 β` as a filter basis. -/
protected lemma has_basis_uniformity :
  (𝓤 (α → β)).has_basis (λ V, V ∈ 𝓤 β)
  (uniform_convergence.gen α β) :=
(uniform_convergence.is_basis_gen α β (𝓤 β)).has_basis

/-- Topology of uniform convergence. -/
protected def topological_space : topological_space (α → β) :=
(𝒰(α, β, infer_instance)).to_topological_space

/-- If `α → β` is endowed with the topology of uniform convergence, `𝓝 f` admits the family
`{g | ∀ x, (f x, g x) ∈ V}` for `V ∈ 𝓤 β` as a filter basis. -/
protected lemma has_basis_nhds :
  (𝓝 f).has_basis (λ V, V ∈ 𝓤 β)
  (λ V, {g | (f, g) ∈ uniform_convergence.gen α β V}) :=
nhds_basis_uniformity' (uniform_convergence.has_basis_uniformity α β)

variables {α}

/-- Evaluation at a fixed point is uniformly continuous for `𝒰(α, β, uβ)`. -/
lemma uniform_continuous_eval (x : α) : uniform_continuous (function.eval x : (α → β) → β) :=
begin
  change _ ≤ _,
  rw [map_le_iff_le_comap,
      (uniform_convergence.has_basis_uniformity α β).le_basis_iff ((𝓤 _).basis_sets.comap _)],
  exact λ U hU, ⟨U, hU, λ uv huv, huv x⟩
end

variables {β}

/-- If `u₁` and `u₂` are two uniform structures on `γ` and `u₁ ≤ u₂`, then
`𝒰(α, γ, u₁) ≤ 𝒰(α, γ, u₂)`. -/
protected lemma mono : monotone (@uniform_convergence.uniform_space α γ) :=
λ u₁ u₂ hu, (uniform_convergence.gc α γ).monotone_u hu

/-- If `u` is a family of uniform structures on `γ`, then
`𝒰(α, γ, (⨅ i, u i)) = ⨅ i, 𝒰(α, γ, u i)`. -/
protected lemma infi_eq {u : ι → uniform_space γ} :
  (𝒰(α, γ, ⨅ i, u i)) = ⨅ i, 𝒰(α, γ, u i) :=
begin
  -- This follows directly from the fact that the upper adjoint in a Galois connection maps
  -- infimas to infimas.
  ext : 1,
  change uniform_convergence.filter α γ (@uniformity _ (⨅ i, u i)) =
    @uniformity _ (⨅ i, (𝒰(α, γ, u i))),
  rw [infi_uniformity', infi_uniformity'],
  exact (uniform_convergence.gc α γ).u_infi
end

/-- If `u₁` and `u₂` are two uniform structures on `γ`, then
`𝒰(α, γ, u₁ ⊓ u₂) = 𝒰(α, γ, u₁) ⊓ 𝒰(α, γ, u₂)`. -/
protected lemma inf_eq {u₁ u₂ : uniform_space γ} :
  (𝒰(α, γ, u₁ ⊓ u₂)) = (𝒰(α, γ, u₁)) ⊓ (𝒰(α, γ, u₂)) :=
begin
  -- This follows directly from the fact that the upper adjoint in a Galois connection maps
  -- infimas to infimas.
  rw [inf_eq_infi, inf_eq_infi, uniform_convergence.infi_eq],
  refine infi_congr (λ i, _),
  cases i; refl
end

/-- If `u` is a uniform structures on `β` and `f : γ → β`, then
`𝒰(α, γ, comap f u) = comap (λ g, f ∘ g) 𝒰(α, γ, u₁)`. -/
protected lemma comap_eq {f : γ → β} :
  (𝒰(α, γ, ‹uniform_space β›.comap f)) = (𝒰(α, β, _)).comap ((∘) f) :=
begin
  letI : uniform_space γ := ‹uniform_space β›.comap f,
  ext : 1,
  change (uniform_convergence.filter α γ ((𝓤 β).comap _)) =
    (uniform_convergence.filter α β ((𝓤 β))).comap _,
  -- We have the following four Galois connection which form a square diagram, and we want
  -- to show that the square of upper adjoints is commutative. The trick then is to use
  -- `galois_connection.u_comm_of_l_comm` to reduce it to commutativity of the lower adjoints,
  -- which is way easier to prove.
  have h₁ := filter.gc_map_comap (prod.map ((∘) f) ((∘) f)),
  have h₂ := filter.gc_map_comap (prod.map f f),
  have h₃ := uniform_convergence.gc α β,
  have h₄ := uniform_convergence.gc α γ,
  refine galois_connection.u_comm_of_l_comm h₁ h₂ h₃ h₄ (λ 𝓐, _),
  have : prod.map f f ∘ (Φ α γ) =
    (Φ α β) ∘ prod.map (prod.map ((∘) f) ((∘) f)) id,
  { ext; refl },
  rw [map_comm this, ← prod_map_map_eq'],
  refl
end

/-- Post-composition by a uniformly continuous function is uniformly continuous for the
uniform structures of uniform convergence.

More precisely, if `f : (γ, uγ) → (β, uβ)` is uniformly continuous, then
`(λ g, f ∘ g) : (α → γ, 𝒰(α, γ, uγ)) → (α → β, 𝒰(α, β, uβ))` is uniformly continuous. -/
protected lemma postcomp_uniform_continuous [uniform_space γ] {f : γ → β}
  (hf : uniform_continuous f):
  uniform_continuous ((∘) f : (α → γ) → α → β) :=
-- This is a direct consequence of `uniform_convergence.comap_eq`
uniform_continuous_iff.mpr $
calc 𝒰(α, γ, _)
    ≤ 𝒰(α, γ, ‹uniform_space β›.comap f) :
      uniform_convergence.mono (uniform_continuous_iff.mp hf)
... = (𝒰(α, β, _)).comap ((∘) f) :
      uniform_convergence.comap_eq

/-- Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of uniform convergence.

More precisely, if `f : (γ, uγ) → (β, uβ)` is a uniform inducing, then
`(λ g, f ∘ g) : (α → γ, 𝒰(α, γ, uγ)) → (α → β, 𝒰(α, β, uβ))` is a uniform inducing. -/
protected lemma postcomp_uniform_inducing [uniform_space γ] {f : γ → β}
  (hf : uniform_inducing f):
  uniform_inducing ((∘) f : (α → γ) → α → β) :=
-- This is a direct consequence of `uniform_convergence.comap_eq`
begin
  split,
  replace hf : (𝓤 β).comap (prod.map f f) = _ := hf.comap_uniformity,
  change comap (prod.map ((∘) f) ((∘) f)) _ = _,
  rw [← uniformity_comap rfl] at ⊢ hf,
  congr,
  rw [← uniform_space_eq hf, uniform_convergence.comap_eq]
end

/-- Turn a uniform isomorphism `(γ, uγ) ≃ᵤ (β, uβ)` into a uniform isomorphism
`(α → γ, 𝒰(α, γ, uγ)) ≃ᵤ (α → β, 𝒰(α, β, uβ))` by post-composing. -/
protected def congr_right [uniform_space γ] (e : γ ≃ᵤ β) :
  (α → γ) ≃ᵤ (α → β) :=
{ uniform_continuous_to_fun :=
    uniform_convergence.postcomp_uniform_continuous e.uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_convergence.postcomp_uniform_continuous e.symm.uniform_continuous,
  .. equiv.Pi_congr_right (λ a, e.to_equiv) }

/-- Pre-composition by a any function is uniformly continuous for the uniform structures of
uniform convergence.

More precisely, for any `f : γ → α`, the function
`(λ g, g ∘ f) : (α → β, 𝒰(α, β, uβ)) → (γ → β, 𝒰(γ, β, uβ))` is uniformly continuous. -/
protected lemma precomp_uniform_continuous {f : γ → α} :
  uniform_continuous (λ g : α → β, g ∘ f) :=
begin
  -- Here we simply go back to filter bases.
  rw uniform_continuous_iff,
  change 𝓤 (α → β) ≤ (𝓤 (γ → β)).comap (prod.map (λ g : α → β, g ∘ f) (λ g : α → β, g ∘ f)),
  rw (uniform_convergence.has_basis_uniformity α β).le_basis_iff
    ((uniform_convergence.has_basis_uniformity γ β).comap _),
  exact λ U hU, ⟨U, hU, λ uv huv x, huv (f x)⟩
end

/-- Turn a bijection `γ ≃ α` into a uniform isomorphism
`(γ → β, 𝒰(γ, β, uβ)) ≃ᵤ (α → β, 𝒰(α, β, uβ))` by pre-composing. -/
protected def congr_left (e : γ ≃ α) :
  (γ → β) ≃ᵤ (α → β) :=
{ uniform_continuous_to_fun :=
    uniform_convergence.precomp_uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_convergence.precomp_uniform_continuous,
  .. equiv.arrow_congr e (equiv.refl _) }

/-- The topology of uniform convergence is T₂. -/
lemma t2_space [t2_space β] : t2_space (α → β) :=
{ t2 :=
  begin
    letI : uniform_space (α → β) := 𝒰(α, β, _),
    letI : topological_space (α → β) := uniform_convergence.topological_space α β,
    intros f g h,
    obtain ⟨x, hx⟩ := not_forall.mp (mt funext h),
    exact separated_by_continuous (uniform_continuous_eval β x).continuous hx
  end }

/-- The uniform structure of uniform convergence is finer than that of pointwise convergence,
aka the product uniform structure. -/
protected lemma le_Pi : 𝒰(α, β, _) ≤ Pi.uniform_space (λ _, β) :=
begin
  -- By definition of the product uniform structure, this is just `uniform_continuous_eval`.
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi],
  intros x,
  exact uniform_continuous_eval β x
end

/-- The topology of uniform convergence indeed gives the same notion of convergence as
`tendsto_uniformly`. -/
protected lemma tendsto_iff_tendsto_uniformly : tendsto F p (𝓝 f) ↔ tendsto_uniformly F f p :=
begin
  letI : uniform_space (α → β) := 𝒰(α, β, _),
  rw [(uniform_convergence.has_basis_nhds α β).tendsto_right_iff, tendsto_uniformly],
  exact iff.rfl,
end

/-- The natural bijection between `α → β × γ` and `(α → β) × (α → γ)`, upgraded to a uniform
isomorphism between `(α → β × γ, 𝒰(α, β × γ, uβ × uγ))` and
`((α → β) × (α → γ), 𝒰(α, β, uβ) × 𝒰(α, γ, uγ))`. -/
protected def uniform_equiv_prod_arrow [uniform_space γ] :
  (α → β × γ) ≃ᵤ ((α → β) × (α → γ)) :=
-- Denote `φ` this bijection. We want to show that
-- `comap φ (𝒰(α, β, uβ) × 𝒰(α, γ, uγ)) = 𝒰(α, β × γ, uβ × uγ)`.
-- But `uβ × uγ` is defined as `comap fst uβ ⊓ comap snd uγ`, so we just have to apply
-- `uniform_convergence.inf_eq` and `uniform_convergence.comap_eq`, and then chase
-- a diagram.
(equiv.arrow_prod_equiv_prod_arrow _ _ _).to_uniform_equiv_of_uniform_inducing
begin
  split,
  change comap (prod.map (equiv.arrow_prod_equiv_prod_arrow _ _ _)
    (equiv.arrow_prod_equiv_prod_arrow _ _ _)) _ = _,
  rw ← uniformity_comap rfl,
  congr,
  rw [prod.uniform_space, uniform_space.of_core_eq_to_core, prod.uniform_space,
      uniform_space.of_core_eq_to_core, uniform_space.comap_inf, uniform_convergence.inf_eq],
  congr;
  rw [← uniform_space.comap_comap, uniform_convergence.comap_eq];
  refl -- this is the diagram chase
end

variables (α) (δ : ι → Type*) [Π i, uniform_space (δ i)]

local attribute [-instance] uniform_convergence.uniform_space

/-- The natural bijection between `α → Π i, δ i` and `Π i, α → δ i`, upgraded to a uniform
isomorphism between `(α → (Π i, δ i), 𝒰(α, (Π i, δ i), (Π i, uδ i)))` and
`((Π i, α → δ i), (Π i, 𝒰(α, δ i, uδ i)))`. -/
protected def uniform_equiv_Pi_comm : @uniform_equiv (α → Π i, δ i) (Π i, α → δ i)
  (𝒰(α, Π i, δ i, Pi.uniform_space δ))
  (@Pi.uniform_space ι (λ i, α → δ i) (λ i, 𝒰(α, δ i, _))) :=
-- Denote `φ` this bijection. We want to show that
-- `comap φ (Π i, 𝒰(α, δ i, uδ i)) = 𝒰(α, (Π i, δ i), (Π i, uδ i))`.
-- But `Π i, uδ i` is defined as `⨅ i, comap (eval i) (uδ i)`, so we just have to apply
-- `uniform_convergence.infi_eq` and `uniform_convergence.comap_eq`, and then chase
-- a diagram.
@equiv.to_uniform_equiv_of_uniform_inducing _ _
  (𝒰(α, Π i, δ i, Pi.uniform_space δ))
  (@Pi.uniform_space ι (λ i, α → δ i) (λ i, 𝒰(α, δ i, _)))
  (equiv.Pi_comm _)
begin
  split,
  change comap (prod.map function.swap function.swap) _ = _,
  rw ← uniformity_comap rfl,
  congr,
  rw [Pi.uniform_space, uniform_space.of_core_eq_to_core, Pi.uniform_space,
      uniform_space.of_core_eq_to_core, uniform_space.comap_infi, uniform_convergence.infi_eq],
  refine infi_congr (λ i, _),
  rw [← uniform_space.comap_comap, uniform_convergence.comap_eq]
  -- Like in the previous lemma, the diagram chase is actually true by defeq
end

end uniform_convergence

namespace uniform_convergence_on

variables (α β : Type*) {γ ι : Type*} [uniform_space β] (𝔖 : set (set α))
variables {F : ι → α → β} {f : α → β} {s s' : set α} {x : α} {p : filter ι} {g : ι → α}

local notation `𝒰(` α `,` β `,` u `)` := @uniform_convergence.uniform_space α β u

/-- Uniform structure of `𝔖`-convergence, i.e uniform convergence on the elements of `𝔖`.
It is defined as the infimum, for `S ∈ 𝔖`, of the pullback of `𝒰 S β` by `S.restrict`, the
map of restriction to `S`. We will denote it `𝒱(α, β, 𝔖, uβ)`, where `uβ` is the uniform structure
on `β`. -/
protected def uniform_space : uniform_space (α → β) :=
⨅ (s : set α) (hs : s ∈ 𝔖), uniform_space.comap s.restrict
  (𝒰(s, β, _))

local notation `𝒱(` α `,` β `,` 𝔖 `,` u `)` := @uniform_convergence_on.uniform_space α β u 𝔖

/-- Topology of `𝔖`-convergence, i.e uniform convergence on the elements of `𝔖`. -/
protected def topological_space : topological_space (α → β) :=
(𝒱(α, β, 𝔖, _)).to_topological_space

/-- The topology of `𝔖`-convergence is the infimum, for `S ∈ 𝔖`, of topology induced by the map
of restriction to `S`, where `↥S → β` is endowed with the topology of uniform convergence. -/
protected lemma topological_space_eq :
  uniform_convergence_on.topological_space α β 𝔖 = ⨅ (s : set α) (hs : s ∈ 𝔖),
  topological_space.induced s.restrict (uniform_convergence.topological_space s β) :=
begin
  simp only [uniform_convergence_on.topological_space, to_topological_space_infi,
    to_topological_space_infi, to_topological_space_comap],
  refl
end

/-- If `S ∈ 𝔖`, then the restriction to `S` is a uniformly continuous map from `𝒱(α, β, 𝔖, uβ)` to
`𝒰(↥S, β, uβ)`. -/
protected lemma uniform_continuous_restrict (h : s ∈ 𝔖) :
  @uniform_continuous _ _ (𝒱(α, β, 𝔖, _))
  (𝒰(s, β, _)) s.restrict :=
begin
  change _ ≤ _,
  rw [uniform_convergence_on.uniform_space, map_le_iff_le_comap, uniformity, infi_uniformity],
  refine infi_le_of_le s _,
  rw infi_uniformity,
  exact infi_le _ h,
end

variables {α}

/-- Let `u₁`, `u₂` be two uniform structures on `γ` and `𝔖₁ 𝔖₂ : set (set α)`. If `u₁ ≤ u₂` and
`𝔖₂ ⊆ 𝔖₁` then `𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)`. -/
protected lemma mono ⦃u₁ u₂ : uniform_space γ⦄ (hu : u₁ ≤ u₂) ⦃𝔖₁ 𝔖₂ : set (set α)⦄
  (h𝔖 : 𝔖₂ ⊆ 𝔖₁) :
  𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂) :=
calc 𝒱(α, γ, 𝔖₁, u₁)
    ≤ 𝒱(α, γ, 𝔖₂, u₁) : infi_le_infi_of_subset h𝔖
... ≤ 𝒱(α, γ, 𝔖₂, u₂) : infi₂_mono
        (λ i hi, uniform_space.comap_mono $ uniform_convergence.mono hu)

/-- If `x : α` is in some `S ∈ 𝔖`, then evaluation at `x` is uniformly continuous for
`𝒱(α, β, 𝔖, uβ)`. -/
lemma uniform_continuous_eval_of_mem {x : α} (hxs : x ∈ s) (hs : s ∈ 𝔖) :
  @uniform_continuous _ _ 𝒱(α, β, 𝔖, _) _ (function.eval x) :=
@uniform_continuous.comp (α → β) (s → β) β (𝒱(α, β, 𝔖, _)) (𝒰(s, β, _)) _ _ _
  (uniform_convergence.uniform_continuous_eval β (⟨x, hxs⟩ : s))
  (uniform_convergence_on.uniform_continuous_restrict α β 𝔖 hs)

variables {β} {𝔖}

/-- If `u` is a family of uniform structures on `γ`, then
`𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)`. -/
protected lemma infi_eq {u : ι → uniform_space γ} :
  𝒱(α, γ, 𝔖, ⨅ i, u i) =
  ⨅ i, 𝒱(α, γ, 𝔖, u i) :=
begin
  simp_rw [uniform_convergence_on.uniform_space, uniform_convergence.infi_eq,
    uniform_space.comap_infi],
  rw infi_comm,
  exact infi_congr (λ s, infi_comm)
end

/-- If `u₁` and `u₂` are two uniform structures on `γ`, then
`𝒱(α, γ, 𝔖, u₁ ⊓ u₂) = 𝒱(α, γ, 𝔖, u₁) ⊓ 𝒱(α, γ, 𝔖, u₂)`. -/
protected lemma inf_eq {u₁ u₂ : uniform_space γ} :
  𝒱(α, γ, 𝔖, u₁ ⊓ u₂) =
  𝒱(α, γ, 𝔖, u₁) ⊓
  𝒱(α, γ, 𝔖, u₂) :=
begin
  rw [inf_eq_infi, inf_eq_infi, uniform_convergence_on.infi_eq],
  refine infi_congr (λ i, _),
  cases i; refl
end

/-- If `u` is a uniform structures on `β` and `f : γ → β`, then
`𝒱(α, γ, 𝔖, comap f u) = comap (λ g, f ∘ g) 𝒱(α, γ, 𝔖, u₁)`. -/
protected lemma comap_eq {f : γ → β} :
  𝒱(α, γ, 𝔖, ‹uniform_space β›.comap f) =
  𝒱(α, β, 𝔖, _).comap ((∘) f) :=
begin
  -- We reduce this to `uniform_convergence.comap_eq` using the fact that `comap` distributes
  -- on `infi`.
  simp_rw [uniform_convergence_on.uniform_space, uniform_space.comap_infi,
            uniform_convergence.comap_eq, ← uniform_space.comap_comap],
  refl -- small diagram chase
end

/-- Post-composition by a uniformly continuous function is uniformly continuous for the
uniform structures of `𝔖`-convergence.

More precisely, if `f : (γ, uγ) → (β, uβ)` is uniformly continuous, then
`(λ g, f ∘ g) : (α → γ, 𝒱(α, γ, 𝔖, uγ)) → (α → β, 𝒱(α, β, 𝔖, uβ))` is uniformly continuous. -/
protected lemma postcomp_uniform_continuous [uniform_space γ] {f : γ → β}
  (hf : uniform_continuous f):
  @uniform_continuous (α → γ) (α → β) 𝒱(α, γ, 𝔖, _) 𝒱(α, β, 𝔖, _) ((∘) f) :=
begin
  -- This is a direct consequence of `uniform_convergence.comap_eq`
  rw uniform_continuous_iff,
  calc 𝒱(α, γ, 𝔖, _)
      ≤ 𝒱(α, γ, 𝔖, ‹uniform_space β›.comap f) :
        uniform_convergence_on.mono (uniform_continuous_iff.mp hf) (subset_rfl)
  ... = 𝒱(α, β, 𝔖, _).comap ((∘) f) :
        uniform_convergence_on.comap_eq
end

/-- Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of `𝔖`-convergence.

More precisely, if `f : (γ, uγ) → (β, uβ)` is a uniform inducing, then
`(λ g, f ∘ g) : (α → γ, 𝒱(α, γ, 𝔖, uγ)) → (α → β, 𝒱(α, β, 𝔖, uβ))` is a uniform inducing. -/
protected lemma postcomp_uniform_inducing [uniform_space γ] {f : γ → β}
  (hf : uniform_inducing f):
  @uniform_inducing (α → γ) (α → β) 𝒱(α, γ, 𝔖, _) 𝒱(α, β, 𝔖, _) ((∘) f) :=
-- This is a direct consequence of `uniform_convergence.comap_eq`
begin
  split,
  replace hf : (𝓤 β).comap (prod.map f f) = _ := hf.comap_uniformity,
  change comap (prod.map ((∘) f) ((∘) f)) _ = _,
  rw [← uniformity_comap rfl] at ⊢ hf,
  congr,
  rw [← uniform_space_eq hf, uniform_convergence_on.comap_eq]
end

/-- Turn a uniform isomorphism `(γ, uγ) ≃ᵤ (β, uβ)` into a uniform isomorphism
`(α → γ, 𝒱(α, γ, 𝔖, uγ)) ≃ᵤ (α → β, 𝒱(α, β, 𝔖, uβ))` by post-composing. -/
protected def congr_right [uniform_space γ] (e : γ ≃ᵤ β) :
  @uniform_equiv (α → γ) (α → β)
  𝒱(α, γ, 𝔖, _) 𝒱(α, β, 𝔖, _) :=
{ uniform_continuous_to_fun :=
    uniform_convergence_on.postcomp_uniform_continuous e.uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_convergence_on.postcomp_uniform_continuous e.symm.uniform_continuous,
  .. equiv.Pi_congr_right (λ a, e.to_equiv) }

/-- Let `f : γ → α`, `𝔖 : set (set α)`, `𝔗 : set (set γ)`, and assume that `∀ T ∈ 𝔗, f '' T ∈ 𝔖`.
Then, the function `(λ g, g ∘ f) : (α → β, 𝒱(α, β, 𝔖, uβ)) → (γ → β, 𝒱(γ, β, 𝔗 uβ))` is
uniformly continuous.

Note that one can easily see that assuming `∀ T ∈ 𝔗, ∃ S ∈ 𝔖, f '' T ⊆ S` would work too, but
we will get this for free when we prove that `𝒱(α, β, 𝔖, uβ) = 𝒱(α, β, 𝔖', uβ)` for `𝔖'` the
***noncovering*** bornology generated by `𝔖`. -/
protected lemma precomp_uniform_continuous {𝔗 : set (set γ)} {f : γ → α}
  (hf : 𝔗 ⊆ (image f) ⁻¹' 𝔖) :
  @uniform_continuous (α → β) (γ → β)
  𝒱(α, β, 𝔖, _) 𝒱(γ, β, 𝔗, _)
  (λ g : α → β, g ∘ f) :=
begin
  -- Since `comap` distributes on `infi`, it suffices to prove that
  -- `⨅ s ∈ 𝔖, comap s.restrict 𝒰(↥s, β, uβ) ≤ ⨅ t ∈ 𝔗, comap (t.restrict ∘ (— ∘ f)) 𝒰(↥t, β, uβ)`.
  simp_rw [uniform_continuous_iff, uniform_convergence_on.uniform_space, uniform_space.comap_infi,
            ← uniform_space.comap_comap],
  -- For any `t ∈ 𝔗`, note `s := f '' t ∈ 𝔖`.
  -- We will show that `comap s.restrict 𝒰(↥s, β, uβ) ≤ comap (t.restrict ∘ (— ∘ f)) 𝒰(↥t, β, uβ)`.
  refine le_infi₂ (λ t ht, infi_le_of_le (f '' t) $ infi_le_of_le (hf ht) _),
  -- Let `f'` be the map from `t` to `f '' t` induced by `f`.
  let f' : t → f '' t := (maps_to_image f t).restrict f t (f '' t),
  -- By definition `t.restrict ∘ (— ∘ f) = (— ∘ f') ∘ (f '' t).restrict`.
  have : t.restrict ∘ (λ g : α → β, g ∘ f) = (λ g : (f '' t) → β, g ∘ f') ∘ (f '' t).restrict :=
    rfl,
  -- Thus, we have to show `comap (f '' t).restrict 𝒰(↥(f '' t), β, uβ) ≤`
  -- `comap (f '' t).restrict (comap (— ∘ f') 𝒰(↥t, β, uβ))`.
  rw [this, @uniform_space.comap_comap (α → β) ((f '' t) → β)],
  -- But this is exactly monotonicity of `comap` applied to
  -- `uniform_convergence.precomp_continuous`.
  refine uniform_space.comap_mono _,
  rw ← uniform_continuous_iff,
  exact uniform_convergence.precomp_uniform_continuous
end

/-- Turn a bijection `e : γ ≃ α` such that we have both `∀ T ∈ 𝔗, e '' T ∈ 𝔖` and
`∀ S ∈ 𝔖, e ⁻¹' S ∈ 𝔗` into a uniform isomorphism `(γ → β, 𝒰(γ, β, uβ)) ≃ᵤ (α → β, 𝒰(α, β, uβ))`
by pre-composing. -/
protected def congr_left {𝔗 : set (set γ)} (e : γ ≃ α)
  (he : 𝔗 ⊆ (image e) ⁻¹' 𝔖) (he' : 𝔖 ⊆ (preimage e) ⁻¹' 𝔗) :
  @uniform_equiv (γ → β) (α → β)
  𝒱(γ, β, 𝔗, _) 𝒱(α, β, 𝔖, _) :=
{ uniform_continuous_to_fun :=
    uniform_convergence_on.precomp_uniform_continuous
    begin
      intros s hs,
      change e.symm '' s ∈ 𝔗,
      rw ← preimage_equiv_eq_image_symm,
      exact he' hs
    end,
  uniform_continuous_inv_fun :=
    uniform_convergence_on.precomp_uniform_continuous he,
  .. equiv.arrow_congr e (equiv.refl _) }

/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/
lemma t2_space_of_covering [t2_space β] (h : ⋃₀ 𝔖 = univ) :
  @t2_space _ (uniform_convergence_on.topological_space α β 𝔖) :=
{ t2 :=
  begin
    letI : uniform_space (α → β) := 𝒱(α, β, 𝔖, _),
    letI : topological_space (α → β) := uniform_convergence_on.topological_space α β 𝔖,
    intros f g hfg,
    obtain ⟨x, hx⟩ := not_forall.mp (mt funext hfg),
    obtain ⟨s, hs, hxs⟩ : ∃ s ∈ 𝔖, x ∈ s := mem_sUnion.mp (h.symm ▸ true.intro),
    exact separated_by_continuous (uniform_continuous_eval_of_mem β 𝔖 hxs hs).continuous hx
  end }

/-- If `𝔖` covers `α`, then the uniform structure of `𝔖`-convergence is finer than that of
pointwise convergence. -/
protected lemma le_Pi_of_covering (h : ⋃₀ 𝔖 = univ) :
  𝒱(α, β, 𝔖, _) ≤ Pi.uniform_space (λ _, β) :=
begin
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi],
  intros x,
  obtain ⟨s : set α, hs : s ∈ 𝔖, hxs :  x ∈ s⟩ := sUnion_eq_univ_iff.mp h x,
  exact uniform_continuous_eval_of_mem β 𝔖 hxs hs
end

/-- Convergence in the topology of `𝔖`-convergence means uniform convergence on `S` (in the sense
of `tendsto_uniformly_on`) for all `S ∈ 𝔖`. -/
protected lemma tendsto_iff_tendsto_uniformly_on :
  tendsto F p (@nhds _ (uniform_convergence_on.topological_space α β 𝔖) f) ↔
  ∀ s ∈ 𝔖, tendsto_uniformly_on F f p s :=
begin
  letI : uniform_space (α → β) := 𝒱(α, β, 𝔖, _),
  rw [uniform_convergence_on.topological_space_eq, nhds_infi, tendsto_infi],
  refine forall_congr (λ s, _),
  rw [nhds_infi, tendsto_infi],
  refine forall_congr (λ hs, _),
  rw [nhds_induced, tendsto_comap_iff, tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe,
      uniform_convergence.tendsto_iff_tendsto_uniformly],
  refl
end

/-- The natural bijection between `α → β × γ` and `(α → β) × (α → γ)`, upgraded to a uniform
isomorphism between `(α → β × γ, 𝒱(α, β × γ, 𝔖, uβ × uγ))` and
`((α → β) × (α → γ), 𝒱(α, β, 𝔖, uβ) × 𝒰(α, γ, 𝔖, uγ))`. -/
protected def uniform_equiv_prod_arrow [uniform_space γ] :
  @uniform_equiv (α → β × γ) ((α → β) × (α → γ))
  𝒱(α, β × γ, 𝔖, _)
  (@prod.uniform_space _ _ 𝒱(α, β, 𝔖, _) 𝒱(α, γ, 𝔖, _)) :=
-- Denote `φ` this bijection. We want to show that
-- `comap φ (𝒱(α, β, 𝔖, uβ) × 𝒱(α, γ, 𝔖, uγ)) = 𝒱(α, β × γ, 𝔖, uβ × uγ)`.
-- But `uβ × uγ` is defined as `comap fst uβ ⊓ comap snd uγ`, so we just have to apply
-- `uniform_convergence_on.inf_eq` and `uniform_convergence_on.comap_eq`, and then chase
-- a diagram.
-- We could also deduce this from `uniform_convergence.uniform_equiv_prod_arrow`, but it turns out
-- to be more annoying.
@equiv.to_uniform_equiv_of_uniform_inducing _ _
  𝒱(α, β × γ, 𝔖, _)
  (@prod.uniform_space _ _ 𝒱(α, β, 𝔖, _) 𝒱(α, γ, 𝔖, _))
  (equiv.arrow_prod_equiv_prod_arrow _ _ _)
begin
  split,
  change comap (prod.map (equiv.arrow_prod_equiv_prod_arrow _ _ _)
    (equiv.arrow_prod_equiv_prod_arrow _ _ _)) _ = _,
  rw ← uniformity_comap rfl,
  congr,
  rw [prod.uniform_space, uniform_space.of_core_eq_to_core, prod.uniform_space,
      uniform_space.of_core_eq_to_core, uniform_space.comap_inf, uniform_convergence_on.inf_eq],
  congr;
  rw [← uniform_space.comap_comap, uniform_convergence_on.comap_eq];
  refl -- this is the diagram chase
end

variables (𝔖) (δ : ι → Type*) [Π i, uniform_space (δ i)]

/-- The natural bijection between `α → Π i, δ i` and `Π i, α → δ i`, upgraded to a uniform
isomorphism between `(α → (Π i, δ i), 𝒱(α, (Π i, δ i), 𝔖, (Π i, uδ i)))` and
`((Π i, α → δ i), (Π i, 𝒱(α, δ i, 𝔖, uδ i)))`. -/
protected def uniform_equiv_Pi_comm : @uniform_equiv (α → Π i, δ i) (Π i, α → δ i)
  𝒱(α, Π i, δ i, 𝔖, Pi.uniform_space δ)
  (@Pi.uniform_space ι (λ i, α → δ i) (λ i, 𝒱(α, δ i, 𝔖, _))) :=
-- Denote `φ` this bijection. We want to show that
-- `comap φ (Π i, 𝒱(α, δ i, 𝔖, uδ i)) = 𝒱(α, (Π i, δ i), 𝔖, (Π i, uδ i))`.
-- But `Π i, uδ i` is defined as `⨅ i, comap (eval i) (uδ i)`, so we just have to apply
-- `uniform_convergence_on.infi_eq` and `uniform_convergence_on.comap_eq`, and then chase
-- a diagram.
-- We could also deduce this from `uniform_convergence.uniform_equiv_Pi_comm`, but it turns out
-- to be more annoying.
@equiv.to_uniform_equiv_of_uniform_inducing _ _
  𝒱(α, Π i, δ i, 𝔖, Pi.uniform_space δ)
  (@Pi.uniform_space ι (λ i, α → δ i) (λ i, 𝒱(α, δ i, 𝔖, _)))
  (equiv.Pi_comm _)
begin
  split,
  change comap (prod.map function.swap function.swap) _ = _,
  rw ← uniformity_comap rfl,
  congr,
  rw [Pi.uniform_space, uniform_space.of_core_eq_to_core, Pi.uniform_space,
      uniform_space.of_core_eq_to_core, uniform_space.comap_infi, uniform_convergence_on.infi_eq],
  refine infi_congr (λ i, _),
  rw [← uniform_space.comap_comap, uniform_convergence_on.comap_eq]
  -- Like in the previous lemma, the diagram chase is actually true by defeq
end

end uniform_convergence_on
