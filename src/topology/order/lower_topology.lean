/-
Copyright (c) 2022 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/
import topology.order.lattice

/-!
# Lower topology

This file introduces the lower topology on a preorder. It is shown that the lower topology on a
partial order is T₀ and the complements of the upper closures of finite subsets form a basis.

## References

* [Gierz et al, A Compendium of Continuous Lattices][GierzEtAl1980]

## Tags

lower topology, preorder
-/

/-! ### To move -/

section
variables (α : Type*) [complete_lattice α]

open set

/-- The map `(a, b) ↦ a ⊓ b` as an `Inf_hom`. -/
def inf_Inf_hom : Inf_hom (α × α) α :=
{ to_fun := λ x, x.1 ⊓ x.2,
  map_Inf' := λ s, begin
    refine le_antisymm (le_Inf _) (Inf_le_iff.2 $ λ a ha, le_inf (le_Inf _) $ le_Inf _),
    { rintro _ ⟨x, hx, rfl⟩,
      exact inf_le_inf (monotone_fst $ Inf_le hx) (monotone_snd $ Inf_le hx) },
    { rintro _ ⟨x, hx, rfl⟩,
      exact (ha $ mem_image_of_mem _ hx).trans inf_le_left },
    { rintro _ ⟨x, hx, rfl⟩,
      exact (ha $ mem_image_of_mem _ hx).trans inf_le_right }
  end }

end

variables (α β : Type*)

open set topological_space

/--
Type synonym for a preorder equipped with the lower topology
-/
def with_lower_topology := α

instance [p : preorder α] : preorder (with_lower_topology α) := p
instance [p : nonempty α] : nonempty (with_lower_topology α) := p
instance [p : inhabited α] : inhabited (with_lower_topology α) := p

instance [preorder α] : topological_space (with_lower_topology α) :=
generate_from {s | ∃ a, (Ici a)ᶜ = s}

namespace with_lower_topology

variable {α}

/-- `to_lower` is the identity function to the `with_lower_topology` of a type.  -/
@[pattern] def to_lower : α ≃ with_lower_topology α := equiv.refl _

/-- `of_lower` is the identity function from the `with_lower_topology` of a type.  -/
@[pattern] def of_lower : with_lower_topology α ≃ α := equiv.refl _

@[simp] lemma to_with_lower_topology_symm_eq : (@to_lower α).symm = @of_lower α := rfl
@[simp] lemma of_with_lower_topology_symm_eq : (@of_lower α).symm = @to_lower α := rfl
@[simp] lemma to_lower_of_lower (a : with_lower_topology α) : to_lower (of_lower a) = a := rfl
@[simp] lemma of_lower_to_lower (a : α) : of_lower (to_lower a) = a := rfl
@[simp] lemma to_lower_inj {a b : α} : to_lower a = to_lower b ↔ a = b := iff.rfl
@[simp] lemma of_lower_inj {a b : with_lower_topology α} : of_lower a = of_lower b ↔ a = b :=
iff.rfl

/-- A recursor for `with_lower_topology`. Use as `induction x using with_lower_topology.rec`. -/
protected def rec {β : with_lower_topology α → Sort*}
  (h : Π a, β (to_lower a)) : Π a, β a := λ a, h (of_lower a)

end with_lower_topology

/--
The lower topology is the topology generated by the complements of the closed intervals to infinity.
-/
class lower_topology (α : Type*) [t : topological_space α] [preorder α] : Prop :=
(topology_eq_lower_topology [] : t = generate_from {s | ∃ a, (Ici a)ᶜ = s})

instance [preorder α] : lower_topology (with_lower_topology α) := ⟨rfl⟩

lemma generate_from_is_open_eq_is_open_with_lower_topology [preorder α] (S : set α) :
  (generate_from {s : set α | ∃ (a : α), (Ici a)ᶜ = s}).is_open S =
  is_open (with_lower_topology.of_lower ⁻¹' S) := rfl

lemma generate_from_is_open_to_lower_inv [preorder α] (T : set (with_lower_topology α)) :
  (generate_from {s : set α | ∃ (a : α), (Ici a)ᶜ = s}).is_open (with_lower_topology.to_lower ⁻¹' T)
  = is_open T := rfl

namespace lower_topology

/--
The complements of the upper closures of finite subsets are a collection of lower sets
which form a basis for the lower topology.
-/
def lower_basis (α : Type*) [preorder α] :=
{s : set α | ∃ (F : set α), F.finite ∧ ↑(upper_closure F).compl = s}

section preorder

variables {α} [preorder α] [topological_space α] [lower_topology α]

/--
The with_lower_topology topology is homeomorphic to the lower_topology topology
-/
def with_lower_topology_homeomorphism : with_lower_topology α ≃ₜ α :=
{ continuous_to_fun := begin
    simp only [equiv.coe_refl],
    rw continuous_def,
    intros s hs,
    rw [equiv.to_fun_as_coe, ← generate_from_is_open_eq_is_open_with_lower_topology],
    convert hs,
    rw topology_eq_lower_topology α,
  end,
  continuous_inv_fun := begin
    simp only [equiv.coe_refl],
    rw continuous_def,
    intros s hs,
    simp only [equiv.inv_fun_as_coe, with_lower_topology.of_with_lower_topology_symm_eq],
    rw ← generate_from_is_open_to_lower_inv at hs,
    convert hs,
    rw topology_eq_lower_topology α,
  end,
  ..with_lower_topology.of_lower }

lemma is_open_iff_generate_Ici_comp {s : set α} :
  is_open s ↔ generate_open {s | ∃ a, (Ici a)ᶜ = s} s :=
by rw topology_eq_lower_topology α; refl

/--
Left-closed right-infinite intervals [a,∞) are closed in the lower topology.
-/
lemma is_closed_Ici (a : α) : is_closed (Ici a) :=
is_open_compl_iff.1 $ is_open_iff_generate_Ici_comp.2 $ generate_open.basic _ ⟨a, rfl⟩

/--
The upper closure of a finite subset is closed in the lower topology.
-/
lemma is_closed_upper_closure (F : set α) (h : F.finite) :
  is_closed (upper_closure F : set α) :=
begin
  simp only [← upper_set.infi_Ici, upper_set.coe_infi],
  exact is_closed_bUnion h (λ a h₁, is_closed_Ici a),
end

/--
Every subset open in the lower topology is a lower set.
-/
lemma is_lower_set_of_is_open {s : set α} (h : is_open s) : is_lower_set s :=
begin
  rw is_open_iff_generate_Ici_comp at h,
  induction h,
  case generate_open.basic : u h { obtain ⟨a, rfl⟩ := h, exact (is_upper_set_Ici a).compl },
  case univ : { exact is_lower_set_univ },
  case inter : u v hu1 hv1 hu2 hv2 { exact hu2.inter hv2 },
  case sUnion : _ _ ih { exact is_lower_set_sUnion ih },
end

lemma is_upper_set_of_is_closed {s : set α} (h : is_closed s) : is_upper_set s :=
is_lower_set_compl.1 $ is_lower_set_of_is_open h.is_open_compl

/--
The closure of a singleton {a} in the lower topology is the left-closed right-infinite interval
[a,∞).
-/
@[simp] lemma closure_singleton (a : α) : closure {a} = Ici a :=
subset_antisymm (closure_minimal (λ b h, h.ge) $ is_closed_Ici a) $
  (is_upper_set_of_is_closed is_closed_closure).Ici_subset (subset_closure rfl)

protected lemma is_topological_basis :
  is_topological_basis (lower_basis α) :=
begin
  convert is_topological_basis_of_subbasis (topology_eq_lower_topology α),
  simp_rw [lower_basis, upper_set.coe_compl, coe_upper_closure, compl_Union],
  ext s, split,
  { rintro ⟨F, hF, rfl⟩,
    refine ⟨(λ a, (Ici a)ᶜ) '' F, ⟨hF.image _, image_subset_iff.2 $ λ _ _, ⟨_, rfl⟩⟩, _⟩,
    rw sInter_image },
  { rintro ⟨F, ⟨hF, hs⟩, rfl⟩,
    haveI := hF.to_subtype,
    rw [subset_def, subtype.forall'] at hs,
    choose f hf using hs,
    exact ⟨_, finite_range f, by simp_rw [bInter_range, hf, sInter_eq_Inter]⟩ }
end

end preorder

section partial_order

variables {α} [partial_order α] [topological_space α] [lower_topology α]

/--
The lower topology on a partial order is T₀.
-/
@[priority 90] -- see Note [lower instance priority]
instance : t0_space α :=
begin
  rw t0_space_iff_inseparable,
  intros x y h,
  rw [inseparable_iff_closure_eq, closure_singleton, closure_singleton] at h,
  rw subset_antisymm_iff at h,
  rw le_antisymm_iff,
  split,
  { rw ← Ici_subset_Ici, apply h.2, },
  { rw ← Ici_subset_Ici, apply h.1, }
end

end partial_order

end lower_topology

section partial_order

variables [partial_order α] [partial_order β] [topological_space α] [lower_topology α]
  [topological_space β] [lower_topology β]

instance [order_bot α] [order_bot β] : lower_topology (α × β) :=
{ topology_eq_lower_topology :=
  begin
    refine le_antisymm (le_generate_from _) _,
    { rintro _ ⟨x, rfl⟩,
      exact ((lower_topology.is_closed_Ici _).prod $
        lower_topology.is_closed_Ici _).is_open_compl },
    rw [(lower_topology.is_topological_basis.prod
      lower_topology.is_topological_basis).eq_generate_from, le_generate_from_iff_subset_is_open,
      image2_subset_iff],
    rintro _ ⟨s, hs, rfl⟩ _ ⟨t, ht, rfl⟩,
    dsimp,
    simp_rw [coe_upper_closure, compl_Union, prod_eq, preimage_Inter, preimage_compl],
    -- Note: `refine` doesn't work here because it tries using `prod.topological_space`.
    apply (is_open_bInter hs $ λ a _, _).inter (is_open_bInter ht $ λ b _, _),
    { exact generate_open.basic _ ⟨(a, ⊥), by simp [Ici_prod_eq, prod_univ]⟩ },
    { exact generate_open.basic _ ⟨(⊥, b), by simp [Ici_prod_eq, univ_prod]⟩ },
    all_goals { apply_instance },
  end }

end partial_order

section complete_lattice

variables {α β} [complete_lattice α] [complete_lattice β] [topological_space α]
  [lower_topology α] [topological_space β] [lower_topology β]

lemma inf_hom_continuous (f : Inf_hom α β) :
  continuous f :=
begin
  convert continuous_generated_from _,
  exact lower_topology.topology_eq_lower_topology β,
  rintro _ ⟨b, rfl⟩,
  rw [preimage_compl, is_open_compl_iff],
  convert lower_topology.is_closed_Ici (Inf $ f ⁻¹' Ici b),
  refine subset_antisymm (λ a, Inf_le) (λ a ha, le_trans _ $ order_hom_class.mono f ha),
  simp [map_Inf],
end

lemma lower_topology.continuous_inf : continuous (inf_Inf_hom α) :=
inf_hom_continuous (inf_Inf_hom α)

@[priority 90] -- see Note [lower instance priority]
instance lower_topology.has_continuous_inf : has_continuous_inf α :=
⟨lower_topology.continuous_inf⟩

end complete_lattice
