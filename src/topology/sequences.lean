/-
Copyright (c) 2018 Jan-David Salchow. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jan-David Salchow, Patrick Massot, Yury Kudryashov
-/
import topology.subset_properties
import topology.metric_space.basic

/-!
# Sequences in topological spaces

In this file we define sequences in topological spaces and show how they are related to
filters and the topology.

## Main definitions

### Set operation
* `seq_closure s`: sequential closure of a set, the set of limits of sequences of points of `s`;

### Predicates

* `is_seq_closed s`: predicate saying that a set is sequentially closed, i.e., `seq_closure s ‚äÜ s`;
* `seq_continuous f`: predicate saying that a function is sequentially continuous, i.e.,
  for any sequence `u : ‚Ñï ‚Üí X` that converges to a point `x`, the sequence `f ‚àò u` converges to
  `f x`;
* `is_seq_compact s`: predicate saying that a set is sequentially compact, i.e., every sequence
  taking values in `s` has a converging subsequence.

### Type classes

* `frechet_urysohn_space X`: a typeclass saying that a topological space is a *Fr√©chet-Urysohn
  space*, i.e., the sequential closure of any set is equal to its closure.
* `sequential_space X`: a typeclass saying that a topological space is a *sequential space*, i.e.,
  any sequentially closed set in this space is closed. This condition is weaker than being a
  Fr√©chet-Urysohn space.
* `seq_compact_space X`: a typeclass saying that a topological space is sequentially compact, i.e.,
  every sequence in `X` has a converging subsequence.

## Main results

* `seq_closure_subset_closure`: closure of a set includes its sequential closure;
* `is_closed.is_seq_closed`: a closed set is sequentially closed;
* `is_seq_closed.seq_closure_eq`: sequential closure of a sequentially closed set `s` is equal
  to `s`;
* `seq_closure_eq_closure`: in a Fr√©chet-Urysohn space, the sequential closure of a set is equal to
  its closure;
* `tendsto_nhds_iff_seq_tendsto`, `frechet_urysohn_space.of_seq_tendsto_imp_tendsto`: a topological
  space is a Fr√©chet-Urysohn space if and only if sequential convergence implies convergence;
* `topological_space.first_countable_topology.frechet_urysohn_space`: every topological space with
  first countable topology is a Fr√©chet-Urysohn space;
* `frechet_urysohn_space.to_sequential_space`: every Fr√©chet-Urysohn space is a sequential space;
* `is_seq_compact.is_compact`: a sequentially compact set in a uniform space with countably
  generated uniformity is compact.

## Tags

sequentially closed, sequentially compact, sequential space
-/

open set function filter topological_space
open_locale topological_space

variables {X Y : Type*}

/-! ### Sequential closures, sequential continuity, and sequential spaces. -/
section topological_space
variables [topological_space X] [topological_space Y]

/-- The sequential closure of a set `s : set X` in a topological space `X` is
the set of all `a : X` which arise as limit of sequences in `s`. -/
def seq_closure (s : set X) : set X :=
{a | ‚àÉ x : ‚Ñï ‚Üí X, (‚àÄ n : ‚Ñï, x n ‚àà s) ‚àß tendsto x at_top (ùìù a)}

lemma subset_seq_closure {s : set X} : s ‚äÜ seq_closure s :=
Œª p hp, ‚ü®const ‚Ñï p, Œª _, hp, tendsto_const_nhds‚ü©

/-- The sequential closure of a set is contained in the closure of that set.
The converse is not true. -/
lemma seq_closure_subset_closure {s : set X} : seq_closure s ‚äÜ closure s :=
Œª p ‚ü®x, xM, xp‚ü©, mem_closure_of_tendsto xp (univ_mem' xM)

/-- A set `s` is sequentially closed if for any converging sequence `x n` of elements of `s`,
the limit belongs to `s` as well. -/
def is_seq_closed (s : set X) : Prop :=
‚àÄ ‚¶Éx : ‚Ñï ‚Üí X‚¶Ñ ‚¶Ép : X‚¶Ñ, (‚àÄ n, x n ‚àà s) ‚Üí tendsto x at_top (ùìù p) ‚Üí p ‚àà s

/-- The sequential closure of a sequentially closed set is the set itself. -/
lemma is_seq_closed.seq_closure_eq {s : set X} (hs : is_seq_closed s) :
  seq_closure s = s :=
subset.antisymm (Œª p ‚ü®x, hx, hp‚ü©, hs hx hp) subset_seq_closure

/-- A set is sequentially closed if it is closed. -/
protected lemma is_closed.is_seq_closed {s : set X} (hc : is_closed s) : is_seq_closed s :=
Œª u x hu hx, hc.mem_of_tendsto hx (eventually_of_forall hu)

/-- A topological space is called a *Fr√©chet-Urysohn space*, if the sequential closure of any set
is equal to its closure. Since one of the inclusions is trivial, we require only the non-trivial one
in the definition. -/
class frechet_urysohn_space (X : Type*) [topological_space X] : Prop :=
(closure_subset_seq_closure : ‚àÄ s : set X, closure s ‚äÜ seq_closure s)

lemma seq_closure_eq_closure [frechet_urysohn_space X] (s : set X) :
  seq_closure s = closure s :=
seq_closure_subset_closure.antisymm $ frechet_urysohn_space.closure_subset_seq_closure s

/-- In a Fr√©chet-Urysohn space, a point belongs to the closure of a set iff it is a limit
of a sequence taking values in this set. -/
lemma mem_closure_iff_seq_limit [frechet_urysohn_space X] {s : set X} {a : X} :
  a ‚àà closure s ‚Üî ‚àÉ x : ‚Ñï ‚Üí X, (‚àÄ n : ‚Ñï, x n ‚àà s) ‚àß tendsto x at_top (ùìù a) :=
by { rw [‚Üê seq_closure_eq_closure], refl }

/-- If the domain of a function `f : Œ± ‚Üí Œ≤` is a Fr√©chet-Urysohn space, then convergence
is equivalent to sequential convergence. See also `filter.tendsto_iff_seq_tendsto` for a version
that works for any pair of filters assuming that the filter in the domain is countably generated.

This property is equivalent to the definition of `frechet_urysohn_space`, see
`frechet_urysohn_space.of_seq_tendsto_imp_tendsto`. -/
lemma tendsto_nhds_iff_seq_tendsto [frechet_urysohn_space X] {f : X ‚Üí Y} {a : X} {b : Y} :
  tendsto f (ùìù a) (ùìù b) ‚Üî ‚àÄ u : ‚Ñï ‚Üí X, tendsto u at_top (ùìù a) ‚Üí tendsto (f ‚àò u) at_top (ùìù b) :=
begin
  refine ‚ü®Œª hf u hu, hf.comp hu,
    Œª h, ((nhds_basis_closeds _).tendsto_iff (nhds_basis_closeds _)).2 _‚ü©,
  rintro s ‚ü®hbs, hsc‚ü©,
  refine ‚ü®closure (f ‚Åª¬π' s), ‚ü®mt _ hbs, is_closed_closure‚ü©, Œª x, mt $ Œª hx, subset_closure hx‚ü©,
  rw [‚Üê seq_closure_eq_closure],
  rintro ‚ü®u, hus, hu‚ü©,
  exact hsc.mem_of_tendsto (h u hu) (eventually_of_forall hus)
end

/-- An alternative construction for `frechet_urysohn_space`: if sequential convergence implies
convergence, then the space is a Fr√©chet-Urysohn space. -/
lemma frechet_urysohn_space.of_seq_tendsto_imp_tendsto
  (h : ‚àÄ (f : X ‚Üí Prop) (a : X),
    (‚àÄ u : ‚Ñï ‚Üí X, tendsto u at_top (ùìù a) ‚Üí tendsto (f ‚àò u) at_top (ùìù (f a))) ‚Üí continuous_at f a) :
  frechet_urysohn_space X :=
begin
  refine ‚ü®Œª s x hcx, _‚ü©,
  specialize h (‚àâ s) x,
  by_cases hx : x ‚àà s, { exact subset_seq_closure hx },
  simp_rw [(‚àò), continuous_at, hx, not_false_iff, nhds_true, tendsto_pure, eq_true,
    ‚Üê mem_compl_iff, eventually_mem_set, ‚Üê mem_interior_iff_mem_nhds, interior_compl] at h,
  rw [mem_compl_iff, imp_not_comm] at h,
  simp only [not_forall, not_eventually, mem_compl_iff, not_not] at h,
  rcases h hcx with ‚ü®u, hux, hus‚ü©,
  rcases extraction_of_frequently_at_top hus with ‚ü®œÜ, œÜ_mono, hœÜ‚ü©,
  exact ‚ü®u ‚àò œÜ, hœÜ, hux.comp œÜ_mono.tendsto_at_top‚ü©
end

/-- Every first-countable space is a Fr√©chet-Urysohn space. -/
@[priority 100] -- see Note [lower instance priority]
instance topological_space.first_countable_topology.frechet_urysohn_space
  [first_countable_topology X] : frechet_urysohn_space X :=
frechet_urysohn_space.of_seq_tendsto_imp_tendsto $ Œª f a, tendsto_iff_seq_tendsto.2

/-- A topological space is said to be a *sequential space* if any sequentially closed set in this
space is closed. This condition is weaker than being a Fr√©chet-Urysohn space. -/
class sequential_space (X : Type*) [topological_space X] : Prop :=
(is_closed_of_seq : ‚àÄ s : set X, is_seq_closed s ‚Üí is_closed s)

/-- Every Fr√©chet-Urysohn space is a sequential space. -/
@[priority 100] -- see Note [lower instance priority]
instance frechet_urysohn_space.to_sequential_space [frechet_urysohn_space X] :
  sequential_space X :=
‚ü®Œª s hs, by rw [‚Üê closure_eq_iff_is_closed, ‚Üê seq_closure_eq_closure, hs.seq_closure_eq]‚ü©

/-- In a sequential space, a sequentially closed set is closed. -/
protected lemma is_seq_closed.is_closed [sequential_space X] {s : set X} (hs : is_seq_closed s) :
  is_closed s :=
sequential_space.is_closed_of_seq s hs

/-- In a sequential space, a set is closed iff it's sequentially closed. -/
lemma is_seq_closed_iff_is_closed [sequential_space X] {M : set X} :
  is_seq_closed M ‚Üî is_closed M :=
‚ü®is_seq_closed.is_closed, is_closed.is_seq_closed‚ü©

/-- A function between topological spaces is sequentially continuous if it commutes with limit of
 convergent sequences. -/
def seq_continuous (f : X ‚Üí Y) : Prop :=
‚àÄ ‚¶Éx : ‚Ñï ‚Üí X‚¶Ñ ‚¶Ép : X‚¶Ñ, tendsto x at_top (ùìù p) ‚Üí tendsto (f ‚àò x) at_top (ùìù (f p))

/-- The preimage of a sequentially closed set under a sequentially continuous map is sequentially
closed. -/
lemma is_seq_closed.preimage {f : X ‚Üí Y} {s : set Y} (hs : is_seq_closed s)
  (hf : seq_continuous f) :
  is_seq_closed (f ‚Åª¬π' s) :=
Œª x p hx hp, hs hx (hf hp)

/- A continuous function is sequentially continuous. -/
protected lemma continuous.seq_continuous {f : X ‚Üí Y} (hf : continuous f) :
  seq_continuous f :=
Œª x p hx, (hf.tendsto p).comp hx

/-- A sequentially continuous function defined on a sequential space is continuous. -/
protected lemma seq_continuous.continuous [sequential_space X] {f : X ‚Üí Y} (hf : seq_continuous f) :
  continuous f :=
continuous_iff_is_closed.mpr $ Œª s hs, (hs.is_seq_closed.preimage hf).is_closed

/-- If the domain of a function is a sequential space, then continuity of this function is
equivalent to its sequential continuity. -/
lemma continuous_iff_seq_continuous [sequential_space X] {f : X ‚Üí Y} :
  continuous f ‚Üî seq_continuous f :=
‚ü®continuous.seq_continuous, seq_continuous.continuous‚ü©

lemma quotient_map.sequential_space [sequential_space X] {f : X ‚Üí Y} (hf : quotient_map f) :
  sequential_space Y :=
‚ü®Œª s hs, hf.is_closed_preimage.mp $ (hs.preimage $ hf.continuous.seq_continuous).is_closed‚ü©

/-- The quotient of a sequential space is a sequential space. -/
instance [sequential_space X] {s : setoid X} : sequential_space (quotient s) :=
quotient_map_quot_mk.sequential_space

end topological_space

section seq_compact
open topological_space topological_space.first_countable_topology
variables [topological_space X]

/-- A set `s` is sequentially compact if every sequence taking values in `s` has a
converging subsequence. -/
def is_seq_compact (s : set X) :=
‚àÄ ‚¶Éx : ‚Ñï ‚Üí X‚¶Ñ, (‚àÄ n, x n ‚àà s) ‚Üí ‚àÉ (a ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a)

/-- A space `X` is sequentially compact if every sequence in `X` has a
converging subsequence. -/
class seq_compact_space (X : Type*) [topological_space X] : Prop :=
(seq_compact_univ : is_seq_compact (univ : set X))

lemma is_seq_compact.subseq_of_frequently_in {s : set X} (hs : is_seq_compact s) {x : ‚Ñï ‚Üí X}
  (hx : ‚àÉ·∂† n in at_top, x n ‚àà s) :
  ‚àÉ (a ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
let ‚ü®œà, hœà, huœà‚ü© := extraction_of_frequently_at_top hx, ‚ü®a, a_in, œÜ, hœÜ, h‚ü© := hs huœà in
‚ü®a, a_in, œà ‚àò œÜ, hœà.comp hœÜ, h‚ü©

lemma seq_compact_space.tendsto_subseq [seq_compact_space X] (x : ‚Ñï ‚Üí X) :
  ‚àÉ a (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
let ‚ü®a, _, œÜ, mono, h‚ü© := seq_compact_space.seq_compact_univ (Œª n, mem_univ (x n)) in
‚ü®a, œÜ, mono, h‚ü©

section first_countable_topology
variables [first_countable_topology X]
open topological_space.first_countable_topology

lemma is_compact.is_seq_compact {s : set X} (hs : is_compact s) : is_seq_compact s :=
Œª x x_in,
let ‚ü®a, a_in, ha‚ü© := @hs (map x at_top) _
  (le_principal_iff.mpr (univ_mem' x_in : _)) in ‚ü®a, a_in, tendsto_subseq ha‚ü©

lemma is_compact.tendsto_subseq' {s : set X} {x : ‚Ñï ‚Üí X} (hs : is_compact s)
  (hx : ‚àÉ·∂† n in at_top, x n ‚àà s) :
  ‚àÉ (a ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
hs.is_seq_compact.subseq_of_frequently_in hx

lemma is_compact.tendsto_subseq {s : set X} {x : ‚Ñï ‚Üí X} (hs : is_compact s) (hx : ‚àÄ n, x n ‚àà s) :
  ‚àÉ (a ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
hs.is_seq_compact hx

@[priority 100] -- see Note [lower instance priority]
instance first_countable_topology.seq_compact_of_compact [compact_space X] : seq_compact_space X :=
‚ü®compact_univ.is_seq_compact‚ü©

lemma compact_space.tendsto_subseq [compact_space X] (x : ‚Ñï ‚Üí X) :
  ‚àÉ a (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
seq_compact_space.tendsto_subseq x

end first_countable_topology
end seq_compact

section uniform_space_seq_compact

open_locale uniformity
open uniform_space prod

variables [uniform_space X] {s : set X}

lemma lebesgue_number_lemma_seq {Œπ : Type*} [is_countably_generated (ùì§ X)] {c : Œπ ‚Üí set X}
  (hs : is_seq_compact s) (hc‚ÇÅ : ‚àÄ i, is_open (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ i, c i) :
  ‚àÉ V ‚àà ùì§ X, symmetric_rel V ‚àß ‚àÄ x ‚àà s, ‚àÉ i, ball x V ‚äÜ c i :=
begin
  classical,
  obtain ‚ü®V, hV, Vsymm‚ü© :
    ‚àÉ V : ‚Ñï ‚Üí set (X √ó X), (ùì§ X).has_antitone_basis V ‚àß ‚àÄ n, swap ‚Åª¬π' V n = V n,
      from uniform_space.has_seq_basis X,
  suffices : ‚àÉ n, ‚àÄ x ‚àà s, ‚àÉ i, ball x (V n) ‚äÜ c i,
  { cases this with n hn,
    exact ‚ü®V n, hV.to_has_basis.mem_of_mem trivial, Vsymm n, hn‚ü© },
  by_contradiction H,
  obtain ‚ü®x, x_in, hx‚ü© : ‚àÉ x : ‚Ñï ‚Üí X, (‚àÄ n, x n ‚àà s) ‚àß ‚àÄ n i, ¬¨ ball (x n) (V n) ‚äÜ c i,
  { push_neg at H,
    choose x hx using H,
    exact ‚ü®x, forall_and_distrib.mp hx‚ü© }, clear H,
  obtain ‚ü®x‚ÇÄ, x‚ÇÄ_in, œÜ, œÜ_mono, hlim‚ü© :
    ‚àÉ (x‚ÇÄ ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù x‚ÇÄ),
    from hs x_in, clear hs,
  obtain ‚ü®i‚ÇÄ, x‚ÇÄ_in‚ü© : ‚àÉ i‚ÇÄ, x‚ÇÄ ‚àà c i‚ÇÄ,
  { rcases hc‚ÇÇ x‚ÇÄ_in with ‚ü®_, ‚ü®i‚ÇÄ, rfl‚ü©, x‚ÇÄ_in_c‚ü©,
    exact ‚ü®i‚ÇÄ, x‚ÇÄ_in_c‚ü© }, clear hc‚ÇÇ,
  obtain ‚ü®n‚ÇÄ, hn‚ÇÄ‚ü© : ‚àÉ n‚ÇÄ, ball x‚ÇÄ (V n‚ÇÄ) ‚äÜ c i‚ÇÄ,
  { rcases (nhds_basis_uniformity hV.to_has_basis).mem_iff.mp
      (is_open_iff_mem_nhds.mp (hc‚ÇÅ i‚ÇÄ) _ x‚ÇÄ_in) with ‚ü®n‚ÇÄ, _, h‚ü©,
    use n‚ÇÄ,
    rwa ‚Üê ball_eq_of_symmetry (Vsymm n‚ÇÄ) at h }, clear hc‚ÇÅ,
  obtain ‚ü®W, W_in, hWW‚ü© : ‚àÉ W ‚àà ùì§ X, W ‚óã W ‚äÜ V n‚ÇÄ,
    from comp_mem_uniformity_sets (hV.to_has_basis.mem_of_mem trivial),
  obtain ‚ü®N, x_œÜ_N_in, hVNW‚ü© : ‚àÉ N, x (œÜ N) ‚àà ball x‚ÇÄ W ‚àß V (œÜ N) ‚äÜ W,
  { obtain ‚ü®N‚ÇÅ, h‚ÇÅ‚ü© : ‚àÉ N‚ÇÅ, ‚àÄ n ‚â• N‚ÇÅ, x (œÜ n) ‚àà ball x‚ÇÄ W,
      from tendsto_at_top'.mp hlim _ (mem_nhds_left x‚ÇÄ W_in),
    obtain ‚ü®N‚ÇÇ, h‚ÇÇ‚ü© : ‚àÉ N‚ÇÇ, V (œÜ N‚ÇÇ) ‚äÜ W,
    { rcases hV.to_has_basis.mem_iff.mp W_in with ‚ü®N, _, hN‚ü©,
      use N,
      exact subset.trans (hV.antitone $ œÜ_mono.id_le _) hN },
    have : œÜ N‚ÇÇ ‚â§ œÜ (max N‚ÇÅ N‚ÇÇ),
      from œÜ_mono.le_iff_le.mpr (le_max_right _ _),
    exact ‚ü®max N‚ÇÅ N‚ÇÇ, h‚ÇÅ _ (le_max_left _ _), trans (hV.antitone this) h‚ÇÇ‚ü© },
  suffices : ball (x (œÜ N)) (V (œÜ N)) ‚äÜ c i‚ÇÄ,
    from hx (œÜ N) i‚ÇÄ this,
  calc
    ball (x $ œÜ N) (V $ œÜ N) ‚äÜ ball (x $ œÜ N) W : preimage_mono hVNW
                         ... ‚äÜ ball x‚ÇÄ (V n‚ÇÄ)   : ball_subset_of_comp_subset x_œÜ_N_in hWW
                         ... ‚äÜ c i‚ÇÄ             : hn‚ÇÄ,
end

lemma is_seq_compact.totally_bounded (h : is_seq_compact s) : totally_bounded s :=
begin
  classical,
  apply totally_bounded_of_forall_symm,
  unfold is_seq_compact at h,
  contrapose! h,
  rcases h with ‚ü®V, V_in, V_symm, h‚ü©,
  simp_rw [not_subset] at h,
  have : ‚àÄ (t : set X), t.finite ‚Üí ‚àÉ a, a ‚àà s ‚àß a ‚àâ ‚ãÉ y ‚àà t, ball y V,
  { intros t ht,
    obtain ‚ü®a, a_in, H‚ü© : ‚àÉ a ‚àà s, ‚àÄ x ‚àà t, (x, a) ‚àâ V,
      by simpa [ht] using h t,
    use [a, a_in],
    intro H',
    obtain ‚ü®x, x_in, hx‚ü© := mem_Union‚ÇÇ.mp H',
    exact H x x_in hx },
  cases seq_of_forall_finite_exists this with u hu, clear h this,
  simp [forall_and_distrib] at hu,
  cases hu with u_in hu,
  use [u, u_in], clear u_in,
  intros x x_in œÜ,
  intros hœÜ huœÜ,
  obtain ‚ü®N, hN‚ü© : ‚àÉ N, ‚àÄ p q, p ‚â• N ‚Üí q ‚â• N ‚Üí (u (œÜ p), u (œÜ q)) ‚àà V,
    from huœÜ.cauchy_seq.mem_entourage V_in,
  specialize hN N (N+1) (le_refl N) (nat.le_succ N),
  specialize hu (œÜ $ N+1) (œÜ N) (hœÜ $ lt_add_one N),
  exact hu hN,
end

protected lemma is_seq_compact.is_compact [is_countably_generated $ ùì§ X] (hs : is_seq_compact s) :
  is_compact s :=
begin
  classical,
  rw is_compact_iff_finite_subcover,
  intros Œπ U Uop s_sub,
  rcases lebesgue_number_lemma_seq hs Uop s_sub with ‚ü®V, V_in, Vsymm, H‚ü©,
  rcases totally_bounded_iff_subset.mp hs.totally_bounded V V_in with ‚ü®t,t_sub, tfin,  ht‚ü©,
  have : ‚àÄ x : t, ‚àÉ (i : Œπ), ball x.val V ‚äÜ U i,
  { rintros ‚ü®x, x_in‚ü©,
    exact H x (t_sub x_in) },
  choose i hi using this,
  haveI : fintype t := tfin.fintype,
  use finset.image i finset.univ,
  transitivity ‚ãÉ y ‚àà t, ball y V,
  { intros x x_in,
    specialize ht x_in,
    rw mem_Union‚ÇÇ at *,
    simp_rw ball_eq_of_symmetry Vsymm,
    exact ht },
  { refine Union‚ÇÇ_mono' (Œª x x_in, _),
    exact ‚ü®i ‚ü®x, x_in‚ü©, finset.mem_image_of_mem _ (finset.mem_univ _), hi ‚ü®x, x_in‚ü©‚ü© },
end

/-- A version of Bolzano-Weistrass: in a uniform space with countably generated uniformity filter
(e.g., in a metric space), a set is compact if and only if it is sequentially compact. -/
protected lemma uniform_space.compact_iff_seq_compact [is_countably_generated $ ùì§ X] :
 is_compact s ‚Üî is_seq_compact s :=
‚ü®Œª H, H.is_seq_compact, Œª H, H.is_compact‚ü©

lemma uniform_space.compact_space_iff_seq_compact_space [is_countably_generated $ ùì§ X] :
  compact_space X ‚Üî seq_compact_space X :=
have key : is_compact (univ : set X) ‚Üî is_seq_compact univ := uniform_space.compact_iff_seq_compact,
‚ü®Œª ‚ü®h‚ü©, ‚ü®key.mp h‚ü©, Œª ‚ü®h‚ü©, ‚ü®key.mpr h‚ü©‚ü©

end uniform_space_seq_compact

section metric_seq_compact

variables [pseudo_metric_space X]
open metric

lemma seq_compact.lebesgue_number_lemma_of_metric {Œπ : Sort*} {c : Œπ ‚Üí set X}
  {s : set X} (hs : is_seq_compact s) (hc‚ÇÅ : ‚àÄ i, is_open (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ i, c i) :
  ‚àÉ Œ¥ > 0, ‚àÄ a ‚àà s, ‚àÉ i, ball a Œ¥ ‚äÜ c i :=
lebesgue_number_lemma_of_metric hs.is_compact hc‚ÇÅ hc‚ÇÇ

variables [proper_space X] {s : set X}

/-- A version of **Bolzano-Weistrass**: in a proper metric space (eg. $‚Ñù^n$),
every bounded sequence has a converging subsequence. This version assumes only
that the sequence is frequently in some bounded set. -/
lemma tendsto_subseq_of_frequently_bounded (hs : bounded s)
  {x : ‚Ñï ‚Üí X} (hx : ‚àÉ·∂† n in at_top, x n ‚àà s) :
  ‚àÉ a ‚àà closure s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
have hcs : is_seq_compact (closure s), from hs.is_compact_closure.is_seq_compact,
have hu' : ‚àÉ·∂† n in at_top, x n ‚àà closure s, from hx.mono (Œª n hn, subset_closure hn),
hcs.subseq_of_frequently_in hu'

/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $‚Ñù^n$),
every bounded sequence has a converging subsequence. -/
lemma tendsto_subseq_of_bounded (hs : bounded s) {x : ‚Ñï ‚Üí X} (hx : ‚àÄ n, x n ‚àà s) :
  ‚àÉ a ‚àà closure s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
tendsto_subseq_of_frequently_bounded hs $ frequently_of_forall hx

end metric_seq_compact
