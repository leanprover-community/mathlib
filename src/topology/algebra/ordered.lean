/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro

Theory of ordered topology.
-/
import order.liminf_limsup
import data.set.intervals
import topology.algebra.group
import topology.constructions

open classical set lattice filter topological_space
open_locale topological_space classical

universes u v w
variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}


/-- (Partially) ordered topology
Also called: partially ordered spaces (pospaces).

Usually ordered topology is used for a topology on linear ordered spaces, where the open intervals
are open sets. This is a generalization as for each linear order where open interals are open sets,
the order relation is closed. -/
class ordered_topology (Œ± : Type*) [t : topological_space Œ±] [preorder Œ±] : Prop :=
(is_closed_le' : is_closed (Œªp:Œ±√óŒ±, p.1 ‚â§ p.2))

instance : Œ† [topological_space Œ±], topological_space (order_dual Œ±) := id

section ordered_topology

section preorder
variables [topological_space Œ±] [preorder Œ±] [t : ordered_topology Œ±]
include t

lemma is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_closed {b | f b ‚â§ g b} :=
continuous_iff_is_closed.mp (hf.prod_mk hg) _ t.is_closed_le'

lemma is_closed_le' (a : Œ±) : is_closed {b | b ‚â§ a} :=
is_closed_le continuous_id continuous_const

lemma is_closed_Iic {a : Œ±} : is_closed (Iic a) :=
is_closed_le' a

lemma is_closed_ge' (a : Œ±) : is_closed {b | a ‚â§ b} :=
is_closed_le continuous_const continuous_id

lemma is_closed_Ici {a : Œ±} : is_closed (Ici a) :=
is_closed_ge' a

instance : ordered_topology (order_dual Œ±) :=
‚ü®continuous_swap _ (@ordered_topology.is_closed_le' Œ± _ _ _)‚ü©

lemma is_closed_Icc {a b : Œ±} : is_closed (Icc a b) :=
is_closed_inter is_closed_Ici is_closed_Iic

lemma le_of_tendsto_of_tendsto {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hb : b ‚â† ‚ä•)
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : {b | f b ‚â§ g b} ‚àà b) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
have tendsto (Œªb, (f b, g b)) b (ùìù (a‚ÇÅ, a‚ÇÇ)),
  by rw [nhds_prod_eq]; exact hf.prod_mk hg,
show (a‚ÇÅ, a‚ÇÇ) ‚àà {p:Œ±√óŒ± | p.1 ‚â§ p.2},
  from mem_of_closed_of_tendsto hb this t.is_closed_le' h

lemma le_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  (nt : x ‚â† ‚ä•) (lim : tendsto f x (ùìù a)) (h : f ‚Åª¬π' {c | c ‚â§ b} ‚àà x) : a ‚â§ b :=
le_of_tendsto_of_tendsto nt lim tendsto_const_nhds h

lemma ge_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  (nt : x ‚â† ‚ä•) (lim : tendsto f x (ùìù a)) (h : f ‚Åª¬π' {c | b ‚â§ c} ‚àà x) : b ‚â§ a :=
le_of_tendsto_of_tendsto nt tendsto_const_nhds lim h

@[simp] lemma closure_le_eq [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  closure {b | f b ‚â§ g b} = {b | f b ‚â§ g b} :=
closure_eq_iff_is_closed.mpr $ is_closed_le hf hg

lemma closure_lt_subset_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  closure {b | f b < g b} ‚äÜ {b | f b ‚â§ g b} :=
by { rw [‚Üêclosure_le_eq hf hg], exact closure_mono (Œª b, le_of_lt) }

end preorder

section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : ordered_topology Œ±]
include t

private lemma is_closed_eq : is_closed {p : Œ± √ó Œ± | p.1 = p.2} :=
by simp [le_antisymm_iff];
   exact is_closed_inter t.is_closed_le' (is_closed_le continuous_snd continuous_fst)

@[priority 100] -- see Note [lower instance priority]
instance ordered_topology.to_t2_space : t2_space Œ± :=
{ t2 :=
  have is_open {p : Œ± √ó Œ± | p.1 ‚â† p.2}, from is_closed_eq,
  assume a b h,
  let ‚ü®u, v, hu, hv, ha, hb, h‚ü© := is_open_prod_iff.mp this a b h in
  ‚ü®u, v, hu, hv, ha, hb,
    set.eq_empty_iff_forall_not_mem.2 $ assume a ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    have a ‚â† a, from @h (a, a) ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    this rfl‚ü© }

end partial_order

section linear_order
variables [topological_space Œ±] [linear_order Œ±] [ordered_topology Œ±]

lemma is_open_lt [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_open {b | f b < g b} :=
by simp [lt_iff_not_ge, -not_le]; exact is_closed_le hg hf

lemma is_open_Iio {a : Œ±} : is_open (Iio a) :=
is_open_lt continuous_id continuous_const

lemma is_open_Ioi {a : Œ±} : is_open (Ioi a) :=
is_open_lt continuous_const continuous_id

lemma is_open_Ioo {a b : Œ±} : is_open (Ioo a b) :=
is_open_inter is_open_Ioi is_open_Iio

end linear_order

section decidable_linear_order
variables [topological_space Œ±] [decidable_linear_order Œ±] [t : ordered_topology Œ±] {f g : Œ≤ ‚Üí Œ±}
include t

section
variables [topological_space Œ≤] (hf : continuous f) (hg : continuous g)
include hf hg

lemma frontier_le_subset_eq : frontier {b | f b ‚â§ g b} ‚äÜ {b | f b = g b} :=
begin
  rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg],
  rintros b ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©,
  refine le_antisymm hb‚ÇÅ (closure_lt_subset_le hg hf _),
  convert hb‚ÇÇ using 2, simp only [not_le.symm], refl
end

lemma frontier_lt_subset_eq : frontier {b | f b < g b} ‚äÜ {b | f b = g b} :=
by rw ‚Üê frontier_compl;
   convert frontier_le_subset_eq hg hf; simp [ext_iff, eq_comm]

lemma continuous.max : continuous (Œªb, max (f b) (g b)) :=
have ‚àÄb‚ààfrontier {b | f b ‚â§ g b}, g b = f b, from assume b hb, (frontier_le_subset_eq hf hg hb).symm,
continuous_if this hg hf

lemma continuous.min : continuous (Œªb, min (f b) (g b)) :=
have ‚àÄb‚ààfrontier {b | f b ‚â§ g b}, f b = g b, from assume b hb, frontier_le_subset_eq hf hg hb,
continuous_if this hf hg

end

lemma tendsto.max {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, max (f b) (g b)) b (ùìù (max a‚ÇÅ a‚ÇÇ)) :=
show tendsto ((Œªp:Œ±√óŒ±, max p.1 p.2) ‚àò (Œªb, (f b, g b))) b (ùìù (max a‚ÇÅ a‚ÇÇ)),
  from tendsto.comp
    begin
      rw [‚Üênhds_prod_eq],
      from continuous_iff_continuous_at.mp (continuous_fst.max continuous_snd) _
    end
    (hf.prod_mk hg)

lemma tendsto.min {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, min (f b) (g b)) b (ùìù (min a‚ÇÅ a‚ÇÇ)) :=
show tendsto ((Œªp:Œ±√óŒ±, min p.1 p.2) ‚àò (Œªb, (f b, g b))) b (ùìù (min a‚ÇÅ a‚ÇÇ)),
  from tendsto.comp
    begin
      rw [‚Üênhds_prod_eq],
      from continuous_iff_continuous_at.mp (continuous_fst.min continuous_snd) _
    end
    (hf.prod_mk hg)

end decidable_linear_order

end ordered_topology

/-- Topologies generated by the open intervals.

  This is restricted to linear orders. Only then it is guaranteed that they are also a ordered
  topology. -/
class orderable_topology (Œ± : Type*) [t : topological_space Œ±] [partial_order Œ±] : Prop :=
(topology_eq_generate_intervals : t = generate_from {s | ‚àÉa, s = Ioi a ‚à® s = Iio a})

section orderable_topology

instance {Œ± : Type*} [topological_space Œ±] [partial_order Œ±] [orderable_topology Œ±] :
  orderable_topology (order_dual Œ±) :=
‚ü®by convert @orderable_topology.topology_eq_generate_intervals Œ± _ _ _;
  conv in (_ ‚à® _) { rw or.comm }; refl‚ü©

section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : orderable_topology Œ±]
include t

lemma is_open_iff_generate_intervals {s : set Œ±} :
  is_open s ‚Üî generate_open {s | ‚àÉa, s = Ioi a ‚à® s = Iio a} s :=
by rw [t.topology_eq_generate_intervals]; refl

lemma is_open_lt' (a : Œ±) : is_open {b:Œ± | a < b} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inl rfl‚ü©

lemma is_open_gt' (a : Œ±) : is_open {b:Œ± | b < a} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inr rfl‚ü©

lemma lt_mem_nhds {a b : Œ±} (h : a < b) : {b | a < b} ‚àà ùìù b :=
mem_nhds_sets (is_open_lt' _) h

lemma le_mem_nhds {a b : Œ±} (h : a < b) : {b | a ‚â§ b} ‚àà ùìù b :=
(ùìù b).sets_of_superset (lt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma gt_mem_nhds {a b : Œ±} (h : a < b) : {a | a < b} ‚àà ùìù a :=
mem_nhds_sets (is_open_gt' _) h

lemma ge_mem_nhds {a b : Œ±} (h : a < b) : {a | a ‚â§ b} ‚àà ùìù a :=
(ùìù a).sets_of_superset (gt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma nhds_eq_orderable (a : Œ±) :
  ùìù a = (‚®Öb ‚àà Iio a, principal (Ioi b)) ‚äì (‚®Öb ‚àà Ioi a, principal (Iio b)) :=
by rw [t.topology_eq_generate_intervals, nhds_generate_from];
from le_antisymm
  (le_inf
    (le_infi $ assume b, le_infi $ assume hb,
      infi_le_of_le {c : Œ± | b < c} $ infi_le _ ‚ü®hb, b, or.inl rfl‚ü©)
    (le_infi $ assume b, le_infi $ assume hb,
      infi_le_of_le {c : Œ± | c < b} $ infi_le _ ‚ü®hb, b, or.inr rfl‚ü©))
  (le_infi $ assume s, le_infi $ assume ‚ü®ha, b, hs‚ü©,
    match s, ha, hs with
    | _, h, (or.inl rfl) := inf_le_left_of_le $ infi_le_of_le b $ infi_le _ h
    | _, h, (or.inr rfl) := inf_le_right_of_le $ infi_le_of_le b $ infi_le _ h
    end)

lemma tendsto_orderable {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤} :
  tendsto f x (ùìù a) ‚Üî (‚àÄa'<a, {b | a' < f b} ‚àà x) ‚àß (‚àÄa'>a, {b | a' > f b} ‚àà x) :=
by simp [nhds_eq_orderable a, tendsto_inf, tendsto_infi, tendsto_principal]

/-- Also known as squeeze or sandwich theorem. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a))
  (hgf : {b | g b ‚â§ f b} ‚àà b) (hfh : {b | f b ‚â§ h b} ‚àà b) :
  tendsto f b (ùìù a) :=
tendsto_orderable.2
  ‚ü®assume a' h',
    have {b : Œ≤ | a' < g b} ‚àà b, from (tendsto_orderable.1 hg).left a' h',
    by filter_upwards [this, hgf] assume a, lt_of_lt_of_le,
    assume a' h',
    have {b : Œ≤ | h b < a'} ‚àà b, from (tendsto_orderable.1 hh).right a' h',
    by filter_upwards [this, hfh] assume a h‚ÇÅ h‚ÇÇ, lt_of_le_of_lt h‚ÇÇ h‚ÇÅ‚ü©

lemma nhds_orderable_unbounded {a : Œ±} (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) :
  ùìù a = (‚®Öl (h‚ÇÇ : l < a) u (h‚ÇÇ : a < u), principal (Ioo l u)) :=
let ‚ü®u, hu‚ü© := hu, ‚ü®l, hl‚ü© := hl in
calc ùìù a = (‚®Öb<a, principal {c | b < c}) ‚äì (‚®Öb>a, principal {c | c < b}) : nhds_eq_orderable a
  ... = (‚®Öb<a, principal {c | b < c} ‚äì (‚®Öb>a, principal {c | c < b})) :
    binfi_inf hl
  ... = (‚®Öl<a, (‚®Öu>a, principal {c | c < u} ‚äì principal {c | l < c})) :
    begin
      congr, funext x,
      congr, funext hx,
      rw [inf_comm],
      apply binfi_inf hu
    end
  ... = _ : by simp [inter_comm]; refl

lemma tendsto_orderable_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤}
  (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) (h : ‚àÄl u, l < a ‚Üí a < u ‚Üí {b | l < f b ‚àß f b < u } ‚àà x) :
  tendsto f x (ùìù a) :=
by rw [nhds_orderable_unbounded hu hl];
from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl,
  tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)

end partial_order

theorem induced_orderable_topology' {Œ± : Type u} {Œ≤ : Type v}
  [partial_order Œ±] [ta : topological_space Œ≤] [partial_order Œ≤] [orderable_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b)
  (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
  @orderable_topology _ (induced f ta) _ :=
begin
  letI := induced f ta,
  refine ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_orderable (f a)],
  apply le_antisymm,
  { refine le_infi (Œª s, le_infi $ Œª hs, le_principal_iff.2 _),
    rcases hs with ‚ü®ab, b, rfl|rfl‚ü©,
    { exact mem_comap_sets.2 ‚ü®{x | f b < x},
        mem_inf_sets_of_left $ mem_infi_sets _ $ mem_infi_sets (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© },
    { exact mem_comap_sets.2 ‚ü®{x | x < f b},
        mem_inf_sets_of_right $ mem_infi_sets _ $ mem_infi_sets (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© } },
  { rw [‚Üê map_le_iff_le_comap],
    refine le_inf _ _; refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _); simp,
    { rcases H‚ÇÅ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_sets _ (mem_infi_sets ‚ü®ab, b, or.inl rfl‚ü© (mem_principal_sets.2 _)),
      exact Œª c hc, lt_of_le_of_lt xb (hf.2 hc) },
    { rcases H‚ÇÇ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_sets _ (mem_infi_sets ‚ü®ab, b, or.inr rfl‚ü© (mem_principal_sets.2 _)),
      exact Œª c hc, lt_of_lt_of_le (hf.2 hc) xb } },
end

theorem induced_orderable_topology {Œ± : Type u} {Œ≤ : Type v}
  [partial_order Œ±] [ta : topological_space Œ≤] [partial_order Œ≤] [orderable_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) :
  @orderable_topology _ (induced f ta) _ :=
induced_orderable_topology' f @hf
  (Œª a x xa, let ‚ü®b, xb, ba‚ü© := H xa in ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
  (Œª a x ax, let ‚ü®b, ab, bx‚ü© := H ax in ‚ü®b, hf.1 ab, le_of_lt bx‚ü©)

lemma nhds_top_orderable [topological_space Œ±] [order_top Œ±] [orderable_topology Œ±] :
  ùìù (‚ä§:Œ±) = (‚®Öl (h‚ÇÇ : l < ‚ä§), principal (Ioi l)) :=
by simp [nhds_eq_orderable (‚ä§:Œ±)]

lemma nhds_bot_orderable [topological_space Œ±] [order_bot Œ±] [orderable_topology Œ±] :
  ùìù (‚ä•:Œ±) = (‚®Öl (h‚ÇÇ : ‚ä• < l), principal (Iio l)) :=
by simp [nhds_eq_orderable (‚ä•:Œ±)]

section linear_order

variables [topological_space Œ±] [linear_order Œ±] [t : orderable_topology Œ±]
include t

lemma exists_Ioc_subset_of_mem_nhds' {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) {l : Œ±} (hl : l < a) :
  ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=
begin
  rw [nhds_eq_orderable a] at hs,
  rcases hs with ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, hts‚ü©,

  -- First we show that `t‚ÇÇ` includes `(-‚àû, a]`, so it suffices to show `(l', ‚àû) ‚äÜ t‚ÇÅ`
  suffices : ‚àÉ l' ‚àà Ico l a, Ioi l' ‚äÜ t‚ÇÅ,
  { have A : principal (Iic a) ‚â§ ‚®Ö b ‚àà Ioi a, principal (Iio b),
      from (le_infi $ Œª b, le_infi $ Œª hb, principal_mono.2 $ Iic_subset_Iio.2 hb),
    have B : t‚ÇÅ ‚à© Iic a ‚äÜ s,
      from subset.trans (inter_subset_inter_right _ (A ht‚ÇÇ)) hts,
    from this.imp (Œª l', Exists.imp $ Œª hl' hl x hx, B ‚ü®hl hx.1, hx.2‚ü©) },
  clear hts ht‚ÇÇ t‚ÇÇ,

  -- Now we find `l` such that `(l', ‚àû) ‚äÜ t‚ÇÅ`
  letI := classical.DLO Œ±,
  rw [mem_binfi, mem_bUnion_iff] at ht‚ÇÅ,
  { rcases ht‚ÇÅ with ‚ü®b, hb, hb'‚ü©,
    exact ‚ü®max b l, ‚ü®le_max_right _ _, max_lt hb hl‚ü©,
      Œª x hx, hb' $ Ioi_subset_Ioi (le_max_left _ _) hx‚ü© },
  { intros b hb b' hb', simp only [mem_Iio] at hb hb',
    use [max b b', max_lt hb hb'],
    simp [le_refl] },
  exact ‚ü®l, hl‚ü©
end

lemma exists_Ico_subset_of_mem_nhds' {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) {u : Œ±} (hu : a < u) :
  ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s :=
begin
  convert @exists_Ioc_subset_of_mem_nhds' (order_dual Œ±) _ _ _ _ _ hs _ hu,
  ext, rw [dual_Ico, dual_Ioc]
end

lemma exists_Ioc_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ l, l < a) :
  ‚àÉ l < a, Ioc l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := h in let ‚ü®l, hl‚ü© := exists_Ioc_subset_of_mem_nhds' hs hl' in ‚ü®l, hl.fst.2, hl.snd‚ü©

lemma exists_Ico_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ u, a < u) :
  ‚àÉ u (_ : a < u), Ico a u ‚äÜ s :=
let ‚ü®l', hl'‚ü© := h in let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl' in ‚ü®l, hl.fst.1, hl.snd‚ü©

lemma mem_nhds_unbounded {a : Œ±} {s : set Œ±} (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) :
  s ‚àà ùìù a ‚Üî (‚àÉl u, l < a ‚àß a < u ‚àß ‚àÄb, l < b ‚Üí b < u ‚Üí b ‚àà s) :=
let ‚ü®l, hl'‚ü© := hl, ‚ü®u, hu'‚ü© := hu in
have ùìù a = (‚®Öp : {l // l < a} √ó {u // a < u}, principal (Ioo p.1.val p.2.val)),
  by simp [nhds_orderable_unbounded hu hl, infi_subtype, infi_prod],
iff.intro
  (assume hs, by rw [this] at hs; from infi_sets_induct hs
    ‚ü®l, u, hl', hu', by simp‚ü©
    begin
      intro p, rcases p with ‚ü®‚ü®l, hl‚ü©, ‚ü®u, hu‚ü©‚ü©,
      simp [set.subset_def],
      intros s‚ÇÅ s‚ÇÇ hs‚ÇÅ l' hl' u' hu' hs‚ÇÇ,
      letI := classical.DLO Œ±,
      refine ‚ü®max l l', _, min u u', _‚ü©;
      simp [*, lt_min_iff, max_lt_iff] {contextual := tt}
    end
    (assume s‚ÇÅ s‚ÇÇ h ‚ü®l, u, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©, ‚ü®l, u, h‚ÇÅ, h‚ÇÇ, assume b hu hl, h $ h‚ÇÉ _ hu hl‚ü©))
  (assume ‚ü®l, u, hl, hu, h‚ü©,
    by rw [this]; exact mem_infi_sets ‚ü®‚ü®l, hl‚ü©, ‚ü®u, hu‚ü©‚ü© (assume b ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h b h‚ÇÅ h‚ÇÇ))

lemma order_separated {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
  ‚àÉu v : set Œ±, is_open u ‚àß is_open v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß (‚àÄb‚ÇÅ‚ààu, ‚àÄb‚ÇÇ‚ààv, b‚ÇÅ < b‚ÇÇ) :=
match dense_or_discrete a‚ÇÅ a‚ÇÇ with
| or.inl ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© := ‚ü®{a' | a' < a}, {a' | a < a'}, is_open_gt' a, is_open_lt' a, ha‚ÇÅ, ha‚ÇÇ,
    assume b‚ÇÅ h‚ÇÅ b‚ÇÇ h‚ÇÇ, lt_trans h‚ÇÅ h‚ÇÇ‚ü©
| or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a | a < a‚ÇÇ}, {a | a‚ÇÅ < a}, is_open_gt' a‚ÇÇ, is_open_lt' a‚ÇÅ, h, h,
    assume b‚ÇÅ hb‚ÇÅ b‚ÇÇ hb‚ÇÇ,
    calc b‚ÇÅ ‚â§ a‚ÇÅ : h‚ÇÇ _ hb‚ÇÅ
      ... < a‚ÇÇ : h
      ... ‚â§ b‚ÇÇ : h‚ÇÅ _ hb‚ÇÇ‚ü©
end

@[priority 100] -- see Note [lower instance priority]
instance orderable_topology.to_ordered_topology : ordered_topology Œ± :=
{ is_closed_le' :=
    is_open_prod_iff.mpr $ assume a‚ÇÅ a‚ÇÇ (h : ¬¨ a‚ÇÅ ‚â§ a‚ÇÇ),
      have h : a‚ÇÇ < a‚ÇÅ, from lt_of_not_ge h,
      let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h in
      ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, assume ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, not_le_of_gt $ h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü© }

lemma orderable_topology.t2_space : t2_space Œ± := by apply_instance

@[priority 100] -- see Note [lower instance priority]
instance orderable_topology.regular_space : regular_space Œ± :=
{ regular := assume s a hs ha,
    have hs' : -s ‚àà ùìù a, from mem_nhds_sets hs ha,
    have ‚àÉt:set Œ±, is_open t ‚àß (‚àÄl‚àà s, l < a ‚Üí l ‚àà t) ‚àß ùìù a ‚äì principal t = ‚ä•,
      from by_cases
        (assume h : ‚àÉl, l < a,
          let ‚ü®l, hl, h‚ü© := exists_Ioc_subset_of_mem_nhds hs' h in
          match dense_or_discrete l a with
          | or.inl ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := ‚ü®{a | a < b}, is_open_gt' _,
              assume c hcs hca, show c < b,
                from lt_of_not_ge $ assume hbc, h ‚ü®lt_of_lt_of_le hb‚ÇÅ hbc, le_of_lt hca‚ü© hcs,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_lt' _) hb‚ÇÇ) $
                assume x (hx : b < x), show ¬¨ x < b, from not_lt.2 $ le_of_lt hx‚ü©
          | or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a' | a' < a}, is_open_gt' _, assume b hbs hba, hba,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_lt' _) hl) $
                assume x (hx : l < x), show ¬¨ x < a, from not_lt.2 $ h‚ÇÅ _ hx‚ü©
          end)
        (assume : ¬¨ ‚àÉl, l < a, ‚ü®‚àÖ, is_open_empty, assume l _ hl, (this ‚ü®l, hl‚ü©).elim,
          by rw [principal_empty, inf_bot_eq]‚ü©),
    let ‚ü®t‚ÇÅ, ht‚ÇÅo, ht‚ÇÅs, ht‚ÇÅa‚ü© := this in
    have ‚àÉt:set Œ±, is_open t ‚àß (‚àÄu‚àà s, u>a ‚Üí u ‚àà t) ‚àß ùìù a ‚äì principal t = ‚ä•,
      from by_cases
        (assume h : ‚àÉu, u > a,
          let ‚ü®u, hu, h‚ü© := exists_Ico_subset_of_mem_nhds hs' h in
          match dense_or_discrete a u with
          | or.inl ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := ‚ü®{a | b < a}, is_open_lt' _,
              assume c hcs hca, show c > b,
                from lt_of_not_ge $ assume hbc, h ‚ü®le_of_lt hca, lt_of_le_of_lt hbc hb‚ÇÇ‚ü© hcs,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_gt' _) hb‚ÇÅ) $
                assume x (hx : b > x), show ¬¨ x > b, from not_lt.2 $ le_of_lt hx‚ü©
          | or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a' | a' > a}, is_open_lt' _, assume b hbs hba, hba,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_gt' _) hu) $
                assume x (hx : u > x), show ¬¨ x > a, from not_lt.2 $ h‚ÇÇ _ hx‚ü©
          end)
        (assume : ¬¨ ‚àÉu, u > a, ‚ü®‚àÖ, is_open_empty, assume l _ hl, (this ‚ü®l, hl‚ü©).elim,
          by rw [principal_empty, inf_bot_eq]‚ü©),
    let ‚ü®t‚ÇÇ, ht‚ÇÇo, ht‚ÇÇs, ht‚ÇÇa‚ü© := this in
    ‚ü®t‚ÇÅ ‚à™ t‚ÇÇ, is_open_union ht‚ÇÅo ht‚ÇÇo,
      assume x hx,
      have x ‚â† a, from assume eq, ha $ eq ‚ñ∏ hx,
      (ne_iff_lt_or_gt.mp this).imp (ht‚ÇÅs _ hx) (ht‚ÇÇs _ hx),
      by rw [‚Üêsup_principal, inf_sup_left, ht‚ÇÅa, ht‚ÇÇa, bot_sup_eq]‚ü©,
  ..orderable_topology.t2_space }

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
lemma mem_nhds_iff_exists_Ioo_subset' {a l' u' : Œ±} {s : set Œ±}
  (hl' : l' < a) (hu' : a < u') :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
begin
  split,
  { assume h,
    rcases exists_Ico_subset_of_mem_nhds' h hu' with ‚ü®u, au, hu‚ü©,
    rcases exists_Ioc_subset_of_mem_nhds' h hl' with ‚ü®l, la, hl‚ü©,
    refine ‚ü®l, u, ‚ü®la.2, au.1‚ü©, Œªx hx, _‚ü©,
    cases le_total a x with hax hax,
    { exact hu ‚ü®hax, hx.2‚ü© },
    { exact hl ‚ü®hx.1, hax‚ü© } },
  { rintros ‚ü®l, u, ha, h‚ü©,
    apply mem_sets_of_superset (mem_nhds_sets is_open_Ioo ha) h }
end

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`. -/
lemma mem_nhds_iff_exists_Ioo_subset [no_top_order Œ±] [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_iff_exists_Ioo_subset' hl' hu'

/-!
### Neighborhoods to the left and to the right

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `nhds_within a (Ioi a)` and
`nhds_wihin a (Ici a)` on the right, and similarly on the left. Such neighborhoods can be
characterized as the sets containing suitable intervals to the right or to the left of `a`.
We give now these characterizations. -/

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà nhds_within a (Ioi a) ‚Üî ‚àÉu, a < u ‚àß Ioo a u ‚äÜ s :=
begin
  split,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ico_subset_of_mem_nhds va ‚ü®u', hu'‚ü© with ‚ü®u, au, hu‚ü©,
    refine ‚ü®u, au, Œªx hx, _‚ü©,
    refine hv ‚ü®_, hx.1‚ü©,
    exact hu ‚ü®le_of_lt hx.1, hx.2‚ü© },
  { rintros ‚ü®u, au, hu‚ü©,
    rw mem_nhds_within_iff_exists_mem_nhds_inter,
    refine ‚ü®Iio u, mem_nhds_sets is_open_Iio au, _‚ü©,
    rwa [inter_comm, Ioi_inter_Iio] }
end

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset [no_top_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà nhds_within a (Ioi a) ‚Üî ‚àÉu, a < u ‚àß Ioo a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioc_subset [no_top_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (Ioi a) ‚Üî ‚àÉu, a < u ‚àß Ioc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ioi_iff_exists_Ioo_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases dense au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü© }
end

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà nhds_within a (Iio a) ‚Üî ‚àÉl, l < a ‚àß Ioo l a ‚äÜ s :=
begin
  split,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ioc_subset_of_mem_nhds va ‚ü®l', hl'‚ü© with ‚ü®l, la, hl‚ü©,
    refine ‚ü®l, la, Œªx hx, _‚ü©,
    refine hv ‚ü®_, hx.2‚ü©,
    exact hl ‚ü®hx.1, le_of_lt hx.2‚ü© },
  { rintros ‚ü®l, la, ha‚ü©,
    rw mem_nhds_within_iff_exists_mem_nhds_inter,
    refine ‚ü®Ioi l, mem_nhds_sets is_open_Ioi la, _‚ü©,
    rwa [Ioi_inter_Iio] }
end

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà nhds_within a (Iio a) ‚Üî ‚àÉl, l < a ‚àß Ioo l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ico_subset [no_bot_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (Iio a) ‚Üî ‚àÉl, l < a ‚àß Ico l a ‚äÜ s :=
begin
  rw mem_nhds_within_Iio_iff_exists_Ioo_subset,
  split,
  { rintros ‚ü®l, la, as‚ü©,
    rcases dense la with ‚ü®v, hv‚ü©,
    refine ‚ü®v, hv.2, Œªx hx, as ‚ü®lt_of_lt_of_le hv.1 hx.1, hx.2‚ü©‚ü©, },
  { rintros ‚ü®l, la, as‚ü©,
    exact ‚ü®l, la, subset.trans Ioo_subset_Ico_self as‚ü© }
end

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà nhds_within a (Ici a) ‚Üî ‚àÉu, a < u ‚àß Ico a u ‚äÜ s :=
begin
  split,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ico_subset_of_mem_nhds va ‚ü®u', hu'‚ü© with ‚ü®u, au, hu‚ü©,
    refine ‚ü®u, au, Œªx hx, _‚ü©,
    refine hv ‚ü®_, hx.1‚ü©,
    exact hu hx },
  { rintros ‚ü®u, au, hu‚ü©,
    rw mem_nhds_within_iff_exists_mem_nhds_inter,
    refine ‚ü®Iio u, mem_nhds_sets is_open_Iio au, _‚ü©,
    rwa [inter_comm, Ici_inter_Iio] }
end

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset [no_top_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà nhds_within a (Ici a) ‚Üî ‚àÉu, a < u ‚àß Ico a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_within_Ici_iff_exists_Ico_subset' hu'

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Icc_subset [no_top_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (Ici a) ‚Üî ‚àÉu, a < u ‚àß Icc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases dense au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
end

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà nhds_within a (Iic a) ‚Üî ‚àÉl, l < a ‚àß Ioc l a ‚äÜ s :=
begin
  split,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ioc_subset_of_mem_nhds va ‚ü®l', hl'‚ü© with ‚ü®l, la, hl‚ü©,
    refine ‚ü®l, la, Œªx hx, _‚ü©,
    refine hv ‚ü®_, hx.2‚ü©,
    exact hl hx },
  { rintros ‚ü®l, la, ha‚ü©,
    rw mem_nhds_within_iff_exists_mem_nhds_inter,
    refine ‚ü®Ioi l, mem_nhds_sets is_open_Ioi la, _‚ü©,
    rwa [Ioi_inter_Iic] }
end

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà nhds_within a (Iic a) ‚Üî ‚àÉl, l < a ‚àß Ioc l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Icc_subset [no_bot_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (Iic a) ‚Üî ‚àÉl, l < a ‚àß Icc l a ‚äÜ s :=
begin
  rw mem_nhds_within_Iic_iff_exists_Ioc_subset,
  split,
  { rintros ‚ü®l, la, as‚ü©,
    rcases dense la with ‚ü®v, hv‚ü©,
    refine ‚ü®v, hv.2, Œªx hx, as ‚ü®lt_of_lt_of_le hv.1 hx.1, hx.2‚ü©‚ü©, },
  { rintros ‚ü®l, la, as‚ü©,
    exact ‚ü®l, la, subset.trans Ioc_subset_Icc_self as‚ü© }
end

end linear_order

lemma preimage_neg [add_group Œ±] : preimage (has_neg.neg : Œ± ‚Üí Œ±) = image (has_neg.neg : Œ± ‚Üí Œ±) :=
(image_eq_preimage_of_inverse neg_neg neg_neg).symm

lemma filter.map_neg [add_group Œ±] : map (has_neg.neg : Œ± ‚Üí Œ±) = comap (has_neg.neg : Œ± ‚Üí Œ±) :=
funext $ assume f, map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)

section topological_add_group

variables [topological_space Œ±] [ordered_comm_group Œ±] [topological_add_group Œ±]

lemma neg_preimage_closure {s : set Œ±} : (Œªr:Œ±, -r) ‚Åª¬π' closure s = closure ((Œªr:Œ±, -r) '' s) :=
have (Œªr:Œ±, -r) ‚àò (Œªr:Œ±, -r) = id, from funext neg_neg,
by rw [preimage_neg]; exact
  (subset.antisymm (image_closure_subset_closure_image continuous_neg) $
    calc closure ((Œª (r : Œ±), -r) '' s) = (Œªr, -r) '' ((Œªr, -r) '' closure ((Œª (r : Œ±), -r) '' s)) :
        by rw [‚Üêimage_comp, this, image_id]
      ... ‚äÜ (Œªr, -r) '' closure ((Œªr, -r) '' ((Œª (r : Œ±), -r) '' s)) :
        mono_image $ image_closure_subset_closure_image continuous_neg
      ... = _ : by rw [‚Üêimage_comp, this, image_id])

end topological_add_group

section order_topology

variables [topological_space Œ±] [topological_space Œ≤]
  [linear_order Œ±] [linear_order Œ≤] [orderable_topology Œ±] [orderable_topology Œ≤]

lemma nhds_principal_ne_bot_of_is_lub {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s ‚â† ‚àÖ) :
  ùìù a ‚äì principal s ‚â† ‚ä• :=
let ‚ü®a', ha'‚ü© := exists_mem_of_ne_empty hs in
forall_sets_neq_empty_iff_neq_bot.mp $ assume t ht,
  let ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, ht‚ü© := mem_inf_sets.mp ht in
  by_cases
    (assume h : a = a',
      have a ‚àà t‚ÇÅ, from mem_of_nhds ht‚ÇÅ,
      have a ‚àà t‚ÇÇ, from ht‚ÇÇ $ by rwa [h],
      ne_empty_iff_exists_mem.mpr ‚ü®a, ht ‚ü®‚Äπa ‚àà t‚ÇÅ‚Ä∫, ‚Äπa ‚àà t‚ÇÇ‚Ä∫‚ü©‚ü©)
    (assume : a ‚â† a',
      have a' < a, from lt_of_le_of_ne (ha.left ‚Äπa' ‚àà s‚Ä∫) this.symm,
      let ‚ü®l, hl, hlt‚ÇÅ‚ü© := exists_Ioc_subset_of_mem_nhds ht‚ÇÅ ‚ü®a', this‚ü© in
      have ‚àÉa'‚ààs, l < a',
        from classical.by_contradiction $ assume : ¬¨ ‚àÉa'‚ààs, l < a',
          have ‚àÄa'‚ààs, a' ‚â§ l, from assume a ha, not_lt.1 $ assume ha', this ‚ü®a, ha, ha'‚ü©,
          have ¬¨ l < a, from not_lt.2 $ ha.right this,
          this ‚Äπl < a‚Ä∫,
      let ‚ü®a', ha', ha'l‚ü© := this in
      have a' ‚àà t‚ÇÅ, from hlt‚ÇÅ ‚ü®‚Äπl < a'‚Ä∫, ha.left ha'‚ü©,
      ne_empty_iff_exists_mem.mpr ‚ü®a', ht ‚ü®‚Äπa' ‚àà t‚ÇÅ‚Ä∫, ht‚ÇÇ ‚Äπa' ‚àà s‚Ä∫‚ü©‚ü©)

lemma nhds_principal_ne_bot_of_is_glb : ‚àÄ {a : Œ±} {s : set Œ±}, is_glb s a ‚Üí s ‚â† ‚àÖ ‚Üí
  ùìù a ‚äì principal s ‚â† ‚ä• :=
@nhds_principal_ne_bot_of_is_lub (order_dual Œ±) _ _ _

lemma is_lub_of_mem_nhds {s : set Œ±} {a : Œ±} {f : filter Œ±}
  (hsa : a ‚àà upper_bounds s) (hsf : s ‚àà f) (hfa : f ‚äì ùìù a ‚â† ‚ä•) : is_lub s a :=
‚ü®hsa, assume b hb,
  not_lt.1 $ assume hba,
  have s ‚à© {a | b < a} ‚àà f ‚äì ùìù a,
    from inter_mem_inf_sets hsf (mem_nhds_sets (is_open_lt' _) hba),
  let ‚ü®x, ‚ü®hxs, hxb‚ü©‚ü© := inhabited_of_mem_sets hfa this in
  have b < b, from lt_of_lt_of_le hxb $ hb hxs,
  lt_irrefl b this‚ü©

lemma is_glb_of_mem_nhds : ‚àÄ {s : set Œ±} {a : Œ±} {f : filter Œ±},
  a ‚àà lower_bounds s ‚Üí s ‚àà f ‚Üí f ‚äì ùìù a ‚â† ‚ä• ‚Üí is_glb s a :=
@is_lub_of_mem_nhds (order_dual Œ±) _ _ _

lemma is_lub_of_is_lub_of_tendsto {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤}
  (hf : ‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f x ‚â§ f y) (ha : is_lub s a) (hs : s ‚â† ‚àÖ)
  (hb : tendsto f (ùìù a ‚äì principal s) (ùìù b)) : is_lub (f '' s) b :=
have hnbot : (ùìù a ‚äì principal s) ‚â† ‚ä•, from nhds_principal_ne_bot_of_is_lub ha hs,
have ‚àÄa'‚ààs, ¬¨ b < f a',
  from assume a' ha' h,
  have {x | x < f a'} ‚àà ùìù b, from mem_nhds_sets (is_open_gt' _) h,
  let ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, hs‚ü© := mem_inf_sets.mp (hb this) in
  by_cases
    (assume h : a = a',
      have a ‚àà t‚ÇÅ ‚à© t‚ÇÇ, from ‚ü®mem_of_nhds ht‚ÇÅ, ht‚ÇÇ $ by rwa [h]‚ü©,
      have f a < f a', from hs this,
      lt_irrefl (f a') $ by rwa [h] at this)
    (assume h : a ‚â† a',
      have a' < a, from lt_of_le_of_ne (ha.left ha') h.symm,
      have {x | a' < x} ‚àà ùìù a, from mem_nhds_sets (is_open_lt' _) this,
      have {x | a' < x} ‚à© t‚ÇÅ ‚àà ùìù a, from inter_mem_sets this ht‚ÇÅ,
      have ({x | a' < x} ‚à© t‚ÇÅ) ‚à© s ‚àà ùìù a ‚äì principal s,
        from inter_mem_inf_sets this (subset.refl s),
      let ‚ü®x, ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©, hx‚ÇÉ‚ü© := inhabited_of_mem_sets hnbot this in
      have hxa' : f x < f a', from hs ‚ü®hx‚ÇÇ, ht‚ÇÇ hx‚ÇÉ‚ü©,
      have ha'x : f a' ‚â§ f x, from hf _ ha' _ hx‚ÇÉ $ le_of_lt hx‚ÇÅ,
      lt_irrefl _ (lt_of_le_of_lt ha'x hxa')),
and.intro
  (assume b' ‚ü®a', ha', h_eq‚ü©, h_eq ‚ñ∏ not_lt.1 $ this _ ha')
  (assume b' hb', le_of_tendsto hnbot hb $
      mem_inf_sets_of_right $ assume x hx, hb' $ mem_image_of_mem _ hx)

lemma is_glb_of_is_glb_of_tendsto {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤}
  (hf : ‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f x ‚â§ f y) : is_glb s a ‚Üí s ‚â† ‚àÖ ‚Üí
  tendsto f (ùìù a ‚äì principal s) (ùìù b) ‚Üí is_glb (f '' s) b :=
@is_lub_of_is_lub_of_tendsto (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ f s a b
  (Œª x hx y hy, hf y hy x hx)

lemma is_glb_of_is_lub_of_tendsto : ‚àÄ {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤},
  (‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f y ‚â§ f x) ‚Üí is_lub s a ‚Üí s ‚â† ‚àÖ ‚Üí
  tendsto f (ùìù a ‚äì principal s) (ùìù b) ‚Üí is_glb (f '' s) b :=
@is_lub_of_is_lub_of_tendsto Œ± (order_dual Œ≤) _ _ _ _ _ _

lemma is_lub_of_is_glb_of_tendsto : ‚àÄ {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤},
  (‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f y ‚â§ f x) ‚Üí is_glb s a ‚Üí s ‚â† ‚àÖ ‚Üí
  tendsto f (ùìù a ‚äì principal s) (ùìù b) ‚Üí is_lub (f '' s) b :=
@is_glb_of_is_glb_of_tendsto Œ± (order_dual Œ≤) _ _ _ _ _ _

lemma mem_closure_of_is_lub {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s ‚â† ‚àÖ) : a ‚àà closure s :=
by rw closure_eq_nhds; exact nhds_principal_ne_bot_of_is_lub ha hs

lemma mem_of_is_lub_of_is_closed {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s ‚â† ‚àÖ) (sc : is_closed s) : a ‚àà s :=
by rw ‚Üêclosure_eq_of_is_closed sc; exact mem_closure_of_is_lub ha hs

lemma mem_closure_of_is_glb {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s ‚â† ‚àÖ) : a ‚àà closure s :=
by rw closure_eq_nhds; exact nhds_principal_ne_bot_of_is_glb ha hs

lemma mem_of_is_glb_of_is_closed {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s ‚â† ‚àÖ) (sc : is_closed s) : a ‚àà s :=
by rw ‚Üêclosure_eq_of_is_closed sc; exact mem_closure_of_is_glb ha hs

/-- A compact set is bounded below -/
lemma bdd_below_of_compact {Œ± : Type u} [topological_space Œ±] [linear_order Œ±]
  [ordered_topology Œ±] [nonempty Œ±] {s : set Œ±} (hs : compact s) : bdd_below s :=
begin
  by_contra H,
  letI := classical.DLO Œ±,
  rcases @compact_elim_finite_subcover_image Œ± _ _ _ s (Œª x, {b | x < b}) hs
    (Œª x _, is_open_lt continuous_const continuous_id) _ with ‚ü®t, st, ft, ht‚ü©,
  { refine H ((bdd_below_finite ft).imp $ Œª C hC y hy, _),
    rcases mem_bUnion_iff.1 (ht hy) with ‚ü®x, hx, xy‚ü©,
    exact le_trans (hC hx) (le_of_lt xy) },
  { refine Œª x hx, mem_bUnion_iff.2 (not_imp_comm.1 _ H),
    exact Œª h, ‚ü®x, Œª y hy, le_of_not_lt (h.imp $ Œª ys, ‚ü®_, hy, ys‚ü©)‚ü© }
end

/-- A compact set is bounded above -/
lemma bdd_above_of_compact {Œ± : Type u} [topological_space Œ±] [linear_order Œ±]
  [orderable_topology Œ±] : Œ† [nonempty Œ±] {s : set Œ±}, compact s ‚Üí bdd_above s :=
@bdd_below_of_compact (order_dual Œ±) _ _ _

end order_topology

section decidable_linear_order

variables [topological_space Œ±] [decidable_linear_order Œ±] [orderable_topology Œ±] [densely_ordered Œ±]

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`, unless `a` is a top
element. -/
lemma closure_Ioi' {a b : Œ±} (hab : a < b) :
  closure (Ioi a) = Ici a :=
begin
  apply subset.antisymm,
  { rw ‚Üê closure_eq_iff_is_closed.2 is_closed_Ici,
    exact closure_mono Ioi_subset_Ici_self,
    apply_instance },
  { assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_glb is_glb_Ioi (ne_empty_of_mem hab) },
    { exact subset_closure (lt_of_le_of_ne hx (ne.symm h)) } }
end

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`. -/
lemma closure_Ioi (a : Œ±) [no_top_order Œ±] :
  closure (Ioi a) = Ici a :=
let ‚ü®b, hb‚ü© := no_top a in closure_Ioi' hb

/-- The closure of the interval `(-‚àû, a)` is the closed interval `(-‚àû, a]`, unless `a` is a bottom
element. -/
lemma closure_Iio' {a b : Œ±} (hab : b < a) :
  closure (Iio a) = Iic a :=
begin
  apply subset.antisymm,
  { rw ‚Üê closure_eq_iff_is_closed.2 is_closed_Iic,
    exact closure_mono Iio_subset_Iic_self,
    apply_instance },
  { assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_lub is_lub_Iio (ne_empty_of_mem hab) },
    { apply subset_closure, by simpa [h] using lt_or_eq_of_le hx } }
end

/-- The closure of the interval `(-‚àû, a)` is the interval `(-‚àû, a]`. -/
lemma closure_Iio (a : Œ±) [no_bot_order Œ±] :
  closure (Iio a) = Iic a :=
let ‚ü®b, hb‚ü© := no_bot a in closure_Iio' hb

/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
lemma closure_Ioo {a b : Œ±} (hab : a < b) :
  closure (Ioo a b) = Icc a b :=
begin
  apply subset.antisymm,
  { rw ‚Üê closure_eq_iff_is_closed.2 is_closed_Icc,
    exact closure_mono Ioo_subset_Icc_self,
    apply_instance },
  { have ne_empty : Ioo a b ‚â† ‚àÖ, by simpa [Ioo_eq_empty_iff],
    assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_glb (is_glb_Ioo hab) ne_empty },
    by_cases h' : x = b,
    { rw h', refine mem_closure_of_is_lub (is_lub_Ioo hab) ne_empty },
    exact subset_closure ‚ü®lt_of_le_of_ne hx.1 (ne.symm h), by simpa [h'] using lt_or_eq_of_le hx.2‚ü© }
end

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
lemma closure_Ioc {a b : Œ±} (hab : a < b) :
  closure (Ioc a b) = Icc a b :=
begin
  apply subset.antisymm,
  { rw ‚Üê closure_eq_iff_is_closed.2 is_closed_Icc,
    exact closure_mono Ioc_subset_Icc_self,
    apply_instance },
  { apply subset.trans _ (closure_mono Ioo_subset_Ioc_self),
    rw closure_Ioo hab }
end

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
lemma closure_Ico {a b : Œ±} (hab : a < b) :
  closure (Ico a b) = Icc a b :=
begin
  apply subset.antisymm,
  { rw ‚Üê closure_eq_iff_is_closed.2 is_closed_Icc,
    exact closure_mono Ico_subset_Icc_self,
    apply_instance },
  { apply subset.trans _ (closure_mono Ioo_subset_Ico_self),
    rw closure_Ioo hab }
end

end decidable_linear_order

section complete_linear_order

variables [complete_linear_order Œ±] [topological_space Œ±] [orderable_topology Œ±]
  [complete_linear_order Œ≤] [topological_space Œ≤] [orderable_topology Œ≤] [nonempty Œ≥]

lemma Sup_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±] [orderable_topology Œ±]
  {s : set Œ±} (hs : s ‚â† ‚àÖ) : Sup s ‚àà closure s :=
mem_closure_of_is_lub is_lub_Sup hs

lemma Inf_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±] [orderable_topology Œ±]
  {s : set Œ±} (hs : s ‚â† ‚àÖ) : Inf s ‚àà closure s :=
mem_closure_of_is_glb is_glb_Inf hs

lemma Sup_mem_of_is_closed {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±] [orderable_topology Œ±]
  {s : set Œ±} (hs : s ‚â† ‚àÖ) (hc : is_closed s) : Sup s ‚àà s :=
mem_of_is_lub_of_is_closed  is_lub_Sup hs hc

lemma Inf_mem_of_is_closed {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±] [orderable_topology Œ±]
  {s : set Œ±} (hs : s ‚â† ‚àÖ) (hc : is_closed s) : Inf s ‚àà s :=
mem_of_is_glb_of_is_closed  is_glb_Inf hs hc

/-- A continuous monotone function sends supremum to supremum for nonempty sets. -/
lemma Sup_of_continuous' {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  {s : set Œ±} (hs : s ‚â† ‚àÖ) : f (Sup s) = Sup (f '' s) :=
--This is a particular case of the more general is_lub_of_is_lub_of_tendsto
(is_lub_iff_Sup_eq.1
  (is_lub_of_is_lub_of_tendsto (Œª x hx y hy xy, Cf xy) is_lub_Sup hs $
    tendsto_le_left inf_le_left (Mf.tendsto _))).symm

/-- A continuous monotone function sending bot to bot sends supremum to supremum. -/
lemma Sup_of_continuous {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  (fbot : f ‚ä• = ‚ä•) {s : set Œ±} : f (Sup s) = Sup (f '' s) :=
begin
  by_cases (s = ‚àÖ),
  { simpa [h] },
  { exact Sup_of_continuous' Mf Cf h }
end

/-- A continuous monotone function sends indexed supremum to indexed supremum. -/
lemma supr_of_continuous {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) : f (supr g) = supr (f ‚àò g) :=
by rw [supr, Sup_of_continuous' Mf Cf
  (Œª h, range_eq_empty.1 h ‚Äπ_‚Ä∫), ‚Üê range_comp]; refl

/-- A continuous monotone function sends infimum to infimum for nonempty sets. -/
lemma Inf_of_continuous' {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  {s : set Œ±} (hs : s ‚â† ‚àÖ) : f (Inf s) = Inf (f '' s) :=
(is_glb_iff_Inf_eq.1
  (is_glb_of_is_glb_of_tendsto (Œª x hx y hy xy, Cf xy) is_glb_Inf hs $
    tendsto_le_left inf_le_left (Mf.tendsto _))).symm

/-- A continuous monotone function sending top to top sends infimum to infimum. -/
lemma Inf_of_continuous {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  (ftop : f ‚ä§ = ‚ä§) {s : set Œ±} : f (Inf s) = Inf (f '' s) :=
begin
  by_cases (s = ‚àÖ),
  { simpa [h] },
  { exact Inf_of_continuous' Mf Cf h }
end

/-- A continuous monotone function sends indexed infimum to indexed infimum. -/
lemma infi_of_continuous {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) : f (infi g) = infi (f ‚àò g) :=
by rw [infi, Inf_of_continuous' Mf Cf
  (Œª h, range_eq_empty.1 h ‚Äπ_‚Ä∫), ‚Üê range_comp]; refl

end complete_linear_order


section conditionally_complete_linear_order

variables [conditionally_complete_linear_order Œ±] [topological_space Œ±] [orderable_topology Œ±]
  [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [orderable_topology Œ≤] [nonempty Œ≥]

lemma cSup_mem_closure {Œ± : Type u} [topological_space Œ±] [conditionally_complete_linear_order Œ±] [orderable_topology Œ±]
  {s : set Œ±} (hs : s ‚â† ‚àÖ) (B : bdd_above s) : Sup s ‚àà closure s :=
mem_closure_of_is_lub (is_lub_cSup hs B) hs

lemma cInf_mem_closure {Œ± : Type u} [topological_space Œ±] [conditionally_complete_linear_order Œ±] [orderable_topology Œ±]
  {s : set Œ±} (hs : s ‚â† ‚àÖ) (B : bdd_below s) : Inf s ‚àà closure s :=
mem_closure_of_is_glb (is_glb_cInf hs B) hs

lemma cSup_mem_of_is_closed {Œ± : Type u} [topological_space Œ±] [conditionally_complete_linear_order Œ±] [orderable_topology Œ±]
  {s : set Œ±} (hs : s ‚â† ‚àÖ) (hc : is_closed s) (B : bdd_above s) : Sup s ‚àà s :=
mem_of_is_lub_of_is_closed (is_lub_cSup hs B) hs hc

lemma cInf_mem_of_is_closed {Œ± : Type u} [topological_space Œ±] [conditionally_complete_linear_order Œ±] [orderable_topology Œ±]
  {s : set Œ±} (hs : s ‚â† ‚àÖ) (hc : is_closed s) (B : bdd_below s) : Inf s ‚àà s :=
mem_of_is_glb_of_is_closed (is_glb_cInf hs B) hs hc

/-- A continuous monotone function sends supremum to supremum in conditionally complete
lattices, under a boundedness assumption. -/
lemma cSup_of_cSup_of_monotone_of_continuous {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  {s : set Œ±} (ne : s ‚â† ‚àÖ) (H : bdd_above s) : f (Sup s) = Sup (f '' s) :=
begin
  refine (is_lub_iff_eq_of_is_lub _).1
    (is_lub_cSup (mt image_eq_empty.1 ne) (bdd_above_of_bdd_above_of_monotone Cf H)),
  refine is_lub_of_is_lub_of_tendsto (Œªx hx y hy xy, Cf xy) (is_lub_cSup ne H) ne _,
  exact tendsto_le_left inf_le_left (Mf.tendsto _)
end

/-- A continuous monotone function sends indexed supremum to indexed supremum in conditionally complete
lattices, under a boundedness assumption. -/
lemma csupr_of_csupr_of_monotone_of_continuous {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) (H : bdd_above (range g)) : f (supr g) = supr (f ‚àò g) :=
by rw [supr, cSup_of_cSup_of_monotone_of_continuous Mf Cf
  (Œª h, range_eq_empty.1 h ‚Äπ_‚Ä∫) H, ‚Üê range_comp]; refl

/-- A continuous monotone function sends infimum to infimum in conditionally complete
lattices, under a boundedness assumption. -/
lemma cInf_of_cInf_of_monotone_of_continuous {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  {s : set Œ±} (ne : s ‚â† ‚àÖ) (H : bdd_below s) : f (Inf s) = Inf (f '' s) :=
begin
  refine (is_glb_iff_eq_of_is_glb _).1
    (is_glb_cInf (mt image_eq_empty.1 ne) (bdd_below_of_bdd_below_of_monotone Cf H)),
  refine is_glb_of_is_glb_of_tendsto (Œªx hx y hy xy, Cf xy) (is_glb_cInf ne H) ne _,
  exact tendsto_le_left inf_le_left (Mf.tendsto _)
end

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally complete
lattices, under a boundedness assumption. -/
lemma cinfi_of_cinfi_of_monotone_of_continuous {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) (H : bdd_below (range g)) : f (infi g) = infi (f ‚àò g) :=
by rw [infi, cInf_of_cInf_of_monotone_of_continuous Mf Cf
  (Œª h, range_eq_empty.1 h ‚Äπ_‚Ä∫) H, ‚Üê range_comp]; refl

/-- The extreme value theorem: a continuous function realizes its minimum on a compact set -/
lemma exists_forall_le_of_compact_of_continuous {Œ± : Type u} [topological_space Œ±]
  (f : Œ± ‚Üí Œ≤) (hf : continuous f) (s : set Œ±) (hs : compact s) (ne_s : s ‚â† ‚àÖ) :
  ‚àÉx‚ààs, ‚àÄy‚ààs, f x ‚â§ f y :=
begin
  have C : compact (f '' s) := compact_image hs hf,
  haveI := has_Inf_to_nonempty Œ≤,
  have B : bdd_below (f '' s) := bdd_below_of_compact C,
  have : Inf (f '' s) ‚àà f '' s :=
    cInf_mem_of_is_closed (mt image_eq_empty.1 ne_s) (closed_of_compact _ C) B,
  rcases (mem_image _ _ _).1 this with ‚ü®x, xs, hx‚ü©,
  exact ‚ü®x, xs, Œª y hy, hx.symm ‚ñ∏ cInf_le B ‚ü®_, hy, rfl‚ü©‚ü©
end

/-- The extreme value theorem: a continuous function realizes its maximum on a compact set -/
lemma exists_forall_ge_of_compact_of_continuous {Œ± : Type u} [topological_space Œ±] :
  ‚àÄ f : Œ± ‚Üí Œ≤, continuous f ‚Üí ‚àÄ s : set Œ±, compact s ‚Üí s ‚â† ‚àÖ ‚Üí
  ‚àÉx‚ààs, ‚àÄy‚ààs, f y ‚â§ f x :=
@exists_forall_le_of_compact_of_continuous (order_dual Œ≤) _ _ _ _ _

end conditionally_complete_linear_order


section liminf_limsup

section ordered_topology
variables [semilattice_sup Œ±] [topological_space Œ±] [orderable_topology Œ±]

lemma is_bounded_le_nhds (a : Œ±) : (ùìù a).is_bounded (‚â§) :=
match forall_le_or_exists_lt_sup a with
| or.inl h := ‚ü®a, show {x : Œ± | x ‚â§ a} ‚àà ùìù a, from univ_mem_sets' h‚ü©
| or.inr ‚ü®b, hb‚ü© := ‚ü®b, ge_mem_nhds hb‚ü©
end

lemma is_bounded_under_le_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (h : tendsto u f (ùìù a)) : f.is_bounded_under (‚â§) u :=
is_bounded_of_le h (is_bounded_le_nhds a)

lemma is_cobounded_ge_nhds (a : Œ±) : (ùìù a).is_cobounded (‚â•) :=
is_cobounded_of_is_bounded nhds_neq_bot (is_bounded_le_nhds a)

lemma is_cobounded_under_ge_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (hf : f ‚â† ‚ä•) (h : tendsto u f (ùìù a)) : f.is_cobounded_under (‚â•) u :=
is_cobounded_of_is_bounded (map_ne_bot hf) (is_bounded_under_le_of_tendsto h)

end ordered_topology

section ordered_topology
variables [semilattice_inf Œ±] [topological_space Œ±] [orderable_topology Œ±]

lemma is_bounded_ge_nhds (a : Œ±) : (ùìù a).is_bounded (‚â•) :=
match forall_le_or_exists_lt_inf a with
| or.inl h := ‚ü®a, show {x : Œ± | a ‚â§ x} ‚àà ùìù a, from univ_mem_sets' h‚ü©
| or.inr ‚ü®b, hb‚ü© := ‚ü®b, le_mem_nhds hb‚ü©
end

lemma is_bounded_under_ge_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (h : tendsto u f (ùìù a)) : f.is_bounded_under (‚â•) u :=
is_bounded_of_le h (is_bounded_ge_nhds a)

lemma is_cobounded_le_nhds (a : Œ±) : (ùìù a).is_cobounded (‚â§) :=
is_cobounded_of_is_bounded nhds_neq_bot (is_bounded_ge_nhds a)

lemma is_cobounded_under_le_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (hf : f ‚â† ‚ä•) (h : tendsto u f (ùìù a)) : f.is_cobounded_under (‚â§) u :=
is_cobounded_of_is_bounded (map_ne_bot hf) (is_bounded_under_ge_of_tendsto h)

end ordered_topology

section conditionally_complete_linear_order
variables [conditionally_complete_linear_order Œ±]

theorem lt_mem_sets_of_Limsup_lt {f : filter Œ±} {b} (h : f.is_bounded (‚â§)) (l : f.Limsup < b) :
  {a | a < b} ‚àà f :=
let ‚ü®c, (h : {a : Œ± | a ‚â§ c} ‚àà f), hcb‚ü© :=
  exists_lt_of_cInf_lt (ne_empty_iff_exists_mem.2 h) l in
mem_sets_of_superset h $ assume a hac, lt_of_le_of_lt hac hcb

theorem gt_mem_sets_of_Liminf_gt : ‚àÄ {f : filter Œ±} {b}, f.is_bounded (‚â•) ‚Üí f.Liminf > b ‚Üí
  {a | a > b} ‚àà f :=
@lt_mem_sets_of_Limsup_lt (order_dual Œ±) _

variables [topological_space Œ±] [orderable_topology Œ±]

/-- If the liminf and the limsup of a filter coincide, then this filter converges to
their common value, at least if the filter is eventually bounded above and below. -/
theorem le_nhds_of_Limsup_eq_Liminf {f : filter Œ±} {a : Œ±}
  (hl : f.is_bounded (‚â§)) (hg : f.is_bounded (‚â•)) (hs : f.Limsup = a) (hi : f.Liminf = a) :
  f ‚â§ ùìù a :=
tendsto_orderable.2 $ and.intro
  (assume b hb, gt_mem_sets_of_Liminf_gt hg $ hi.symm ‚ñ∏ hb)
  (assume b hb, lt_mem_sets_of_Limsup_lt hl $ hs.symm ‚ñ∏ hb)

theorem Limsup_nhds (a : Œ±) : Limsup (ùìù a) = a :=
cInf_intro (ne_empty_iff_exists_mem.2 $ is_bounded_le_nhds a)
  (assume a' (h : {n : Œ± | n ‚â§ a'} ‚àà ùìù a), show a ‚â§ a', from @mem_of_nhds Œ± _ a _ h)
  (assume b (hba : a < b), show ‚àÉc (h : {n : Œ± | n ‚â§ c} ‚àà ùìù a), c < b, from
    match dense_or_discrete a b with
    | or.inl ‚ü®c, hac, hcb‚ü© := ‚ü®c, ge_mem_nhds hac, hcb‚ü©
    | or.inr ‚ü®_, h‚ü©        := ‚ü®a, (ùìù a).sets_of_superset (gt_mem_nhds hba) h, hba‚ü©
    end)

theorem Liminf_nhds : ‚àÄ (a : Œ±), Liminf (ùìù a) = a :=
@Limsup_nhds (order_dual Œ±) _ _ _

/-- If a filter is converging, its limsup coincides with its limit. -/
theorem Liminf_eq_of_le_nhds {f : filter Œ±} {a : Œ±} (hf : f ‚â† ‚ä•) (h : f ‚â§ ùìù a) : f.Liminf = a :=
have hb_ge : is_bounded (‚â•) f, from is_bounded_of_le h (is_bounded_ge_nhds a),
have hb_le : is_bounded (‚â§) f, from is_bounded_of_le h (is_bounded_le_nhds a),
le_antisymm
  (calc f.Liminf ‚â§ f.Limsup : Liminf_le_Limsup hf hb_le hb_ge
    ... ‚â§ (ùìù a).Limsup :
      Limsup_le_Limsup_of_le h (is_cobounded_of_is_bounded hf hb_ge) (is_bounded_le_nhds a)
    ... = a : Limsup_nhds a)
  (calc a = (ùìù a).Liminf : (Liminf_nhds a).symm
    ... ‚â§ f.Liminf :
      Liminf_le_Liminf_of_le h (is_bounded_ge_nhds a) (is_cobounded_of_is_bounded hf hb_le))

/-- If a filter is converging, its liminf coincides with its limit. -/
theorem Limsup_eq_of_le_nhds : ‚àÄ {f : filter Œ±} {a : Œ±}, f ‚â† ‚ä• ‚Üí f ‚â§ ùìù a ‚Üí f.Limsup = a :=
@Liminf_eq_of_le_nhds (order_dual Œ±) _ _ _

end conditionally_complete_linear_order

section complete_linear_order
variables [complete_linear_order Œ±] [topological_space Œ±] [orderable_topology Œ±]
-- In complete_linear_order, the above theorems take a simpler form

/-- If the liminf and the limsup of a function coincide, then the limit of the function
exists and has the same value -/
theorem tendsto_of_liminf_eq_limsup {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (h : liminf f u = a ‚àß limsup f u = a) : tendsto u f (ùìù a) :=
  le_nhds_of_Limsup_eq_Liminf is_bounded_le_of_top is_bounded_ge_of_bot h.2 h.1

/-- If a function has a limit, then its limsup coincides with its limit-/
theorem limsup_eq_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : f ‚â† ‚ä•)
  (h : tendsto u f (ùìù a)) : limsup f u = a :=
  Limsup_eq_of_le_nhds (map_ne_bot hf) h

/-- If a function has a limit, then its liminf coincides with its limit-/
theorem liminf_eq_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : f ‚â† ‚ä•)
  (h : tendsto u f (ùìù a)) : liminf f u = a :=
  Liminf_eq_of_le_nhds (map_ne_bot hf) h

end complete_linear_order

end liminf_limsup

end orderable_topology

lemma orderable_topology_of_nhds_abs
  {Œ± : Type*} [decidable_linear_ordered_comm_group Œ±] [topological_space Œ±]
  (h_nhds : ‚àÄa:Œ±, ùìù a = (‚®Ör>0, principal {b | abs (a - b) < r})) : orderable_topology Œ± :=
orderable_topology.mk $ eq_of_nhds_eq_nhds $ assume a:Œ±, le_antisymm_iff.mpr
begin
  simp [infi_and, topological_space.nhds_generate_from,
        h_nhds, le_infi_iff, -le_principal_iff, and_comm],
  refine ‚ü®Œª s ha b hs, _, Œª r hr, _‚ü©,
  { rcases hs with rfl | rfl,
    { refine infi_le_of_le (a - b)
        (infi_le_of_le (lt_sub_left_of_add_lt $ by simpa using ha) $
          principal_mono.mpr $ assume c (hc : abs (a - c) < a - b), _),
      have : a - c < a - b := lt_of_le_of_lt (le_abs_self _) hc,
      exact lt_of_neg_lt_neg (lt_of_add_lt_add_left this) },
    { refine infi_le_of_le (b - a)
        (infi_le_of_le (lt_sub_left_of_add_lt $ by simpa using ha) $
          principal_mono.mpr $ assume c (hc : abs (a - c) < b - a), _),
      have : abs (c - a) < b - a, {rw abs_sub; simpa using hc},
      have : c - a < b - a := lt_of_le_of_lt (le_abs_self _) this,
      exact lt_of_add_lt_add_right this } },
  { have h : {b | abs (a + -b) < r} = {b | a - r < b} ‚à© {b | b < a + r},
      from set.ext (assume b,
        by simp [abs_lt, -sub_eq_add_neg, (sub_eq_add_neg _ _).symm,
          sub_lt, lt_sub_iff_add_lt, and_comm, sub_lt_iff_lt_add']),
    rw [h, ‚Üê inf_principal],
    apply le_inf _ _,
    { exact infi_le_of_le {b : Œ± | a - r < b} (infi_le_of_le (sub_lt_self a hr) $
        infi_le_of_le (a - r) $ infi_le _ (or.inl rfl)) },
    { exact infi_le_of_le {b : Œ± | b < a + r} (infi_le_of_le (lt_add_of_pos_right _ hr) $
        infi_le_of_le (a + r) $ infi_le _ (or.inr rfl)) } }
end

lemma tendsto_at_top_supr_nat [topological_space Œ±] [complete_linear_order Œ±] [orderable_topology Œ±]
  (f : ‚Ñï ‚Üí Œ±) (hf : monotone f) : tendsto f at_top (ùìù (‚®Üi, f i)) :=
tendsto_orderable.2 $ and.intro
  (assume a ha, let ‚ü®n, hn‚ü© := lt_supr_iff.1 ha in
    mem_at_top_sets.2 ‚ü®n, assume i hi, lt_of_lt_of_le hn (hf hi)‚ü©)
  (assume a ha, univ_mem_sets' (assume n, lt_of_le_of_lt (le_supr _ n) ha))

lemma tendsto_at_top_infi_nat [topological_space Œ±] [complete_linear_order Œ±] [orderable_topology Œ±]
  (f : ‚Ñï ‚Üí Œ±) (hf : ‚àÄ{n m}, n ‚â§ m ‚Üí f m ‚â§ f n) : tendsto f at_top (ùìù (‚®Öi, f i)) :=
@tendsto_at_top_supr_nat (order_dual Œ±) _ _ _ _ @hf

lemma supr_eq_of_tendsto {Œ±} [topological_space Œ±] [complete_linear_order Œ±] [orderable_topology Œ±]
  {f : ‚Ñï ‚Üí Œ±} {a : Œ±} (hf : monotone f) : tendsto f at_top (ùìù a) ‚Üí supr f = a :=
tendsto_nhds_unique at_top_ne_bot (tendsto_at_top_supr_nat f hf)

lemma infi_eq_of_tendsto {Œ±} [topological_space Œ±] [complete_linear_order Œ±] [orderable_topology Œ±]
  {f : ‚Ñï ‚Üí Œ±} {a : Œ±} (hf : ‚àÄn m, n ‚â§ m ‚Üí f m ‚â§ f n) : tendsto f at_top (ùìù a) ‚Üí infi f = a :=
tendsto_nhds_unique at_top_ne_bot (tendsto_at_top_infi_nat f hf)
