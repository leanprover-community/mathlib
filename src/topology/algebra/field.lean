/-
Copyright (c) 2021 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Scott Morrison
-/
import topology.algebra.ring.basic
import topology.algebra.group_with_zero
import topology.local_extr
import field_theory.subfield

/-!
# Topological fields

A topological division ring is a topological ring whose inversion function is continuous at every
non-zero element.

-/


namespace topological_ring
open topological_space function
variables (R : Type*) [semiring R]

variables  [topological_space R]

/-- The induced topology on units of a topological semiring.
This is not a global instance since other topologies could be relevant. Instead there is a class
`induced_units` asserting that something equivalent to this construction holds. -/
def topological_space_units : topological_space RÀ£ := induced (coe : RÀ£ ‚Üí R) ‚Äπ_‚Ä∫

/-- Asserts the topology on units is the induced topology.

 Note: this is not always the correct topology.
 Another good candidate is the subspace topology of $R \times R$,
 with the units embedded via $u \mapsto (u, u^{-1})$.
 These topologies are not (propositionally) equal in general. -/
class induced_units [t : topological_space $ RÀ£] : Prop :=
(top_eq : t = induced (coe : RÀ£ ‚Üí R) ‚Äπ_‚Ä∫)

variables [topological_space $ RÀ£]

lemma units_topology_eq [induced_units R] :
  ‚Äπtopological_space RÀ£‚Ä∫ = induced (coe : RÀ£ ‚Üí R) ‚Äπ_‚Ä∫ :=
induced_units.top_eq

lemma induced_units.continuous_coe [induced_units R] : continuous (coe : RÀ£ ‚Üí R) :=
(units_topology_eq R).symm ‚ñ∏ continuous_induced_dom

lemma units_embedding [induced_units R] :
  embedding (coe : RÀ£ ‚Üí R) :=
{ induced := units_topology_eq R,
  inj := Œª x y h, units.ext h }

instance top_monoid_units [topological_semiring R] [induced_units R] :
  has_continuous_mul RÀ£ :=
‚ü®begin
  let mulR := (Œª (p : R √ó R), p.1*p.2),
  let mulRx := (Œª (p : RÀ£ √ó RÀ£), p.1*p.2),
  have key : coe ‚àò mulRx = mulR ‚àò (Œª p, (p.1.val, p.2.val)), from rfl,
  rw [continuous_iff_le_induced, units_topology_eq R, prod_induced_induced,
      induced_compose, key, ‚Üê induced_compose],
  apply induced_mono,
  rw ‚Üê continuous_iff_le_induced,
  exact continuous_mul,
end‚ü©
end topological_ring

variables {K : Type*} [division_ring K] [topological_space K]

/-- Left-multiplication by a nonzero element of a topological division ring is proper, i.e.,
inverse images of compact sets are compact. -/
lemma filter.tendsto_cocompact_mul_left‚ÇÄ [has_continuous_mul K] {a : K} (ha : a ‚â† 0) :
  filter.tendsto (Œª x : K, a * x) (filter.cocompact K) (filter.cocompact K) :=
filter.tendsto_cocompact_mul_left (inv_mul_cancel ha)

/-- Right-multiplication by a nonzero element of a topological division ring is proper, i.e.,
inverse images of compact sets are compact. -/
lemma filter.tendsto_cocompact_mul_right‚ÇÄ [has_continuous_mul K] {a : K} (ha : a ‚â† 0) :
  filter.tendsto (Œª x : K, x * a) (filter.cocompact K) (filter.cocompact K) :=
filter.tendsto_cocompact_mul_right (mul_inv_cancel ha)

variables (K)

/-- A topological division ring is a division ring with a topology where all operations are
    continuous, including inversion. -/
class topological_division_ring extends topological_ring K, has_continuous_inv‚ÇÄ K : Prop

namespace topological_division_ring
open filter set
/-!
In this section, we show that units of a topological division ring endowed with the
induced topology form a topological group. These are not global instances because
one could want another topology on units. To turn on this feature, use:

```lean
local attribute [instance]
topological_semiring.topological_space_units topological_division_ring.units_top_group
```
-/

local attribute [instance] topological_ring.topological_space_units

@[priority 100] instance induced_units : topological_ring.induced_units K := ‚ü®rfl‚ü©

variables [topological_division_ring K]

lemma units_top_group : topological_group KÀ£ :=
{ continuous_inv := begin
    rw continuous_iff_continuous_at,
    intros x,
    rw [continuous_at, nhds_induced, nhds_induced, tendsto_iff_comap,
      ‚Üêfunction.semiconj.filter_comap units.coe_inv _],
    apply comap_mono,
    rw [‚Üê tendsto_iff_comap, units.coe_inv],
    exact continuous_at_inv‚ÇÄ x.ne_zero
  end,
  ..topological_ring.top_monoid_units K}

local attribute [instance] units_top_group

lemma continuous_units_inv : continuous (Œª x : KÀ£, (‚Üë(x‚Åª¬π) : K)) :=
(topological_ring.induced_units.continuous_coe K).comp continuous_inv

end topological_division_ring

section subfield

variables {Œ± : Type*} [field Œ±] [topological_space Œ±] [topological_division_ring Œ±]

/-- The (topological-space) closure of a subfield of a topological field is
itself a subfield. -/
def subfield.topological_closure (K : subfield Œ±) : subfield Œ± :=
{ carrier := closure (K : set Œ±),
  inv_mem' :=
  begin
    intros x hx,
    by_cases h : x = 0,
    { rwa [h, inv_zero, ‚Üê h], },
    { convert mem_closure_image (continuous_at_inv‚ÇÄ h) hx using 2,
      ext x, split,
      { exact Œª hx, ‚ü®x‚Åª¬π, ‚ü®K.inv_mem hx, inv_inv x‚ü©‚ü©, },
      { rintros ‚ü®y, ‚ü®hy, rfl‚ü©‚ü©, exact K.inv_mem hy, }},
  end,
  ..K.to_subring.topological_closure, }

lemma subfield.le_topological_closure (s : subfield Œ±) :
  s ‚â§ s.topological_closure := subset_closure

lemma subfield.is_closed_topological_closure (s : subfield Œ±) :
  is_closed (s.topological_closure : set Œ±) := is_closed_closure

lemma subfield.topological_closure_minimal
  (s : subfield Œ±) {t : subfield Œ±} (h : s ‚â§ t) (ht : is_closed (t : set Œ±)) :
  s.topological_closure ‚â§ t := closure_minimal h ht

end subfield

section affine_homeomorph
/-!
This section is about affine homeomorphisms from a topological field `ùïú` to itself.
Technically it does not require `ùïú` to be a topological field, a topological ring that
happens to be a field is enough.
-/
variables {ùïú : Type*} [field ùïú] [topological_space ùïú] [topological_ring ùïú]

/--
The map `Œª x, a * x + b`, as a homeomorphism from `ùïú` (a topological field) to itself, when `a ‚â† 0`.
-/
@[simps]
def affine_homeomorph (a b : ùïú) (h : a ‚â† 0) : ùïú ‚âÉ‚Çú ùïú :=
{ to_fun := Œª x, a * x + b,
  inv_fun := Œª y, (y - b) / a,
  left_inv := Œª x, by { simp only [add_sub_cancel], exact mul_div_cancel_left x h, },
  right_inv := Œª y, by { simp [mul_div_cancel' _ h], }, }

end affine_homeomorph

section local_extr

variables {Œ± Œ≤ : Type*} [topological_space Œ±] [linear_ordered_semifield Œ≤] {a : Œ±}
open_locale topology

lemma is_local_min.inv {f : Œ± ‚Üí Œ≤} {a : Œ±} (h1 : is_local_min f a) (h2 : ‚àÄ·∂† z in ùìù a, 0 < f z) :
  is_local_max f‚Åª¬π a :=
by filter_upwards [h1, h2] with z h3 h4 using (inv_le_inv h4 h2.self_of_nhds).mpr h3

end local_extr

section preconnected
/-! Some results about functions on preconnected sets valued in a ring or field with a topology. -/

open set
variables {Œ± ùïú : Type*} {f g : Œ± ‚Üí ùïú} {S : set Œ±}
  [topological_space Œ±] [topological_space ùïú] [t1_space ùïú]

/-- If `f` is a function `Œ± ‚Üí ùïú` which is continuous on a preconnected set `S`, and
`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/
lemma is_preconnected.eq_one_or_eq_neg_one_of_sq_eq [ring ùïú] [no_zero_divisors ùïú]
  (hS : is_preconnected S) (hf : continuous_on f S) (hsq : eq_on (f ^ 2) 1 S) :
  (eq_on f 1 S) ‚à® (eq_on f (-1) S) :=
begin
  simp_rw [eq_on, pi.one_apply, pi.pow_apply, sq_eq_one_iff] at hsq,
  -- First deal with crazy case where `S` is empty.
  by_cases hSe : ‚àÄ (x:Œ±), x ‚àâ S,
  { left, intros x hx,
    exfalso, exact hSe x hx, },
  push_neg at hSe,
  choose y hy using hSe,
  suffices : ‚àÄ (x:Œ±), x ‚àà S ‚Üí f x = f y,
  { rcases (hsq hy),
    { left, intros z hz, rw [pi.one_apply z, ‚Üêh], exact this z hz, },
    { right, intros z hz, rw [pi.neg_apply, pi.one_apply, ‚Üêh], exact this z hz, } },
  refine Œª x hx, hS.constant_of_maps_to hf (Œª z hz, _) hx hy,
  show f z ‚àà ({-1, 1} : set ùïú),
  { exact mem_insert_iff.mpr (hsq hz).symm,  },
  exact discrete_of_t1_of_finite,
end

/-- If `f, g` are functions `Œ± ‚Üí ùïú`, both continuous on a preconnected set `S`, with
`f ^ 2 = g ^ 2` on `S`, and `g z ‚â† 0` all `z ‚àà S`, then either `f = g` or `f = -g` on
`S`. -/
lemma is_preconnected.eq_or_eq_neg_of_sq_eq [field ùïú] [has_continuous_inv‚ÇÄ ùïú] [has_continuous_mul ùïú]
  (hS : is_preconnected S) (hf : continuous_on f S) (hg : continuous_on g S)
  (hsq : eq_on (f ^ 2) (g ^ 2) S) (hg_ne : ‚àÄ {x:Œ±}, x ‚àà S ‚Üí g x ‚â† 0) :
  (eq_on f g S) ‚à® (eq_on f (-g) S) :=
begin
  rcases hS.eq_one_or_eq_neg_one_of_sq_eq (hf.div hg (Œª z hz, hg_ne hz)) (Œª x hx, _) with h | h,
  { refine or.inl (Œª x hx, _),
    rw ‚Üêdiv_eq_one_iff_eq (hg_ne hx),
    exact h hx },
  { refine or.inr (Œª x hx, _),
    specialize h hx,
    rwa [pi.div_apply, pi.neg_apply, pi.one_apply, div_eq_iff (hg_ne hx), neg_one_mul] at h,  },
  { rw [pi.one_apply, div_pow, pi.div_apply, hsq hx, div_self],
    exact pow_ne_zero _ (hg_ne hx) },
end

/-- If `f, g` are functions `Œ± ‚Üí ùïú`, both continuous on a preconnected set `S`, with
`f ^ 2 = g ^ 2` on `S`, and `g z ‚â† 0` all `z ‚àà S`, then as soon as `f = g` holds at
one point of `S` it holds for all points. -/
lemma is_preconnected.eq_of_sq_eq [field ùïú] [has_continuous_inv‚ÇÄ ùïú] [has_continuous_mul ùïú]
  (hS : is_preconnected S) (hf : continuous_on f S) (hg : continuous_on g S)
  (hsq : eq_on (f ^ 2) (g ^ 2) S) (hg_ne : ‚àÄ {x:Œ±}, x ‚àà S ‚Üí g x ‚â† 0)
  {y : Œ±} (hy : y ‚àà S) (hy' : f y = g y) : eq_on f g S :=
Œª x hx, begin
  rcases hS.eq_or_eq_neg_of_sq_eq hf hg @hsq @hg_ne with h | h,
  { exact h hx },
  { rw [h hy, eq_comm, ‚Üêsub_eq_zero, sub_eq_add_neg, pi.neg_apply,
      neg_neg, ‚Üêmul_two, mul_eq_zero] at hy',
    cases hy', -- need to handle case of `char ùïú = 2` separately
    { exfalso, exact hg_ne hy hy' },
    { rw [h hx, pi.neg_apply, eq_comm, ‚Üêsub_eq_zero, sub_eq_add_neg, neg_neg,
       ‚Üêmul_two, hy', mul_zero], } },
end

end preconnected
