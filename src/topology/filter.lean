/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import order.filter.lift
import topology.continuous_on
import data.set.intervals.monotone

/-!
# Topology on the set of filters on a type

In this file introduce topology on `filter α`. It is generated by the sets
`set.Iic (𝓟 s) = {l : filter α | s ∈ l}`, `s : set α`. A set `s : set (filter α)` is open if and
only if it is a union of a family of these basic open sets, see `filter.is_open_iff`.

This topology has the following important properties.

* If `X` is a topological space, then the map `𝓝 : X → filter X` is an inducing map.

* In particular, it is a continuous map, so `𝓝 ∘ f` tends to `𝓝 (𝓝 a)` whenever `f` tends to `𝓝 a`.

* If `X` is an ordered topological space with order topology and no max element, then `𝓝 ∘ f` tends
  to `𝓝 filter.at_top` whenever `f` tends to `filter.at_top`.

## Tags

filter, topological space
-/

open set filter topological_space
open_locale filter topological_space

variables {ι : Sort*} {α β X Y : Type*}

namespace filter

/-- Topology on `filter α` is generated by the sets `set.Iic (𝓟 s) = {l : filter α | s ∈ l}`,
`s : set α`. A set `s : set (filter α)` is open if and only if it is a union of a family of these
basic open sets, see `filter.is_open_iff`. -/
instance : topological_space (filter α) := generate_from $ range $ Iic ∘ 𝓟

lemma is_open_Iic_principal {s : set α} : is_open (Iic (𝓟 s)) :=
generate_open.basic _ (mem_range_self _)

lemma is_open_set_of_mem {s : set α} : is_open {l : filter α | s ∈ l} :=
by simpa only [Iic_principal] using is_open_Iic_principal

lemma is_open_iff {s : set (filter α)} :
  is_open s ↔ ∃ T : set (set α), (⋃ t ∈ T, Iic (𝓟 t)) = s :=
begin
  split,
  { intro h, induction h,
    case basic : t ht
    { rcases ht with ⟨t, rfl⟩,
      exact ⟨{t}, bUnion_singleton _ _⟩ },
    case univ
    { exact ⟨univ, Union₂_eq_univ_iff.2 $ λ l, ⟨univ, mem_univ _, le_principal_iff.2 univ_mem⟩⟩ },
    case inter : s t hs' ht' hs ht
    { clear hs' ht', rcases ⟨hs, ht⟩ with ⟨⟨s, rfl⟩, t, rfl⟩,
      refine ⟨image2 (∩) s t, _⟩,
      simp only [image2_eq_Union, bUnion_Union, bUnion_singleton, inter_Union, Union_inter,
        Iic_inter_Iic, inf_principal] },
    case sUnion : S hS' hS
    { choose! T hT using hS,
      use ⋃ t ∈ S, T t,
      simp [hT, sUnion_eq_bUnion] { contextual := tt } } },
  { rintro ⟨T, rfl⟩,
    exact is_open_bUnion (λ t ht, is_open_Iic_principal) }
end

lemma nhds_eq (l : filter α) : 𝓝 l = l.lift' (Iic ∘ 𝓟) :=
nhds_generate_from.trans $ by simp only [mem_set_of_eq, and_comm (l ∈ _), infi_and, infi_range,
  filter.lift', filter.lift, (∘), mem_Iic, le_principal_iff]

lemma nhds_eq' (l : filter α) : 𝓝 l = l.lift' (λ s, {l' | s ∈ l'}) :=
by simpa only [(∘), Iic_principal] using nhds_eq l

protected lemma tendsto_nhds {la : filter α} {lb : filter β} {f : α → filter β} :
  tendsto f la (𝓝 lb) ↔ ∀ s ∈ lb, ∀ᶠ a in la, s ∈ f a :=
by simp only [nhds_eq', tendsto_lift', mem_set_of_eq]

lemma has_basis.nhds {l : filter α} {p : ι → Prop} {s : ι → set α} (h : has_basis l p s) :
  has_basis (𝓝 l) p (λ i, Iic (𝓟 (s i))) :=
by { rw nhds_eq, exact h.lift' monotone_principal.Iic }

lemma has_basis.nhds' {l : filter α} {p : ι → Prop} {s : ι → set α} (h : has_basis l p s) :
  has_basis (𝓝 l) p (λ i, {l' | s i ∈ l'}) :=
by simpa only [Iic_principal] using h.nhds

lemma mem_nhds_iff {l : filter α} {S : set (filter α)} :
  S ∈ 𝓝 l ↔ ∃ t ∈ l, Iic (𝓟 t) ⊆ S :=
l.basis_sets.nhds.mem_iff

lemma mem_nhds_iff' {l : filter α} {S : set (filter α)} :
  S ∈ 𝓝 l ↔ ∃ t ∈ l, ∀ ⦃l' : filter α⦄, t ∈ l' → l' ∈ S :=
l.basis_sets.nhds'.mem_iff

@[simp] lemma nhds_bot : 𝓝 (⊥ : filter α) = pure ⊥ :=
by simp [nhds_eq, lift'_bot monotone_principal.Iic]

@[simp] lemma nhds_top : 𝓝 (⊤ : filter α) = ⊤ := by simp [nhds_eq]

@[simp] lemma nhds_principal (s : set α) : 𝓝 (𝓟 s) = 𝓟 (Iic (𝓟 s)) :=
(has_basis_principal s).nhds.eq_of_same_basis (has_basis_principal _)

@[simp] lemma nhds_pure (x : α) : 𝓝 (pure x : filter α) = 𝓟 {⊥, pure x} :=
by rw [← principal_singleton, nhds_principal, principal_singleton, Iic_pure]

@[simp] lemma nhds_infi (f : ι → filter α) : 𝓝 (⨅ i, f i) = ⨅ i, 𝓝 (f i) :=
by { simp only [nhds_eq], apply lift'_infi_of_map_univ; simp }

@[simp] lemma nhds_inf (l₁ l₂ : filter α) : 𝓝 (l₁ ⊓ l₂) = 𝓝 l₁ ⊓ 𝓝 l₂ :=
by simpa only [infi_bool_eq] using nhds_infi (λ b, cond b l₁ l₂)

lemma monotone_nhds : monotone (𝓝 : filter α → filter (filter α)) :=
monotone.of_map_inf nhds_inf

lemma Inter_nhds (l : filter α) : ⋂₀ {s | s ∈ 𝓝 l} = Iic l :=
by simp only [nhds_eq, sInter_lift'_sets monotone_principal.Iic, Iic, le_principal_iff,
  ← set_of_forall, ← filter.le_def]

@[simp] lemma nhds_mono {l₁ l₂ : filter α} : 𝓝 l₁ ≤ 𝓝 l₂ ↔ l₁ ≤ l₂ :=
begin
  refine ⟨λ h, _, λ h, monotone_nhds h⟩,
  rw [← Iic_subset_Iic, ← Inter_nhds, ← Inter_nhds],
  exact sInter_subset_sInter h
end

protected lemma mem_interior {s : set (filter α)} {l : filter α} :
  l ∈ interior s ↔ ∃ t ∈ l, Iic (𝓟 t) ⊆ s :=
begin
  refine mem_interior.trans ⟨_, _⟩,
  { simp only [is_open_iff],
    rintro ⟨_, hTs, ⟨T, rfl⟩, hT⟩,
    simp only [Union₂_subset_iff, mem_Union₂] at hTs hT,
    rcases hT with ⟨t, htT, ht⟩,
    exact ⟨t, ht (mem_principal_self _), λ l' hl', hTs t htT hl'⟩ },
  { rintro ⟨t, htl, ht⟩,
    exact ⟨_, ht, is_open_Iic_principal, le_principal_iff.2 htl⟩ }
end

protected lemma mem_closure {s : set (filter α)} {l : filter α} :
  l ∈ closure s ↔ ∀ t ∈ l, ∃ l' ∈ s, t ∈ l' :=
by simp only [closure_eq_compl_interior_compl, filter.mem_interior, mem_compl_iff, not_exists,
  not_forall, not_not, exists_prop, not_and, and_comm, subset_def, mem_Iic, le_principal_iff]

@[simp] protected lemma closure_singleton (l : filter α) : closure {l} = Ici l :=
by { ext l', simp [filter.mem_closure, filter.le_def] }

lemma nhds_at_top [preorder α] : 𝓝 at_top = ⨅ x : α, 𝓟 (Iic (𝓟 (Ici x))) :=
by simp only [at_top, nhds_infi, nhds_principal]

protected lemma tendsto_nhds_at_top [preorder β] {l : filter α} {f : α → filter β} :
  tendsto f l (𝓝 at_top) ↔ ∀ y, ∀ᶠ a in l, Ici y ∈ f a :=
by simp only [nhds_at_top, tendsto_infi, tendsto_principal, mem_Iic, le_principal_iff]

lemma nhds_at_bot [preorder α] : 𝓝 at_bot = ⨅ x : α, 𝓟 (Iic (𝓟 (Iic x))) := @nhds_at_top αᵒᵈ _

protected lemma tendsto_nhds_at_bot [preorder β] {l : filter α} {f : α → filter β} :
  tendsto f l (𝓝 at_bot) ↔ ∀ y, ∀ᶠ a in l, Iic y ∈ f a :=
@filter.tendsto_nhds_at_top α βᵒᵈ _ _ _

variables [topological_space X]

lemma nhds_nhds (x : X) :
  𝓝 (𝓝 x) = ⨅ (s : set X) (hs : is_open s) (hx : x ∈ s), 𝓟 (Iic (𝓟 s)) :=
by simp only [nhds_def' x, nhds_infi, nhds_principal]

lemma inducing_nhds : inducing (𝓝 : X → filter X) :=
begin
  refine ⟨eq_of_nhds_eq_nhds $ λ x, (nhds_def' _).trans _⟩,
  simp only [nhds_induced, nhds_nhds, comap_infi, comap_principal, Iic_principal, set_of_mem_eq,
    preimage_set_of_eq, ← mem_interior_iff_mem_nhds, is_open.interior_eq] { contextual := tt }
end

@[continuity] lemma continuous_nhds  : continuous (𝓝 : X → filter X) := inducing_nhds.continuous

lemma tendsto.nhds {f : α → X} {l : filter α} {x : X} (h : tendsto f l (𝓝 x)) :
  tendsto (𝓝 ∘ f) l (𝓝 (𝓝 x)) :=
(continuous_nhds.tendsto _).comp h

end filter

variables [topological_space X] [topological_space Y] {f : X → Y} {x : X} {s : set X}

lemma continuous_within_at.nhds (h : continuous_within_at f s x) :
  continuous_within_at (𝓝 ∘ f) s x :=
h.nhds

lemma continuous_at.nhds (h : continuous_at f x) : continuous_at (𝓝 ∘ f) x := h.nhds
lemma continuous_on.nhds (h : continuous_on f s) : continuous_on (𝓝 ∘ f) s := λ x hx, (h x hx).nhds
lemma continuous.nhds (h : continuous f) : continuous (𝓝 ∘ f) := filter.continuous_nhds.comp h
