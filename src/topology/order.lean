/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Mario Carneiro
-/
import topology.tactic

/-!
# Ordering on topologies and (co)induced topologies

Topologies on a fixed type `α` are ordered, by reverse inclusion.
That is, for topologies `t₁` and `t₂` on `α`, we write `t₁ ≤ t₂`
if every set open in `t₂` is also open in `t₁`.
(One also calls `t₁` finer than `t₂`, and `t₂` coarser than `t₁`.)

Any function `f : α → β` induces
       `induced f : topological_space β → topological_space α`
and  `coinduced f : topological_space α → topological_space β`.
Continuity, the ordering on topologies and (co)induced topologies are
related as follows:
* The identity map (α, t₁) → (α, t₂) is continuous iff t₁ ≤ t₂.
* A map f : (α, t) → (β, u) is continuous
    iff             t ≤ induced f u   (`continuous_iff_le_induced`)
    iff coinduced f t ≤ u             (`continuous_iff_coinduced_le`).

Topologies on α form a complete lattice, with ⊥ the discrete topology
and ⊤ the indiscrete topology.

For a function f : α → β, (coinduced f, induced f) is a Galois connection
between topologies on α and topologies on β.

## Implementation notes

There is a Galois insertion between topologies on α (with the inclusion ordering)
and all collections of sets in α. The complete lattice structure on topologies
on α is defined as the reverse of the one obtained via this Galois insertion.

## Tags

finer, coarser, induced topology, coinduced topology

-/

open set filter function
open_locale classical topological_space filter

universes u v w x

variables {α : Type u} {β : Type v} {γ : Type w} {ι : Sort w}

namespace topological_space

/-!
### Complete lattice structure

In this section we define a `complete_lattice` structure on `topological_space α`. Topologies are
ordered by inverse inclusion: `t₁ ≤ t₂` if every set open in `t₂` is open in `t₁`. The topology `⊥`
is the discrete topology (i.e., all sets are open) and `⊤` is the indiscrete topology (i.e., only
`∅` and `set.univ` are open).

We also prove some lemmas about `Sup`, `⨆`, and `⊔` in this lattice.
 -/

instance : complete_semilattice_Sup (topological_space α) :=
{ le := λ t₁ t₂, t₂.is_open ≤ t₁.is_open,
  Sup := λ T,
    { is_open := λ s, ∀ t ∈ T, (t : topological_space α).is_open s,
      is_open_univ := λ t _, t.is_open_univ,
      is_open_inter := λ s₁ s₂ h₁ h₂ t ht, t.is_open_inter _ _ (h₁ t ht) (h₂ t ht),
      is_open_sUnion := λ S hS t ht, t.is_open_sUnion _ (λ s hs, hS _ hs _ ht) },
  le_Sup := λ S t ht s hs, hs t ht,
  Sup_le := λ S t ht s hs t' ht', ht _ ht' _ hs,
  .. partial_order.lift (λ t : topological_space α, order_dual.to_dual t.is_open)
    (λ _ _, topological_space_eq) }

/-- Topologies on `α` form a complete lattice, with `⊥` the discrete topology
  and `⊤` the indiscrete topology. The infimum of a collection of topologies
  is the topology generated by all their open sets, while the supremem is the
  topology whose open sets are those sets open in every member of the collection. -/
instance : complete_lattice (topological_space α) :=
{ bot := ⟨λ _, true, trivial, λ _ _ _ _, trivial, λ _ _, trivial⟩,
  bot_le := λ _ _ _, trivial,
  sup := λ t₁ t₂,
  { is_open := t₁.is_open ⊓ t₂.is_open,
    is_open_univ := ⟨t₁.is_open_univ, t₂.is_open_univ⟩,
    is_open_inter := λ s₁ s₂ h₁ h₂,
      ⟨t₁.is_open_inter _ _ h₁.1 h₂.1, t₂.is_open_inter _ _ h₁.2 h₂.2⟩,
    is_open_sUnion := λ S hS,
      ⟨t₁.is_open_sUnion _ (λ s hs, (hS s hs).1), t₂.is_open_sUnion _ (λ s hs, (hS s hs).2)⟩},
  le_sup_left := λ t₁ t₂ s hs, hs.1,
  le_sup_right := λ t₁ t₂ s hs, hs.2,
  sup_le := λ t₁ t₂ t₃ h₁ h₂ s hs, ⟨h₁ s hs, h₂ s hs⟩,
  top :=
    { is_open := λ s, s = ∅ ∨ s = univ,
      is_open_univ := or.inr rfl,
      is_open_inter := by rintro s₁ s₂ (rfl|rfl) (rfl|rfl); simp,
      is_open_sUnion := λ S hS, (eq_empty_or_nonempty _).imp id $ λ Hne,
        let ⟨s, hs, hne⟩ := nonempty_sUnion.1 Hne in sUnion_eq_univ_iff.2 $
        λ x, ⟨s, hs, ((hS s hs).resolve_left hne.ne_empty).symm ▸ mem_univ x⟩ },
  le_top := by { rintro t s (rfl|rfl), exacts [@is_open_empty _ t, t.is_open_univ] },
  .. complete_lattice_of_complete_semilattice_Sup (topological_space α) }

instance inhabited_topological_space : inhabited (topological_space α) := ⟨⊤⟩

lemma le_def {a b : topological_space α} : a ≤ b ↔ (∀ s, b.is_open s → a.is_open s) := iff.rfl

lemma is_open_Sup {s : set α} {T : set (topological_space α)} :
  @is_open _ (Sup T) s ↔ ∀ t ∈ T, @is_open _ t s := iff.rfl

lemma is_closed_Sup {s : set α} {T : set (topological_space α)} :
  @is_closed _ (Sup T) s ↔ ∀ t ∈ T, @is_closed _ t s :=
by simp only [← is_open_compl_iff, is_open_Sup]

lemma is_open_supr {ι} {s : set α} {t : ι → topological_space α} :
  @is_open _ (⨆ i, t i) s ↔ ∀ i, @is_open _ (t i) s :=
by simp only [supr, is_open_Sup, forall_range_iff]

lemma is_closed_supr {ι} {s : set α} {t : ι → topological_space α} :
  @is_closed _ (⨆ i, t i) s ↔ ∀ i, @is_closed _ (t i) s :=
by simp only [← is_open_compl_iff, is_open_supr]

lemma is_open_sup {s : set α} {t₁ t₂ : topological_space α} :
  @is_open α (t₁ ⊔ t₂) s ↔ @is_open α t₁ s ∧ @is_open α t₂ s :=
iff.rfl

lemma is_closed_sup {s : set α} {t₁ t₂ : topological_space α} :
  @is_closed α (t₁ ⊔ t₂) s ↔ @is_closed α t₁ s ∧ @is_closed α t₂ s :=
by simp only [← is_open_compl_iff, is_open_sup]

end topological_space

/-!
### Discrete topology

In this section we introduce a typeclass `discrete_topology` saying that the topology on `α` is
equal (but may be not definitionally equal) to `⊥`. -/

/-- A topological space is discrete if every set is open, that is,
  its topology equals the discrete topology `⊥`. -/
class discrete_topology (α : Type*) [t : topological_space α] : Prop :=
(eq_bot [] : t = ⊥)

@[priority 100]
instance discrete_topology_bot (α : Type*) : @discrete_topology α ⊥ :=
{ eq_bot := rfl }

@[simp] lemma is_open_discrete [topological_space α] [discrete_topology α] (s : set α) :
  is_open s :=
(discrete_topology.eq_bot α).symm ▸ trivial

@[simp] lemma is_closed_discrete [topological_space α] [discrete_topology α] (s : set α) :
  is_closed s :=
is_open_compl_iff.1 $ (discrete_topology.eq_bot α).symm ▸ trivial

lemma continuous_of_discrete_topology [topological_space α] [discrete_topology α]
  [topological_space β] {f : α → β} : continuous f :=
continuous_def.2 $ λs hs, is_open_discrete _

lemma nhds_bot (α : Type*) : (@nhds α ⊥) = pure :=
begin
  refine le_antisymm _ (@pure_le_nhds α ⊥),
  assume a s hs,
  exact @is_open.mem_nhds α ⊥ a s trivial hs
end

lemma nhds_discrete (α : Type*) [topological_space α] [discrete_topology α] : (@nhds α _) = pure :=
(discrete_topology.eq_bot α).symm ▸ nhds_bot α

lemma eq_bot_of_singletons_open {t : topological_space α} (h : ∀ x, t.is_open {x}) : t = ⊥ :=
bot_unique $ λ s hs, bUnion_of_singleton s ▸ is_open_bUnion (λ x _, h x)

lemma discrete_topology_of_singletons_open [topological_space α] (h : ∀ x, is_open ({x} : set α)) :
  discrete_topology α :=
⟨eq_bot_of_singletons_open h⟩

lemma forall_open_iff_discrete {X : Type*} [topological_space X] :
  (∀ s : set X, is_open s) ↔ discrete_topology X :=
⟨λ h, ⟨by { ext U , show is_open U ↔ true, simp [h U] }⟩, λ a, @is_open_discrete _ _ a⟩

lemma singletons_open_iff_discrete {X : Type*} [topological_space X] :
  (∀ a : X, is_open ({a} : set X)) ↔ discrete_topology X :=
⟨discrete_topology_of_singletons_open, λ a _, @is_open_discrete _ _ a _⟩

/-!
### Discrete topology instances

In this section we equip some spaces (`empty`, `pempty`, `punit`, `bool`, `ℕ`, `ℤ`) with the
discrete topology. We also prove that any topology on a `subsingleton` is the discrete topoloty.
-/

section discrete_instances

@[priority 100]
instance subsingleton.unique_topological_space [subsingleton α] :
  unique (topological_space α) :=
{ default := ⊥,
  uniq := λ t, eq_bot_of_singletons_open $ λ x, subsingleton.set_cases
    (@is_open_empty _ t) (@is_open_univ _ t) ({x} : set α) }

@[priority 100]
instance subsingleton.discrete_topology [t : topological_space α] [subsingleton α] :
  discrete_topology α :=
⟨unique.eq_default t⟩

instance : topological_space empty := ⊥
instance : discrete_topology empty := ⟨rfl⟩
instance : topological_space pempty := ⊥
instance : discrete_topology pempty := ⟨rfl⟩
instance : topological_space punit := ⊥
instance : discrete_topology punit := ⟨rfl⟩
instance : topological_space bool := ⊥
instance : discrete_topology bool := ⟨rfl⟩
instance : topological_space ℕ := ⊥
instance : discrete_topology ℕ := ⟨rfl⟩
instance : topological_space ℤ := ⊥
instance : discrete_topology ℤ := ⟨rfl⟩

end discrete_instances

/-!
### Topology generated from a subbasic

Given a set of sets `g`, `topological_space.generate_from g` is the greatest topology (the least one
in the sense of inclusion) such that all sets from `g` are open.
-/

namespace topological_space

/-- The open sets of the greateast topology (least in the sense of inclusion) containing a
collection of basic sets. -/
inductive generate_open (g : set (set α)) : set α → Prop
| basic  : ∀s∈g, generate_open s
| univ   : generate_open univ
| inter  : ∀s t, generate_open s → generate_open t → generate_open (s ∩ t)
| sUnion : ∀k, (∀s∈k, generate_open s) → generate_open (⋃₀ k)

/-- The greatest topological space structure (the least in the sense of inclusion)
such that all sets from `g : set (set α)` are open. -/
def generate_from (g : set (set α)) : topological_space α :=
{ is_open        := generate_open g,
  is_open_univ   := generate_open.univ,
  is_open_inter  := generate_open.inter,
  is_open_sUnion := generate_open.sUnion }

/-- `topological_space.generate_from` and `topological_space.is_open` form an order-reversing
Galois insertion. We formulate it using `order_dual`. -/
lemma gc_generate_from (α : Type*) :
  galois_connection (order_dual.to_dual ∘ @generate_from α)
    (λ t, {s | @is_open _ (order_dual.of_dual t) s}) :=
begin
  refine λ g t, ⟨λ ht o ho, ht _ (generate_open.basic o ho), λ ht s hs, _⟩,
  induction hs,
  case basic : s hs { exact ht hs },
  case univ { exact t.is_open_univ },
  case inter : s₁ s₂ h₁' h₂' h₁ h₂ { exact t.is_open_inter _ _ h₁ h₂ },
  case sUnion : S hS' hS { exact t.is_open_sUnion S hS }
end

/-- Characteristic property of `topological_space.generate_from`. -/
lemma is_greatest_generate_from (g : set (set α)) :
  is_greatest {t : topological_space α | ∀ s ∈ g, @is_open _ t s} (generate_from g) :=
(gc_generate_from α).is_least_l

lemma generate_from_eq_Sup (g : set (set α)) :
  generate_from g = Sup {t : topological_space α | ∀ s ∈ g, @is_open _ t s} :=
(is_greatest_generate_from g).is_lub.Sup_eq.symm

lemma le_generate_from_iff {g : set (set α)} {t : topological_space α} :
  t ≤ generate_from g ↔ ∀ s ∈ g, @is_open α t s :=
gc_generate_from α _ _

alias le_generate_from_iff ↔ _ topological_space.le_generate_from

/-- `topological_space.generate_from` and `topological_space.is_open` form an order-reversing
Galois insertion. We formulate it using `order_dual`. -/
lemma gi_generate_from (α : Type*) :
  galois_insertion (order_dual.to_dual ∘ @generate_from α)
    (λ t, {s | @is_open _ (order_dual.of_dual t) s}) :=
(gc_generate_from α).to_galois_insertion $ λ t, (is_greatest_generate_from _).1

@[mono] lemma generate_from_anti {g₁ g₂ : set (set α)} (h : g₁ ⊆ g₂) :
  topological_space.generate_from g₂ ≤ topological_space.generate_from g₁ :=
(gc_generate_from _).monotone_l h

lemma generate_from_set_of_is_open (t : topological_space α) :
  topological_space.generate_from {s | t.is_open s} = t :=
(gi_generate_from α).l_u_eq t

lemma left_inverse_generate_from :
  function.left_inverse topological_space.generate_from
    (λ t : topological_space α, {s | t.is_open s}) :=
(gi_generate_from α).left_inverse_l_u

lemma generate_from_surjective :
  function.surjective (topological_space.generate_from : set (set α) → topological_space α) :=
(gi_generate_from α).l_surjective

lemma set_of_is_open_injective :
  function.injective (λ t : topological_space α, {s | t.is_open s}) :=
(gi_generate_from α).u_injective

lemma generate_from_union (a₁ a₂ : set (set α)) :
  generate_from (a₁ ∪ a₂) = generate_from a₁ ⊓ generate_from a₂ :=
(gc_generate_from α).l_sup

lemma generate_from_Union {f : ι → set (set α)} :
  generate_from (⋃ i, f i) = (⨅ i, generate_from (f i)) :=
(gc_generate_from α).l_supr

lemma generate_from_sUnion {S : set (set (set α))} :
  generate_from (⋃₀ S) = (⨅ s ∈ S, generate_from s) :=
(gc_generate_from α).l_Sup

lemma generate_from_union_is_open (a b : topological_space α) :
  topological_space.generate_from ({s | a.is_open s} ∪ {s | b.is_open s}) = a ⊓ b :=
(gi_generate_from α).l_sup_u a b

lemma generate_from_Union_is_open (f : ι → topological_space α) :
  topological_space.generate_from (⋃ i, {s | (f i).is_open s}) = ⨅ i, (f i) :=
(gi_generate_from α).l_supr_u f

lemma generate_from_inter_is_open (a b : topological_space α) :
  topological_space.generate_from ({s | a.is_open s} ∩ {s | b.is_open s}) = a ⊔ b :=
(gi_generate_from α).l_inf_u a b

lemma generate_from_Inter_is_open (f : ι → topological_space α) :
  topological_space.generate_from (⋂ i, {s | (f i).is_open s}) = ⨆ i, (f i) :=
(gi_generate_from α).l_infi_u f

end topological_space

/-- `g : set (set α)` is a topological subbasis of `α` if the topology on `α` is the -/
def is_topological_subbasis [topological_space α] (g : set (set α)) : Prop :=
‹topological_space α› = topological_space.generate_from g

lemma is_topological_subbasis_opens [topological_space α] :
  is_topological_subbasis {s : set α | is_open s} :=
(topological_space.generate_from_set_of_is_open _).symm

lemma is_topological_subbasis_generate_from (g : set (set α)) :
  @is_topological_subbasis α (topological_space.generate_from g) g := refl _

namespace is_topological_subbasis

variables [topological_space α] {g : set (set α)}
open topological_space

protected lemma eq (h : is_topological_subbasis g) : ‹topological_space α› = generate_from g := h

lemma is_open_iff (h : is_topological_subbasis g) {s : set α} :
  is_open s ↔ generate_open g s :=
by { rw [h.eq], refl }

lemma is_open_of_mem (h : is_topological_subbasis g) {s : set α} (hs : s ∈ g) :
  is_open s :=
h.is_open_iff.2 $ generate_open.basic s hs

lemma nhds_eq (h : is_topological_subbasis g) (a : α) :
  𝓝 a = ⨅ (s : set α) (ha : a ∈ s) (hs : s ∈ g), 𝓟 s :=
begin
  simp only [nhds_def, le_antisymm_iff, le_infi_iff, mem_set_of_eq, and_imp],
  refine ⟨λ s ha hg, infi_le_of_le s $ infi_le _ ⟨ha, h.is_open_of_mem hg⟩, λ s ha hs, _⟩,
  rw h.is_open_iff at hs, induction hs,
  case basic : s hs { exact binfi_le_of_le s ha (infi_le _ hs) },
  case univ { simp only [principal_univ, le_top] },
  case inter : s t hs' ht' hs ht { rw ← inf_principal, exact le_inf (hs ha.1) (ht ha.2) },
  case sUnion : S ihS' ihS { rcases ha with ⟨s, hsS, ha⟩,
    exact (ihS s hsS ha).trans (principal_mono.2 $ subset_sUnion_of_mem hsS) }
end

lemma tendsto_nhds (h : is_topological_subbasis g) {l : filter β} {f : β → α} {a : α} :
  tendsto f l (𝓝 a) ↔ ∀ s, a ∈ s → s ∈ g → ∀ᶠ x in l, f x ∈ s :=
by simp only [h.nhds_eq, tendsto_infi, tendsto_principal]

lemma continuous_iff [topological_space β] (h : is_topological_subbasis g) {f : β → α} :
  continuous f ↔ ∀ s ∈ g, is_open (f ⁻¹' s) :=
begin
  simp only [continuous_iff_continuous_at, continuous_at, h.tendsto_nhds, is_open_iff_mem_nhds],
  exact ⟨λ H s hs a ha, H a s ha hs, λ H a s ha hs, H s hs a ha⟩
end

end is_topological_subbasis

/-!
### Construct a topology from its `nhds` filter

Given a family of filters `n : α → filter α`, `topological_space.mk_of_nhds` is the least topology
`t` (the greatest one in the sense of inclusion) such that `n a ≤ @nhds α t a` for all `a`. In this
section we define `topological_space.mk_of_nhds`, prove that this function forms a Galois insertion
with `nhds α`, and deduce some corollaries from this fact.
-/

namespace topological_space

/-- Construct a topology on `α` given the filter of neighborhoods of each point of `α`. In general,
`topological_space.mk_of_nhds n` is the least topology `t` (the greatest one in the sense of
inclusion) such that `n ≤ @nhds α t`. -/
def mk_of_nhds (n : α → filter α) : topological_space α :=
{ is_open        := λ s, ∀ a ∈ s, s ∈ n a,
  is_open_univ   := assume x h, univ_mem,
  is_open_inter  := assume s t hs ht x ⟨hxs, hxt⟩, inter_mem (hs x hxs) (ht x hxt),
  is_open_sUnion := assume s hs a ⟨x, hx, hxa⟩,
    mem_of_superset (hs x hx _ hxa) (set.subset_sUnion_of_mem hx) }

lemma _root_.gc_nhds (α : Type*) : galois_connection mk_of_nhds (@nhds α) :=
λ n t, ⟨λ hle x, (@nhds_basis_opens α t x).ge_iff.2 $ λ s hs, hle s hs.2 x hs.1,
    λ hle s hs a ha, hle _ $ @is_open.mem_nhds α t _ _ hs ha⟩

lemma _root_.gi_nhds (α : Type*) : galois_insertion mk_of_nhds (@nhds α) :=
(gc_nhds α).to_galois_insertion $ λ t s, (@is_open_iff_mem_nhds α t s).2

@[simp] lemma mk_of_nhds_nhds {t : topological_space α} :
  topological_space.mk_of_nhds (@nhds α t) = t :=
(gi_nhds α).l_u_eq t

lemma le_nhds_mk_of_nhds (n : α → filter α) : n ≤ @nhds α (topological_space.mk_of_nhds n) :=
(gc_nhds α).le_u_l n

lemma is_least_mk_of_nhds (n : α → filter α) :
  is_least {t : topological_space α | n ≤ @nhds α t} (topological_space.mk_of_nhds n) :=
(gc_nhds α).is_least_l

lemma nhds_mk_of_nhds (n : α → filter α) (a : α)
  (h₀ : pure ≤ n) (h₁ : ∀{a s}, s ∈ n a → ∃ t ∈ n a, t ⊆ s ∧ ∀a' ∈ t, s ∈ n a') :
  @nhds α (topological_space.mk_of_nhds n) = n :=
begin
  refine le_antisymm (λ a s hs, _) (le_nhds_mk_of_nhds n),
  letI := topological_space.mk_of_nhds n,
  have h₀ : {b | s ∈ n b} ⊆ s := assume b hb, mem_pure.1 $ h₀ b hb,
  have h₁ : {b | s ∈ n b} ∈ 𝓝 a,
  { refine is_open.mem_nhds (assume b (hb : s ∈ n b), _) hs,
    rcases h₁ hb with ⟨t, ht, hts, h⟩,
    exact mem_of_superset ht h },
  exact mem_of_superset h₁ h₀
end

end topological_space

section gi_nhds

lemma nhds_le_nhds_iff {t₁ t₂ : topological_space α} :
  @nhds α t₁ ≤ @nhds α t₂ ↔ t₁ ≤ t₂ :=
(gi_nhds α).u_le_u_iff

alias nhds_le_nhds_iff ↔ le_of_nhds_le_nhds _

lemma injective_nhds : injective (@nhds α) := (gi_nhds α).u_injective

lemma nhds_mono {t₁ t₂ : topological_space α} (h : t₁ ≤ t₂) :
  @nhds α t₁ ≤ @nhds α t₂ :=
(gc_nhds α).monotone_u h

lemma nhds_infi' {t : ι → topological_space α} :
  @nhds α (infi t) = (⨅ i, @nhds α (t i)) := (gc_nhds α).u_infi

lemma nhds_infi {t : ι → topological_space α} {a : α} :
  @nhds α (infi t) a = (⨅ i, @nhds α (t i) a) :=
by rw [nhds_infi', infi_apply]

lemma nhds_Inf' {s : set (topological_space α)} :
  @nhds α (Inf s) = (⨅t∈s, @nhds α t) := (gc_nhds α).u_Inf

lemma nhds_inf' {t₁ t₂ : topological_space α} :
  @nhds α (t₁ ⊓ t₂) = @nhds α t₁ ⊓ @nhds α t₂ := (gc_nhds α).u_inf

lemma nhds_inf {t₁ t₂ : topological_space α} {a : α} :
  @nhds α (t₁ ⊓ t₂) a = @nhds α t₁ a ⊓ @nhds α t₂ a :=
congr_fun (gc_nhds α).u_inf a

lemma nhds_top' : @nhds α ⊤ = ⊤ := (gc_nhds α).u_top

lemma nhds_top {a : α} : @nhds α ⊤ a = ⊤ :=
congr_fun (gc_nhds α).u_top a

end gi_nhds

section induced_coinduced

/-- Given `f : α → β` and a topology on `β`, the induced topology on `α` is the collection of
  sets that are preimages of some open set in `β`. This is the coarsest topology that
  makes `f` continuous. -/
def topological_space.induced {α : Type u} {β : Type v} (f : α → β) (t : topological_space β) :
  topological_space α :=
{ is_open        := λ s, ∃ s', t.is_open s' ∧ f ⁻¹' s' = s,
  is_open_univ   := ⟨univ, t.is_open_univ, preimage_univ⟩,
  is_open_inter  := by rintro s₁ s₂ ⟨s'₁, hs₁, rfl⟩ ⟨s'₂, hs₂, rfl⟩;
    exact ⟨s'₁ ∩ s'₂, t.is_open_inter _ _ hs₁ hs₂, preimage_inter⟩,
  is_open_sUnion := assume S h,
  begin
    resetI, choose g hgo hg using h,
    use ⋃ (s : set α) (hs : s ∈ S), g s hs,
    simp only [sUnion_eq_bUnion, preimage_Union, hg],
    exact ⟨is_open_Union $ λ s, is_open_Union $ λ hs, hgo _ _, rfl⟩,
  end }

lemma is_open_induced_iff [t : topological_space β] {s : set α} {f : α → β} :
  @is_open α (t.induced f) s ↔ (∃t, is_open t ∧ f ⁻¹' t = s) :=
iff.rfl

lemma is_open_induced_iff' [t : topological_space β] {s : set α} {f : α → β} :
  (t.induced f).is_open s ↔ (∃t, is_open t ∧ f ⁻¹' t = s) :=
iff.rfl

lemma is_closed_induced_iff [t : topological_space β] {s : set α} {f : α → β} :
  @is_closed α (t.induced f) s ↔ (∃t, is_closed t ∧ f ⁻¹' t = s) :=
begin
  simp only [← is_open_compl_iff, is_open_induced_iff],
  exact ⟨λ ⟨t, ht, heq⟩, ⟨tᶜ, by rwa compl_compl, by simp [preimage_compl, heq, compl_compl]⟩,
         λ ⟨t, ht, heq⟩, ⟨tᶜ, ht, by simp only [preimage_compl, heq.symm]⟩⟩
end

/-- Given `f : α → β` and a topology on `α`, the coinduced topology on `β` is defined
  such that `s:set β` is open if the preimage of `s` is open. This is the finest topology that
  makes `f` continuous. -/
def topological_space.coinduced {α : Type u} {β : Type v} (f : α → β) (t : topological_space α) :
  topological_space β :=
{ is_open        := λs, t.is_open (f ⁻¹' s),
  is_open_univ   := by rw preimage_univ; exact t.is_open_univ,
  is_open_inter  := assume s₁ s₂ h₁ h₂, by rw preimage_inter; exact t.is_open_inter _ _ h₁ h₂,
  is_open_sUnion := assume s h, by rw [preimage_sUnion]; exact (@is_open_Union _ _ t _ $ assume i,
    show is_open (⋃ (H : i ∈ s), f ⁻¹' i), from
      @is_open_Union _ _ t _ $ assume hi, h i hi) }

lemma is_open_coinduced {t : topological_space α} {s : set β} {f : α → β} :
  @is_open β (topological_space.coinduced f t) s ↔ is_open (f ⁻¹' s) :=
iff.rfl

lemma preimage_nhds_coinduced [topological_space α] {π : α → β} {s : set β}
  {a : α} (hs : s ∈ @nhds β (topological_space.coinduced π ‹_›) (π a)) : π ⁻¹' s ∈ 𝓝 a :=
begin
  letI := topological_space.coinduced π ‹_›,
  rcases mem_nhds_iff.mp hs with ⟨V, hVs, V_op, mem_V⟩,
  exact mem_nhds_iff.mpr ⟨π ⁻¹' V, set.preimage_mono hVs, V_op, mem_V⟩
end

variables {t tα t₁ t₂ : topological_space α} {tβ : topological_space β} {f : α → β} {g : β → α}

local notation `cont` := @continuous _ _

lemma topological_space.coinduced_le_iff_le_induced :
  tα.coinduced f ≤ tβ ↔ tα ≤ tβ.induced f :=
⟨λ h s ⟨t, ht, hst⟩, hst ▸ h _ ht, λ h s hs, h _ ⟨s, hs, rfl⟩⟩

lemma continuous_iff_coinduced_le : cont tα tβ f ↔ tα.coinduced f ≤ tβ := continuous_def

lemma continuous_iff_le_induced : cont tα tβ f ↔ tα ≤ tβ.induced f :=
continuous_iff_coinduced_le.trans topological_space.coinduced_le_iff_le_induced

alias continuous_iff_coinduced_le ↔ continuous.coinduced_le _
alias continuous_iff_le_induced ↔ continuous.le_induced _

namespace topological_space

lemma gc_coinduced_induced (f : α → β) :
  galois_connection (topological_space.coinduced f) (topological_space.induced f) :=
assume f g, coinduced_le_iff_le_induced

@[mono] lemma induced_mono (h : t₁ ≤ t₂) : t₁.induced g ≤ t₂.induced g :=
(gc_coinduced_induced g).monotone_u h

@[mono] lemma coinduced_mono (h : t₁ ≤ t₂) : t₁.coinduced f ≤ t₂.coinduced f :=
(gc_coinduced_induced f).monotone_l h

@[simp] lemma induced_top : (⊤ : topological_space α).induced g = ⊤ :=
(gc_coinduced_induced g).u_top

@[simp] lemma induced_inf : (t₁ ⊓ t₂).induced g = t₁.induced g ⊓ t₂.induced g :=
(gc_coinduced_induced g).u_inf

@[simp] lemma induced_infi {t : ι → topological_space α} :
  (⨅i, t i).induced g = (⨅i, (t i).induced g) :=
(gc_coinduced_induced g).u_infi

@[simp] lemma coinduced_bot : (⊥ : topological_space α).coinduced f = ⊥ :=
(gc_coinduced_induced f).l_bot

@[simp] lemma coinduced_sup : (t₁ ⊔ t₂).coinduced f = t₁.coinduced f ⊔ t₂.coinduced f :=
(gc_coinduced_induced f).l_sup

@[simp] lemma coinduced_supr {t : ι → topological_space α} :
  (⨆i, t i).coinduced f = (⨆i, (t i).coinduced f) :=
(gc_coinduced_induced f).l_supr

@[simp] lemma induced_id {t : topological_space α} : t.induced id = t :=
topological_space_eq $ funext $ assume s, propext $
  ⟨assume ⟨s', hs, h⟩, h ▸ hs, assume hs, ⟨s, hs, rfl⟩⟩

@[simp] lemma coinduced_id {t : topological_space α} : t.coinduced id = t :=
topological_space_eq rfl

lemma induced_compose {tγ : topological_space γ}
  {f : α → β} {g : β → γ} : (tγ.induced g).induced f = tγ.induced (g ∘ f) :=
topological_space_eq $ funext $ assume s, propext $
  ⟨assume ⟨s', ⟨s, hs, h₂⟩, h₁⟩, h₁ ▸ h₂ ▸ ⟨s, hs, rfl⟩,
    assume ⟨s, hs, h⟩, ⟨preimage g s, ⟨s, hs, rfl⟩, h ▸ rfl⟩⟩

lemma induced_const {t : topological_space α} {x : α} :
  t.induced (λ y : β, x) = ⊤ :=
top_unique (@continuous_const β α ⊤ t x).le_induced

lemma coinduced_compose {tα : topological_space α}
  {f : α → β} {g : β → γ} : (tα.coinduced f).coinduced g = tα.coinduced (g ∘ f) :=
topological_space_eq rfl

lemma induced_generate_from_eq {b : set (set β)} {f : α → β} :
  (generate_from b).induced f = topological_space.generate_from (preimage f '' b) :=
le_antisymm
  (le_generate_from $ ball_image_iff.2 $ assume s hs, ⟨s, generate_open.basic _ hs, rfl⟩)
  (coinduced_le_iff_le_induced.1 $ le_generate_from $ assume s hs,
    generate_open.basic _ $ mem_image_of_mem _ hs)

lemma le_induced_generate_from {α β} [t : topological_space α] {b : set (set β)}
  {f : α → β} (h : ∀ (a : set β), a ∈ b → is_open (f ⁻¹' a)) : t ≤ induced f (generate_from b) :=
begin
  rw induced_generate_from_eq,
  apply le_generate_from,
  simp only [mem_image, and_imp, forall_apply_eq_imp_iff₂, exists_imp_distrib],
  exact h,
end

theorem is_open_induced_iff {s : set α} :
  @is_open _ (induced f tβ) s ↔ s ∈ preimage f '' {s | is_open s} :=
iff.rfl

theorem is_open_induced {s : set β} (h : is_open s) : (induced f tβ).is_open (f ⁻¹' s) :=
⟨s, h, rfl⟩

/-! ### 𝓝 in the induced topology -/

theorem mem_nhds_induced [T : topological_space α] (f : β → α) (a : β) (s : set β) :
  s ∈ @nhds β (topological_space.induced f T) a ↔ ∃ u ∈ 𝓝 (f a), f ⁻¹' u ⊆ s :=
begin
  simp only [mem_nhds_iff, is_open_induced_iff, exists_prop, set.mem_set_of_eq],
  split,
  { rintros ⟨u, usub, ⟨v, openv, ueq⟩, au⟩,
    exact ⟨v, ⟨v, set.subset.refl v, openv, by rwa ←ueq at au⟩, by rw ueq; exact usub⟩ },
  rintros ⟨u, ⟨v, vsubu, openv, amem⟩, finvsub⟩,
  exact ⟨f ⁻¹' v, set.subset.trans (set.preimage_mono vsubu) finvsub, ⟨⟨v, openv, rfl⟩, amem⟩⟩
end

theorem nhds_induced [T : topological_space α] (f : β → α) (a : β) :
  @nhds β (topological_space.induced f T) a = comap f (𝓝 (f a)) :=
by { ext s, rw [mem_nhds_induced, mem_comap] }

lemma induced_iff_nhds_eq [tα : topological_space α] [tβ : topological_space β] (f : β → α) :
  tβ = tα.induced f ↔ ∀ b, 𝓝 b = comap f (𝓝 $ f b) :=
⟨λ h a, h.symm ▸ nhds_induced f a, λ h, injective_nhds $ funext $ λ x, by rw [h, nhds_induced]⟩

lemma map_nhds_induced_eq (a : α) : map f (@nhds α (induced f tβ) a) = 𝓝[range f] (f a) :=
by rw [nhds_induced, filter.map_comap, nhds_within]

theorem map_nhds_induced_of_surjective [T : topological_space α]
    {f : β → α} (hf : function.surjective f) (a : β) :
  map f (@nhds β (topological_space.induced f T) a) = 𝓝 (f a) :=
by rw [nhds_induced, map_comap_of_surjective hf]

lemma map_nhds_induced_of_mem {a : α} (h : range f ∈ 𝓝 (f a)) :
  map f (@nhds α (induced f tβ) a) = 𝓝 (f a) :=
by rw [nhds_induced, filter.map_comap_of_mem h]

lemma closure_induced [t : topological_space β] {f : α → β} {a : α} {s : set α} :
  a ∈ @closure α (topological_space.induced f t) s ↔ f a ∈ closure (f '' s) :=
by simp only [mem_closure_iff_frequently, nhds_induced, frequently_comap, mem_image, and_comm]

end topological_space

end induced_coinduced

/-!
### Sierpinski topology on `Prop`

In this section we equip `Prop` with the Sierpinski topology: the open sets are `∅`, `set.univ`, and
`{true}`. 
-/

section sierpinski

open topological_space

/-- Topology with a single nontrivial open set. Same as `topological_space.generate_from {s₀}`
but has nicer defeq properties for `is_open`. -/
protected def topological_space.singleton (s₀ : set α) : topological_space α :=
{ is_open := λ s, s = ∅ ∨ s = univ ∨ s = s₀,
  is_open_univ := or.inr (or.inl rfl),
  is_open_inter := by rintro s t (rfl|rfl|rfl) (rfl|rfl|rfl); simp,
  is_open_sUnion := λ S hS,
    begin
      by_cases he : ∀ s ∈ S, s = ∅,
      { exact or.inl (sUnion_eq_empty.2 he) },
      { push_neg at he, right,
        by_cases hu : ∃ s ∈ S, s = univ,
        { rcases hu with ⟨s, hs, rfl⟩,
          exact or.inl (eq_univ_of_univ_subset $ subset_sUnion_of_mem hs) },
        { push_neg at hu, right,
          replace hu : ∀ s ∈ S, s = ∅ ∨ s = s₀,
            from λ s hs, (hS s hs).imp id (λ h, h.resolve_left (hu s hs)),
          rcases he with ⟨t, ht, hne⟩, obtain rfl : t = s₀, from (hu t ht).resolve_left hne,
          have : is_greatest S t, from ⟨ht, λ s hs, (hu s hs).elim (λ he, he.symm ▸ bot_le) eq.le⟩,
          exact this.is_lub.Sup_eq } }
    end }

lemma is_topological_subbasis_singleton (s : set α) :
  @is_topological_subbasis α (topological_space.singleton s) {s} :=
begin
  refine le_antisymm (le_generate_from $ λ t (ht : t = s), or.inr $ or.inr ht) _,
  rintro t (rfl|rfl|rfl),
  exacts [@is_open_empty _ (_ : _), @is_open_univ _ (_ : _), generate_open.basic _ rfl]
end

instance sierpinski_space : topological_space Prop :=
topological_space.singleton {true}

@[simp] lemma is_open_Prop {s : set Prop} : is_open s ↔ s = ∅ ∨ s = univ ∨ s = {true} := iff.rfl

lemma is_open_singleton_true : is_open ({true} : set Prop) := or.inr (or.inr rfl)

variables [topological_space α]

lemma continuous_Prop {p : α → Prop} : continuous p ↔ is_open {x | p x} :=
(is_topological_subbasis_singleton {true}).continuous_iff.trans $ by simp [preimage]

lemma is_open_iff_continuous_mem {s : set α} : is_open s ↔ continuous (λ x, x ∈ s) :=
continuous_Prop.symm

alias is_open_iff_continuous_mem ↔ is_open.continuous_mem _

end sierpinski

/-!
### More on continuity and (co)induced topologies
-/

section constructions
open topological_space

local notation `cont` := @continuous _ _
local notation `tspace` := topological_space

variables {f : α → β}

@[continuity]
lemma continuous_induced_dom {t : tspace β} : cont (induced f t) t f :=
by { rw continuous_def, assume s h, exact ⟨_, h, rfl⟩ }

lemma continuous_induced_rng {g : γ → α} {t₂ : tspace β} {t₁ : tspace γ}
  (h : cont t₁ t₂ (f ∘ g)) : cont t₁ (induced f t₂) g :=
begin
  rw continuous_def,
  rintros s ⟨t, ht, rfl⟩,
  simpa using continuous_def.1 h t ht,
end

lemma continuous_induced_rng' [topological_space α] [topological_space β] [topological_space γ]
  {g : γ → α} (f : α → β) (H : ‹topological_space α› = ‹topological_space β›.induced f)
  (h : continuous (f ∘ g)) : continuous g :=
H.symm ▸ continuous_induced_rng h

lemma continuous_coinduced_rng {t : tspace α} : cont t (coinduced f t) f :=
by { rw continuous_def, assume s h, exact h }

lemma continuous_coinduced_dom {g : β → γ} {t₁ : tspace α} {t₂ : tspace γ}
  (h : cont t₁ t₂ (g ∘ f)) : cont (coinduced f t₁) t₂ g :=
begin
  rw continuous_def at h ⊢,
  assume s hs,
  exact h _ hs
end

lemma continuous_le_dom {t₁ t₂ : tspace α} {t₃ : tspace β}
  (h₁ : t₂ ≤ t₁) (h₂ : cont t₁ t₃ f) : cont t₂ t₃ f :=
begin
  rw continuous_def at h₂ ⊢,
  assume s h,
  exact h₁ _ (h₂ s h)
end

lemma continuous_le_rng {t₁ : tspace α} {t₂ t₃ : tspace β}
  (h₁ : t₂ ≤ t₃) (h₂ : cont t₁ t₂ f) : cont t₁ t₃ f :=
begin
  rw continuous_def at h₂ ⊢,
  assume s h,
  exact h₂ s (h₁ s h)
end

lemma continuous_sup_dom {t₁ t₂ : tspace α} {t₃ : tspace β}
  (h₁ : cont t₁ t₃ f) (h₂ : cont t₂ t₃ f) : cont (t₁ ⊔ t₂) t₃ f :=
begin
  rw continuous_def at h₁ h₂ ⊢,
  assume s h,
  exact ⟨h₁ s h, h₂ s h⟩
end

lemma continuous_sup_rng_left {t₁ : tspace α} {t₃ t₂ : tspace β} :
  cont t₁ t₂ f → cont t₁ (t₂ ⊔ t₃) f :=
continuous_le_rng le_sup_left

lemma continuous_sup_rng_right {t₁ : tspace α} {t₃ t₂ : tspace β} :
  cont t₁ t₃ f → cont t₁ (t₂ ⊔ t₃) f :=
continuous_le_rng le_sup_right

lemma continuous_Sup_dom {t₁ : set (tspace α)} {t₂ : tspace β}
  (h : ∀t∈t₁, cont t t₂ f) : cont (Sup t₁) t₂ f :=
continuous_iff_le_induced.2 $ Sup_le $ assume t ht, continuous_iff_le_induced.1 $ h t ht

lemma continuous_Sup_rng {t₁ : tspace α} {t₂ : set (tspace β)} {t : tspace β}
  (h₁ : t ∈ t₂) (hf : cont t₁ t f) : cont t₁ (Sup t₂) f :=
continuous_iff_coinduced_le.2 $ le_Sup_of_le h₁ $ continuous_iff_coinduced_le.1 hf

lemma continuous_supr_dom {t₁ : ι → tspace α} {t₂ : tspace β}
  (h : ∀i, cont (t₁ i) t₂ f) : cont (supr t₁) t₂ f :=
continuous_Sup_dom $ assume t ⟨i, (t_eq : t₁ i = t)⟩, t_eq ▸ h i

lemma continuous_supr_rng {t₁ : tspace α} {t₂ : ι → tspace β} {i : ι}
  (h : cont t₁ (t₂ i) f) : cont t₁ (supr t₂) f :=
continuous_Sup_rng ⟨i, rfl⟩ h

lemma continuous_inf_rng {t₁ : tspace α} {t₂ t₃ : tspace β}
  (h₁ : cont t₁ t₂ f) (h₂ : cont t₁ t₃ f) : cont t₁ (t₂ ⊓ t₃) f :=
continuous_iff_coinduced_le.2 $ le_inf
  (continuous_iff_coinduced_le.1 h₁)
  (continuous_iff_coinduced_le.1 h₂)

lemma continuous_inf_dom_left {t₁ t₂ : tspace α} {t₃ : tspace β} :
  cont t₁ t₃ f → cont (t₁ ⊓ t₂) t₃ f :=
continuous_le_dom inf_le_left

lemma continuous_inf_dom_right {t₁ t₂ : tspace α} {t₃ : tspace β} :
  cont t₂ t₃ f → cont (t₁ ⊓ t₂) t₃ f :=
continuous_le_dom inf_le_right

lemma continuous_Inf_dom {t₁ : set (tspace α)} {t₂ : tspace β} {t : tspace α} (h₁ : t ∈ t₁) :
  cont t t₂ f → cont (Inf t₁) t₂ f :=
continuous_le_dom $ Inf_le h₁

lemma continuous_Inf_rng {t₁ : tspace α} {t₂ : set (tspace β)}
  (h : ∀t∈t₂, cont t₁ t f) : cont t₁ (Inf t₂) f :=
continuous_iff_coinduced_le.2 $ le_Inf $ assume b hb, continuous_iff_coinduced_le.1 $ h b hb

lemma continuous_infi_dom {t₁ : ι → tspace α} {t₂ : tspace β} {i : ι} :
  cont (t₁ i) t₂ f → cont (infi t₁) t₂ f :=
continuous_le_dom $ infi_le _ _

lemma continuous_infi_rng {t₁ : tspace α} {t₂ : ι → tspace β}
  (h : ∀i, cont t₁ (t₂ i) f) : cont t₁ (infi t₂) f :=
continuous_iff_coinduced_le.2 $ le_infi $ assume i, continuous_iff_coinduced_le.1 $ h i

@[continuity] lemma continuous_bot {t : tspace β} : cont ⊥ t f :=
continuous_iff_le_induced.2 $ bot_le

@[continuity] lemma continuous_top {t : tspace α} : cont t ⊤ f :=
continuous_iff_coinduced_le.2 $ le_top

end constructions
