/-
Copyright (c) 2019 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Reid Barton, Patrick Massot, Scott Morrison
-/

import category_theory.concrete_category.unbundled_hom
import category_theory.full_subcategory
import category_theory.monad.limits
import topology.uniform_space.completion
import topology.category.Top.basic

/-!
# The category of uniform spaces

We construct the category of uniform spaces, show that the complete separated uniform spaces
form a reflective subcategory, and hence possess all limits that uniform spaces do.

TODO: show that uniform spaces actually have all limits!
-/

universes u

open category_theory

/-- A (bundled) uniform spaces. -/
@[reducible] def UniformSpace : Type (u+1) := bundled uniform_space

namespace UniformSpace

/-- Construct a bundled `UniformSpace` from the underlying type and the typeclass. -/
def of (Œ± : Type u) [uniform_space Œ±] : UniformSpace := ‚ü®Œ±‚ü©

/-- The category instance on `UniformSpace`. -/
instance concrete_category_uniform_continuous : unbundled_hom @uniform_continuous :=
‚ü®@uniform_continuous_id, @uniform_continuous.comp‚ü©

instance (X : UniformSpace) : uniform_space X := X.str

instance (X Y : UniformSpace) : has_coe_to_fun (X ‚ü∂ Y) :=
{ F := Œª _, X ‚Üí Y, coe := category_theory.functor.map (forget UniformSpace) }

@[simp] lemma coe_comp {X Y Z : UniformSpace} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  (f ‚â´ g : X ‚Üí Z) = g ‚àò f := rfl
@[simp] lemma coe_id (X : UniformSpace) : (ùüô X : X ‚Üí X) = id := rfl
@[simp] lemma coe_mk {X Y : UniformSpace} (f : X ‚Üí Y) (hf : uniform_continuous f) :
  ((‚ü®f, hf‚ü© : X ‚ü∂ Y) : X ‚Üí Y) = f := rfl

@[extensionality] lemma hom_ext {X Y : UniformSpace} {f g : X ‚ü∂ Y} (h : ‚àÄ x : X, f x = g x) : f = g :=
subtype.eq (funext h)

/-- The forgetful functor from uniform spaces to topological spaces. -/
instance has_forget_to_Top : has_forget‚ÇÇ UniformSpace.{u} Top.{u} :=
unbundled_hom.mk_has_forget‚ÇÇ
  @uniform_space.to_topological_space
  @uniform_continuous.continuous

instance complete_space_forget (X) : uniform_space ((forget‚ÇÇ UniformSpace Top).obj X) := X.str

end UniformSpace

/-- A (bundled) complete separated uniform space. -/
structure CpltSepUniformSpace :=
(Œ± : Type u)
[is_uniform_space : uniform_space Œ±]
[is_complete_space : complete_space Œ±]
[is_separated : separated Œ±]

namespace CpltSepUniformSpace

attribute [instance] is_uniform_space is_complete_space is_separated

/-- Construct a bundled `UniformSpace` from the underlying type and the appropriate typeclasses. -/
def of (X : Type u) [uniform_space X] [complete_space X] [separated X] : CpltSepUniformSpace := ‚ü®X‚ü©

/-- The category instance on `CpltSepUniformSpace`. -/
instance concrete_category : concrete_category CpltSepUniformSpace :=
induced_category.concrete_category (Œª X, UniformSpace.of X.Œ±)

instance has_forget_to_UniformSpace : has_forget‚ÇÇ CpltSepUniformSpace UniformSpace :=
induced_category.has_forget‚ÇÇ (Œª X, UniformSpace.of X.Œ±)

instance : has_coe_to_sort CpltSepUniformSpace := concrete_category.has_coe_to_sort CpltSepUniformSpace

instance complete_space_forget (X) : complete_space ((forget‚ÇÇ CpltSepUniformSpace UniformSpace).obj X) := X.is_complete_space
instance separated_forget (X) : separated ((forget‚ÇÇ CpltSepUniformSpace UniformSpace).obj X) := X.is_separated

end CpltSepUniformSpace

namespace UniformSpace
local notation `U` := (forget‚ÇÇ CpltSepUniformSpace UniformSpace).obj

open uniform_space
open CpltSepUniformSpace

/-- The functor turning uniform spaces into complete separated uniform spaces. -/
noncomputable def completion_functor : UniformSpace ‚•§ CpltSepUniformSpace :=
{ obj := Œª X, CpltSepUniformSpace.of (completion X),
  map := Œª X Y f, ‚ü®completion.map f.1, completion.uniform_continuous_map‚ü©,
  map_comp' := Œª X Y Z f g,
  begin
    apply subtype.eq,
    dsimp,
    rw ‚Üêcompletion.map_comp g.property f.property,
    refl,
  end }.

/-- The inclusion of any uniform spaces into its completion. -/
def completion_hom (X : UniformSpace) :
  X ‚ü∂ U (completion_functor.obj X) :=
{ val := (coe : X ‚Üí completion X),
  property := completion.uniform_continuous_coe X }

@[simp] lemma completion_hom_val (X : UniformSpace) (x) :
  (completion_hom X) x = (x : completion X) := rfl

/-- The mate of a morphism from a `UniformSpace` to a `CpltSepUniformSpace`. -/
noncomputable def extension_hom {X : UniformSpace} {Y : CpltSepUniformSpace}
  (f : X ‚ü∂ U Y) :
  completion_functor.obj X ‚ü∂ Y :=
{ val := completion.extension f,
  property := completion.uniform_continuous_extension }

@[simp] lemma extension_hom_val {X : UniformSpace} {Y : CpltSepUniformSpace}
  (f : X ‚ü∂ U Y) (x) :
    (extension_hom f) x = completion.extension f x := rfl.

@[simp] lemma extension_comp_coe {X : UniformSpace} {Y : CpltSepUniformSpace}
  (f : U (CpltSepUniformSpace.of (completion X)) ‚ü∂ U Y) :
    extension_hom (completion_hom X ‚â´ f) = f :=
by { apply subtype.eq, funext x, exact congr_fun (completion.extension_comp_coe f.property) x }

/-- The completion functor is left adjoint to the forgetful functor. -/
noncomputable def adj : completion_functor.{u} ‚ä£ forget‚ÇÇ CpltSepUniformSpace UniformSpace :=
adjunction.mk_of_hom_equiv
{ hom_equiv := Œª X Y,
  { to_fun := Œª f, completion_hom X ‚â´ f,
    inv_fun := Œª f, extension_hom f,
    left_inv := Œª f, by { dsimp, erw extension_comp_coe },
    right_inv := Œª f, by { ext, exact completion.extension_coe f.property x, } },
  hom_equiv_naturality_left_symm' := Œª X X' Y f g,
  begin
    ext, dsimp,
    erw [coe_comp, ‚Üêcompletion.extension_map g.property f.property],
    refl,
  end }

noncomputable instance : is_right_adjoint (forget‚ÇÇ CpltSepUniformSpace UniformSpace) :=
‚ü®completion_functor, adj‚ü©
noncomputable instance : reflective (forget‚ÇÇ CpltSepUniformSpace UniformSpace) := {}

open category_theory.limits

-- TODO Once someone defines `has_limits UniformSpace`, turn this into an instance.
noncomputable example [has_limits.{u} UniformSpace.{u}] : has_limits.{u} CpltSepUniformSpace.{u} :=
has_limits_of_reflective $ forget‚ÇÇ CpltSepUniformSpace UniformSpace

end UniformSpace
