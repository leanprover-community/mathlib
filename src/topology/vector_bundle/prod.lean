/-
Copyright ¬© 2022 Heather Macbeth. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth, Floris van Doorn
-/

import topology.vector_bundle.basic

/-!
# Fiberwise product of two vector bundles

If `E‚ÇÅ : B ‚Üí Type*` and `E‚ÇÇ : B ‚Üí Type*` define two fiber bundles over `R` with fiber
models `F‚ÇÅ` and `F‚ÇÇ`, we define the bundle of fibrewise products `E‚ÇÅ √ó·µá E‚ÇÇ := Œª x, E‚ÇÅ x √ó E‚ÇÇ x`.

If moreover `E‚ÇÅ` and `E‚ÇÇ` are vector bundles over `R`, we can endow `E‚ÇÅ √ó·µá E‚ÇÇ` with a vector bundle
structure: `bundle.prod.vector_bundle`, the direct sum of the two vector bundles.

A similar construction (which is yet to be formalized) can be done for the vector bundle of
continuous linear maps from `E‚ÇÅ x` to `E‚ÇÇ x` with fiber a type synonym
`vector_bundle_continuous_linear_map R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ x := (E‚ÇÅ x ‚ÜíL[R] E‚ÇÇ x)` (and with the
topology inherited from the norm-topology on `F‚ÇÅ ‚ÜíL[R] F‚ÇÇ`, without the need to define the strong
topology on continuous linear maps between general topological vector spaces).  Likewise for tensor
products of topological vector bundles, exterior algebras, and so on, where the topology can be
defined using a norm on the fiber model if this helps.

## Tags
Vector bundle, fiberwise product, direct sum
-/

noncomputable theory

open bundle set
open_locale classical bundle

variables (R ùïú : Type*) {B : Type*} (F : Type*) (E : B ‚Üí Type*)

section defs
variables (E‚ÇÅ : B ‚Üí Type*) (E‚ÇÇ : B ‚Üí Type*)
variables [topological_space (total_space E‚ÇÅ)] [topological_space (total_space E‚ÇÇ)]

/-- Equip the total space of the fibrewise product of two fiber bundles `E‚ÇÅ`, `E‚ÇÇ` with
the induced topology from the diagonal embedding into `total_space E‚ÇÅ √ó total_space E‚ÇÇ`. -/
instance fiber_bundle.prod.topological_space :
  topological_space (total_space (E‚ÇÅ √ó·µá E‚ÇÇ)) :=
topological_space.induced
  (Œª p, ((‚ü®p.1, p.2.1‚ü© : total_space E‚ÇÅ), (‚ü®p.1, p.2.2‚ü© : total_space E‚ÇÇ)))
  (by apply_instance : topological_space (total_space E‚ÇÅ √ó total_space E‚ÇÇ))

/-- The diagonal map from the total space of the fibrewise product of two fiber bundles
`E‚ÇÅ`, `E‚ÇÇ` into `total_space E‚ÇÅ √ó total_space E‚ÇÇ` is `inducing`. -/
lemma fiber_bundle.prod.inducing_diag : inducing
  (Œª p, (‚ü®p.1, p.2.1‚ü©, ‚ü®p.1, p.2.2‚ü©) :
    total_space (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí total_space E‚ÇÅ √ó total_space E‚ÇÇ) :=
‚ü®rfl‚ü©

end defs

open fiber_bundle

variables [nontrivially_normed_field R] [topological_space B]

variables (F‚ÇÅ' : Type*) [topological_space F‚ÇÅ']
  (F‚ÇÅ : Type*) [normed_add_comm_group F‚ÇÅ] [normed_space R F‚ÇÅ]
  (E‚ÇÅ : B ‚Üí Type*) [topological_space (total_space E‚ÇÅ)]

variables (F‚ÇÇ' : Type*) [topological_space F‚ÇÇ']
  (F‚ÇÇ : Type*) [normed_add_comm_group F‚ÇÇ] [normed_space R F‚ÇÇ]
  (E‚ÇÇ : B ‚Üí Type*) [topological_space (total_space E‚ÇÇ)]

namespace trivialization
variables (Œµ‚ÇÅ : trivialization F‚ÇÅ' (œÄ E‚ÇÅ)) (Œµ‚ÇÇ : trivialization F‚ÇÇ' (œÄ E‚ÇÇ))
variables (e‚ÇÅ : trivialization F‚ÇÅ (œÄ E‚ÇÅ)) (e‚ÇÇ : trivialization F‚ÇÇ (œÄ E‚ÇÇ))
include Œµ‚ÇÅ Œµ‚ÇÇ
variables {R F‚ÇÅ' F‚ÇÅ E‚ÇÅ F‚ÇÇ' F‚ÇÇ E‚ÇÇ}

/-- Given trivializations `e‚ÇÅ`, `e‚ÇÇ` for fiber bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the forward
function for the construction `trivialization.prod`, the induced
trivialization for the fibrewise product of `E‚ÇÅ` and `E‚ÇÇ`. -/
def prod.to_fun' : total_space (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí B √ó (F‚ÇÅ' √ó F‚ÇÇ') :=
Œª p, ‚ü®p.1, (Œµ‚ÇÅ ‚ü®p.1, p.2.1‚ü©).2, (Œµ‚ÇÇ ‚ü®p.1, p.2.2‚ü©).2‚ü©

variables {Œµ‚ÇÅ Œµ‚ÇÇ}

lemma prod.continuous_to_fun : continuous_on (prod.to_fun' Œµ‚ÇÅ Œµ‚ÇÇ)
  (@total_space.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set)) :=
begin
  let f‚ÇÅ : total_space (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí total_space E‚ÇÅ √ó total_space E‚ÇÇ :=
    Œª p, ((‚ü®p.1, p.2.1‚ü© : total_space E‚ÇÅ), (‚ü®p.1, p.2.2‚ü© : total_space E‚ÇÇ)),
  let f‚ÇÇ : total_space E‚ÇÅ √ó total_space E‚ÇÇ ‚Üí (B √ó F‚ÇÅ') √ó (B √ó F‚ÇÇ') := Œª p, ‚ü®Œµ‚ÇÅ p.1, Œµ‚ÇÇ p.2‚ü©,
  let f‚ÇÉ : (B √ó F‚ÇÅ') √ó (B √ó F‚ÇÇ') ‚Üí B √ó F‚ÇÅ' √ó F‚ÇÇ' := Œª p, ‚ü®p.1.1, p.1.2, p.2.2‚ü©,
  have hf‚ÇÅ : continuous f‚ÇÅ := (prod.inducing_diag E‚ÇÅ E‚ÇÇ).continuous,
  have hf‚ÇÇ : continuous_on f‚ÇÇ (Œµ‚ÇÅ.source √óÀ¢ Œµ‚ÇÇ.source) :=
    Œµ‚ÇÅ.to_local_homeomorph.continuous_on.prod_map Œµ‚ÇÇ.to_local_homeomorph.continuous_on,
  have hf‚ÇÉ : continuous f‚ÇÉ :=
    (continuous_fst.comp continuous_fst).prod_mk (continuous_snd.prod_map continuous_snd),
  refine ((hf‚ÇÉ.comp_continuous_on hf‚ÇÇ).comp hf‚ÇÅ.continuous_on _).congr _,
  { rw [Œµ‚ÇÅ.source_eq, Œµ‚ÇÇ.source_eq],
    exact maps_to_preimage _ _ },
  rintros ‚ü®b, v‚ÇÅ, v‚ÇÇ‚ü© ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©,
  simp only [prod.to_fun', prod.mk.inj_iff, eq_self_iff_true, and_true],
  rw Œµ‚ÇÅ.coe_fst,
  rw [Œµ‚ÇÅ.source_eq, mem_preimage],
  exact hb‚ÇÅ,
end

variables (Œµ‚ÇÅ Œµ‚ÇÇ) [nz‚ÇÅ : Œ† x, has_zero (E‚ÇÅ x)] [nz‚ÇÇ : ‚àÄ x, has_zero (E‚ÇÇ x)]
  [mnd‚ÇÅ : Œ† x, add_comm_monoid (E‚ÇÅ x)] [mdl‚ÇÅ : Œ† x, module R (E‚ÇÅ x)]
  [mnd‚ÇÇ : Œ† x, add_comm_monoid (E‚ÇÇ x)] [mdl‚ÇÇ : Œ† x, module R (E‚ÇÇ x)]

include nz‚ÇÅ nz‚ÇÇ

/-- Given trivializations `Œµ‚ÇÅ`, `Œµ‚ÇÇ` for fiber bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the inverse
function for the construction `trivialization.prod`, the induced
trivialization for the fibrewise product of `E‚ÇÅ` and `E‚ÇÇ`. -/
def prod.inv_fun' (p : B √ó (F‚ÇÅ' √ó F‚ÇÇ')) : total_space (E‚ÇÅ √ó·µá E‚ÇÇ) :=
‚ü®p.1, Œµ‚ÇÅ.symm p.1 p.2.1, Œµ‚ÇÇ.symm p.1 p.2.2‚ü©

variables {Œµ‚ÇÅ Œµ‚ÇÇ}

lemma prod.left_inv {x : total_space (E‚ÇÅ √ó·µá E‚ÇÇ)}
  (h : x ‚àà @total_space.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set)) :
  prod.inv_fun' Œµ‚ÇÅ Œµ‚ÇÇ (prod.to_fun' Œµ‚ÇÅ Œµ‚ÇÇ x) = x :=
begin
  obtain ‚ü®x, v‚ÇÅ, v‚ÇÇ‚ü© := x,
  obtain ‚ü®h‚ÇÅ : x ‚àà Œµ‚ÇÅ.base_set, h‚ÇÇ : x ‚àà Œµ‚ÇÇ.base_set‚ü© := h,
  simp only [prod.to_fun', prod.inv_fun', symm_apply_apply_mk, h‚ÇÅ, h‚ÇÇ]
end

lemma prod.right_inv {x : B √ó F‚ÇÅ' √ó F‚ÇÇ'}
  (h : x ‚àà (Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set) √óÀ¢ (univ : set (F‚ÇÅ' √ó F‚ÇÇ'))) :
  prod.to_fun' Œµ‚ÇÅ Œµ‚ÇÇ (prod.inv_fun' Œµ‚ÇÅ Œµ‚ÇÇ x) = x :=
begin
  obtain ‚ü®x, w‚ÇÅ, w‚ÇÇ‚ü© := x,
  obtain ‚ü®‚ü®h‚ÇÅ : x ‚àà Œµ‚ÇÅ.base_set, h‚ÇÇ : x ‚àà Œµ‚ÇÇ.base_set‚ü©, -‚ü© := h,
  simp only [prod.to_fun', prod.inv_fun', apply_mk_symm, h‚ÇÅ, h‚ÇÇ]
end

lemma prod.continuous_inv_fun :
  continuous_on (prod.inv_fun' Œµ‚ÇÅ Œµ‚ÇÇ) ((Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set) √óÀ¢ univ) :=
begin
  rw (prod.inducing_diag E‚ÇÅ E‚ÇÇ).continuous_on_iff,
  have H‚ÇÅ : continuous (Œª p : B √ó F‚ÇÅ' √ó F‚ÇÇ', ((p.1, p.2.1), (p.1, p.2.2))) :=
    (continuous_id.prod_map continuous_fst).prod_mk (continuous_id.prod_map continuous_snd),
  refine (Œµ‚ÇÅ.continuous_on_symm.prod_map Œµ‚ÇÇ.continuous_on_symm).comp H‚ÇÅ.continuous_on _,
  exact Œª x h, ‚ü®‚ü®h.1.1, mem_univ _‚ü©, ‚ü®h.1.2, mem_univ _‚ü©‚ü©
end

variables (e‚ÇÅ e‚ÇÇ Œµ‚ÇÅ Œµ‚ÇÇ R)
variables [Œ† x : B, topological_space (E‚ÇÅ x)] [Œ† x : B, topological_space (E‚ÇÇ x)]
  [fiber_bundle F‚ÇÅ' E‚ÇÅ] [fiber_bundle F‚ÇÇ' E‚ÇÇ] [fiber_bundle F‚ÇÅ E‚ÇÅ] [fiber_bundle F‚ÇÇ E‚ÇÇ]

/-- Given trivializations `Œµ‚ÇÅ`, `Œµ‚ÇÇ` for fiber bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the induced
trivialization for the fibrewise product of `E‚ÇÅ` and `E‚ÇÇ`, whose base set is
`Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set`. -/
@[nolint unused_arguments]
def prod : trivialization (F‚ÇÅ' √ó F‚ÇÇ') (œÄ (E‚ÇÅ √ó·µá E‚ÇÇ)) :=
{ to_fun := prod.to_fun' Œµ‚ÇÅ Œµ‚ÇÇ,
  inv_fun := prod.inv_fun' Œµ‚ÇÅ Œµ‚ÇÇ,
  source := (@total_space.proj B (E‚ÇÅ √ó·µá E‚ÇÇ)) ‚Åª¬π' (Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set),
  target := (Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set) √óÀ¢ set.univ,
  map_source' := Œª x h, ‚ü®h, set.mem_univ _‚ü©,
  map_target' := Œª x h, h.1,
  left_inv' := Œª x, prod.left_inv,
  right_inv' := Œª x, prod.right_inv,
  open_source := begin
    refine (Œµ‚ÇÅ.open_base_set.inter Œµ‚ÇÇ.open_base_set).preimage _,
    have : continuous (@total_space.proj B E‚ÇÅ) := continuous_proj F‚ÇÅ' E‚ÇÅ,
    exact this.comp (prod.inducing_diag E‚ÇÅ E‚ÇÇ).continuous.fst,
  end,
  open_target := (Œµ‚ÇÅ.open_base_set.inter Œµ‚ÇÇ.open_base_set).prod is_open_univ,
  continuous_to_fun := prod.continuous_to_fun,
  continuous_inv_fun := prod.continuous_inv_fun,
  base_set := Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set,
  open_base_set := Œµ‚ÇÅ.open_base_set.inter Œµ‚ÇÇ.open_base_set,
  source_eq := rfl,
  target_eq := rfl,
  proj_to_fun := Œª x h, rfl }

omit nz‚ÇÅ nz‚ÇÇ Œµ‚ÇÅ Œµ‚ÇÇ
include mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

instance prod.is_linear [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] : (e‚ÇÅ.prod e‚ÇÇ).is_linear R :=
{ linear := Œª x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, (((e‚ÇÅ.linear R h‚ÇÅ).mk' _).prod_map ((e‚ÇÇ.linear R h‚ÇÇ).mk' _)).is_linear }

omit mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ
include nz‚ÇÅ nz‚ÇÇ

@[simp] lemma base_set_prod : (prod Œµ‚ÇÅ Œµ‚ÇÇ).base_set = Œµ‚ÇÅ.base_set ‚à© Œµ‚ÇÇ.base_set :=
rfl

omit nz‚ÇÅ nz‚ÇÇ
include mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

variables {e‚ÇÅ e‚ÇÇ Œµ‚ÇÅ Œµ‚ÇÇ}

variables (R)

lemma prod_apply
  [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] {x : B} (hx‚ÇÅ : x ‚àà e‚ÇÅ.base_set)
  (hx‚ÇÇ : x ‚àà e‚ÇÇ.base_set) (v‚ÇÅ : E‚ÇÅ x) (v‚ÇÇ : E‚ÇÇ x) :
  prod e‚ÇÅ e‚ÇÇ ‚ü®x, (v‚ÇÅ, v‚ÇÇ)‚ü©
  = ‚ü®x, e‚ÇÅ.continuous_linear_equiv_at R x hx‚ÇÅ v‚ÇÅ, e‚ÇÇ.continuous_linear_equiv_at R x hx‚ÇÇ v‚ÇÇ‚ü© :=
rfl

omit mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ
include nz‚ÇÅ nz‚ÇÇ

lemma prod_symm_apply (x : B) (w‚ÇÅ : F‚ÇÅ') (w‚ÇÇ : F‚ÇÇ') : (prod Œµ‚ÇÅ Œµ‚ÇÇ).to_local_equiv.symm (x, w‚ÇÅ, w‚ÇÇ)
  = ‚ü®x, Œµ‚ÇÅ.symm x w‚ÇÅ, Œµ‚ÇÇ.symm x w‚ÇÇ‚ü© :=
rfl

end trivialization

open trivialization

variables [nz‚ÇÅ : Œ† x, has_zero (E‚ÇÅ x)] [nz‚ÇÇ : ‚àÄ x, has_zero (E‚ÇÇ x)]
  [mnd‚ÇÅ : Œ† x, add_comm_monoid (E‚ÇÅ x)] [mdl‚ÇÅ : Œ† x, module R (E‚ÇÅ x)]
  [mnd‚ÇÇ : Œ† x, add_comm_monoid (E‚ÇÇ x)] [mdl‚ÇÇ : Œ† x, module R (E‚ÇÇ x)]

variables [Œ† x : B, topological_space (E‚ÇÅ x)] [Œ† x : B, topological_space (E‚ÇÇ x)]
  [fiber_bundle F‚ÇÅ' E‚ÇÅ] [fiber_bundle F‚ÇÇ' E‚ÇÇ]
  [fiber_bundle F‚ÇÅ E‚ÇÅ] [fiber_bundle F‚ÇÇ E‚ÇÇ]

include nz‚ÇÅ nz‚ÇÇ

/-- The product of two fiber bundles is a fiber bundle. -/
instance _root_.bundle.prod.fiber_bundle : fiber_bundle (F‚ÇÅ' √ó F‚ÇÇ') (E‚ÇÅ √ó·µá E‚ÇÇ) :=
{ total_space_mk_inducing := Œª b,
  begin
    rw (prod.inducing_diag E‚ÇÅ E‚ÇÇ).inducing_iff,
    exact (total_space_mk_inducing F‚ÇÅ' E‚ÇÅ b).prod_mk (total_space_mk_inducing F‚ÇÇ' E‚ÇÇ b),
  end,
  trivialization_atlas :=
    {e |  ‚àÉ (e‚ÇÅ : trivialization F‚ÇÅ' (œÄ E‚ÇÅ)) (e‚ÇÇ : trivialization F‚ÇÇ' (œÄ E‚ÇÇ))
    [mem_trivialization_atlas e‚ÇÅ] [mem_trivialization_atlas e‚ÇÇ], by exactI
    e = trivialization.prod e‚ÇÅ e‚ÇÇ},
  trivialization_at := Œª b, (trivialization_at F‚ÇÅ' E‚ÇÅ b).prod (trivialization_at F‚ÇÇ' E‚ÇÇ b),
  mem_base_set_trivialization_at :=
    Œª b, ‚ü®mem_base_set_trivialization_at F‚ÇÅ' E‚ÇÅ b, mem_base_set_trivialization_at F‚ÇÇ' E‚ÇÇ b‚ü©,
  trivialization_mem_atlas := Œª b, ‚ü®trivialization_at F‚ÇÅ' E‚ÇÅ b, trivialization_at F‚ÇÇ' E‚ÇÇ b,
    by apply_instance, by apply_instance, rfl‚ü© }

omit nz‚ÇÅ nz‚ÇÇ
include mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

/-- The product of two vector bundles is a vector bundle. -/
instance _root_.bundle.prod.vector_bundle  [vector_bundle R F‚ÇÅ E‚ÇÅ] [vector_bundle R F‚ÇÇ E‚ÇÇ] :
  vector_bundle R (F‚ÇÅ √ó F‚ÇÇ) (E‚ÇÅ √ó·µá E‚ÇÇ) :=
{ trivialization_linear' := begin
    rintros _ ‚ü®e‚ÇÅ, e‚ÇÇ, he‚ÇÅ, he‚ÇÇ, rfl‚ü©, resetI,
    apply_instance
  end,
  continuous_on_coord_change' := begin
    rintros _ _ ‚ü®e‚ÇÅ, e‚ÇÇ, he‚ÇÅ, he‚ÇÇ, rfl‚ü© ‚ü®e‚ÇÅ', e‚ÇÇ', he‚ÇÅ', he‚ÇÇ', rfl‚ü©, resetI,
    refine (((continuous_on_coord_change R e‚ÇÅ e‚ÇÅ').mono _).prod_mapL R
      ((continuous_on_coord_change R e‚ÇÇ e‚ÇÇ').mono _)).congr _;
    dsimp only [base_set_prod] with mfld_simps,
    { mfld_set_tac },
    { mfld_set_tac },
    { rintro b hb,
      rw [continuous_linear_map.ext_iff],
      rintro ‚ü®v‚ÇÅ, v‚ÇÇ‚ü©,
      show (e‚ÇÅ.prod e‚ÇÇ).coord_changeL R (e‚ÇÅ'.prod e‚ÇÇ') b (v‚ÇÅ, v‚ÇÇ) =
        (e‚ÇÅ.coord_changeL R e‚ÇÅ' b v‚ÇÅ, e‚ÇÇ.coord_changeL R e‚ÇÇ' b v‚ÇÇ),
      rw [e‚ÇÅ.coord_changeL_apply e‚ÇÅ', e‚ÇÇ.coord_changeL_apply e‚ÇÇ',
        (e‚ÇÅ.prod e‚ÇÇ).coord_changeL_apply'],
      exacts [rfl, hb, ‚ü®hb.1.2, hb.2.2‚ü©, ‚ü®hb.1.1, hb.2.1‚ü©] }
  end }

omit mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ
include nz‚ÇÅ nz‚ÇÇ

instance _root_.bundle.prod.mem_trivialization_atlas {e‚ÇÅ : trivialization F‚ÇÅ' (œÄ E‚ÇÅ)}
  {e‚ÇÇ : trivialization F‚ÇÇ' (œÄ E‚ÇÇ)} [mem_trivialization_atlas e‚ÇÅ] [mem_trivialization_atlas e‚ÇÇ] :
  mem_trivialization_atlas (e‚ÇÅ.prod e‚ÇÇ : trivialization (F‚ÇÅ' √ó F‚ÇÇ') (œÄ (E‚ÇÅ √ó·µá E‚ÇÇ))) :=
{ out := ‚ü®e‚ÇÅ, e‚ÇÇ, by apply_instance, by apply_instance, rfl‚ü© }

variables {R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ}

omit nz‚ÇÅ nz‚ÇÇ
include mnd‚ÇÅ mdl‚ÇÅ mnd‚ÇÇ mdl‚ÇÇ

@[simp] lemma trivialization.continuous_linear_equiv_at_prod {e‚ÇÅ : trivialization F‚ÇÅ (œÄ E‚ÇÅ)}
  {e‚ÇÇ : trivialization F‚ÇÇ (œÄ E‚ÇÇ)} [e‚ÇÅ.is_linear R] [e‚ÇÇ.is_linear R] {x : B} (hx‚ÇÅ : x ‚àà e‚ÇÅ.base_set)
  (hx‚ÇÇ : x ‚àà e‚ÇÇ.base_set) :
  (e‚ÇÅ.prod e‚ÇÇ).continuous_linear_equiv_at R x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
  = (e‚ÇÅ.continuous_linear_equiv_at R x hx‚ÇÅ).prod (e‚ÇÇ.continuous_linear_equiv_at R x hx‚ÇÇ) :=
begin
  ext1,
  funext v,
  obtain ‚ü®v‚ÇÅ, v‚ÇÇ‚ü© := v,
  rw [(e‚ÇÅ.prod e‚ÇÇ).continuous_linear_equiv_at_apply R, trivialization.prod],
  exact (congr_arg prod.snd (prod_apply R hx‚ÇÅ hx‚ÇÇ v‚ÇÅ v‚ÇÇ) : _)
end
