/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, Ya√´l Dillies
-/
import data.set.pointwise
import order.filter.basic

/-!
# Pointwise operations on filters

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(f‚ÇÅ * f‚ÇÇ).map m  = f‚ÇÅ.map m * f‚ÇÇ.map m`
* `ùìù (x * y) = ùìù x * ùìù y`

## Main declarations

* `0` (`filter.has_zero`): Principal filter at `0 : Œ±`.
* `1` (`filter.has_one`): Principal filter at `1 : Œ±`.
* `f + g` (`filter.has_add`): Addition, filter generated by all `s + t` where `s ‚àà f` and `t ‚àà g`.
* `f * g` (`filter.has_mul`): Multiplication, filter generated by all `s * t` where `s ‚àà f` and
  `t ‚àà g`.
* `-f` (`filter.has_neg`): Negation, filter of all `-s` where `s ‚àà f`.
* `f‚Åª¬π` (`filter.has_inv`): Inversion, filter of all `x‚Åª¬π` where `s ‚àà f`.
* `f - g` (`filter.has_sub`): Subtraction, filter generated by all `x - y` where `s ‚àà f` and
  `t ‚àà g`.
* `f / g` (`filter.has_div`): Division, filter generated by all `x / y` where `s ‚àà f` and `t ‚àà g`.
* `f +·µ• g` (`filter.has_vadd`): Scalar addition, filter generated by all `x +·µ• y` where `s ‚àà f` and
  `t ‚àà g`.
* `f -·µ• g` (`filter.has_vsub`): Scalar subtraction, filter generated by all `x -·µ• y` where `s ‚àà f`
  and `t ‚àà g`.
* `f ‚Ä¢ g` (`filter.has_smul`): Scalar multiplication, filter generated by all `x ‚Ä¢ y` where `s ‚àà f`
  and `t ‚àà g`.
* `a +·µ• f` (`filter.has_vadd_filter`): Translation, filter of all `a +·µ• x` where `s ‚àà f`.
* `a ‚Ä¢ f` (`filter.has_smul_filter`): Scaling, filter of all `a ‚Ä¢ s` where `s ‚àà f`.

## TODO

Add missing operations: subtraction/division, negation/inversion, scalar multiplication/addition

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/

section move
section logic
variables {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort*} {Œ≥ : Œ† a, Œ≤ a ‚Üí Sort*}

lemma Exists‚ÇÉ.imp {p q : Œ† a b, Œ≥ a b ‚Üí Prop} (h : ‚àÄ a b c, p a b c ‚Üí q a b c) :
  (‚àÉ a b c, p a b c) ‚Üí ‚àÉ a b c, q a b c :=
Exists.imp $ Œª a, Exists‚ÇÇ.imp $ h a

end logic

variables {F Œ± Œ≤ Œ≥ Œ¥ : Type*}

namespace set
open_locale pointwise
open function

lemma le_iff_subset {s t : set Œ±} : s ‚â§ t ‚Üî s ‚äÜ t := iff.rfl

/-- A multiplicative action of a monoid on a type Œ≤ gives also a
 multiplicative action on the subsets of Œ≤. -/
@[to_additive "An additive action of an additive monoid on a type Œ≤ gives also an additive action
on the subsets of Œ≤."]
protected def mul_action [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (set Œ±) (set Œ≤) :=
{ mul_smul := Œª _ _ _, image2_assoc mul_smul,
  one_smul := Œª s, image2_singleton_left.trans $ by simp_rw [one_smul, image_id'] }

localized "attribute [instance] set.mul_action set.add_action" in pointwise

section image2
variables {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s s‚ÇÅ s‚ÇÇ : set Œ±} {t t‚ÇÅ t‚ÇÇ : set Œ≤} {a : Œ±} {b : Œ≤}

-- lemma image2_subset_image2_iff {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hf : injective2 f) :
--   image2 f s‚ÇÅ t‚ÇÅ ‚äÜ image2 f s‚ÇÇ t‚ÇÇ ‚Üî s‚ÇÅ ‚äÜ s‚ÇÇ ‚àß t‚ÇÅ ‚äÜ t‚ÇÇ :=
-- begin
--   simp_rw ‚Üêimage_prod,
--   rw image_subset_image_iff,
--   rw prod_subset_prod_iff,
--   refine ‚ü®_, Œª h, image2_subset h.1 h.2‚ü©,
--   refine (iff.symm $ iff.intro (image2_subset f) $ assume h, _),
--   rw [‚Üê preimage_image_eq s hf, ‚Üê preimage_image_eq t hf],
--   exact preimage_mono h
-- end

lemma image_subset_image2_left (hb : b ‚àà t) : (Œª a, f a b) '' s ‚äÜ image2 f s t :=
ball_image_of_ball $ Œª a ha, mem_image2_of_mem ha hb

lemma image_subset_image2_right (ha : a ‚àà s) : f a '' t ‚äÜ image2 f s t :=
ball_image_of_ball $ Œª b, mem_image2_of_mem ha

@[simp] lemma image2_nonempty_iff : (image2 f s t).nonempty ‚Üî s.nonempty ‚àß t.nonempty :=
‚ü®Œª ‚ü®_, a, b, ha, hb, _‚ü©, ‚ü®‚ü®a, ha‚ü©, b, hb‚ü©, Œª h, h.1.image2 h.2‚ü©

@[simp] lemma image2_eq_empty_iff : image2 f s t = ‚àÖ ‚Üî s = ‚àÖ ‚à® t = ‚àÖ :=
by simp_rw [‚Üênot_nonempty_iff_eq_empty, image2_nonempty_iff, not_and_distrib]

end image2

variables {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {s s‚ÇÅ s‚ÇÇ : set Œ±} {t t‚ÇÅ t‚ÇÇ : set Œ≤} {u u‚ÇÅ u‚ÇÇ : set Œ≥} {a : Œ±} {b : Œ≤}

lemma image3_mono (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) (ht : t‚ÇÅ ‚äÜ t‚ÇÇ) (hu : u‚ÇÅ ‚äÜ u‚ÇÇ) :
  image3 f s‚ÇÅ t‚ÇÅ u‚ÇÅ ‚äÜ image3 f s‚ÇÇ t‚ÇÇ u‚ÇÇ :=
Œª x, Exists‚ÇÉ.imp $ Œª a b c ‚ü®ha, hb, hc, hx‚ü©, ‚ü®hs ha, ht hb, hu hc, hx‚ü©

end set
end move

open function set
open_locale filter pointwise

variables {F Œ± Œ≤ Œ≥ Œ¥ Œµ : Type*}

namespace filter

/-! ### `0`/`1` as filters -/

section one
variables [has_one Œ±] [has_one Œ≤] {s : set Œ±}

/-- `1 : filter Œ±` is the set of sets containing `1 : Œ±`. -/
@[to_additive "`0 : filter Œ±` is the set of sets containing `0 : Œ±`."]
instance : has_one (filter Œ±) := ‚ü®principal 1‚ü©

@[simp, to_additive] lemma mem_one : s ‚àà (1 : filter Œ±) ‚Üî (1 : Œ±) ‚àà s := one_subset

@[to_additive] lemma one_mem_one : (1 : set Œ±) ‚àà (1 : filter Œ±) := mem_principal_self _

@[simp, to_additive] lemma principal_one : ùìü 1 = (1 : filter Œ±) := rfl
@[simp, to_additive] lemma pure_one : pure 1 = (1 : filter Œ±) := (principal_singleton _).symm

@[simp, to_additive]
protected lemma map_one [one_hom_class F Œ± Œ≤] (œÜ : F) : map œÜ 1 = 1 :=
le_antisymm
  (le_principal_iff.2 $ mem_map_iff_exists_image.2 ‚ü®1, one_mem_one, Œª x, by simp [map_one œÜ]‚ü©)
  (le_map $ Œª s hs, mem_one.2 ‚ü®1, mem_one.1 hs, map_one œÜ‚ü©)

end one

section map
open function
variables {m : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {f f‚ÇÅ f‚ÇÇ : filter Œ±} {g g‚ÇÅ g‚ÇÇ : filter Œ≤} {h h‚ÇÅ h‚ÇÇ : filter Œ≥}
  {s s‚ÇÅ s‚ÇÇ : set Œ±} {t t‚ÇÅ t‚ÇÇ : set Œ≤} {u : set Œ≥} {v : set Œ¥} {a : Œ±} {b : Œ≤} {c : Œ≥}

/-- The image of a binary function `m : Œ± ‚Üí Œ≤ ‚Üí Œ≥` as a function `filter Œ± ‚Üí filter Œ≤ ‚Üí filter Œ≥`.
Mathematically this should be thought of as the image of the corresponding function `Œ± √ó Œ≤ ‚Üí Œ≥`. -/
def map‚ÇÇ (m : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (f : filter Œ±) (g : filter Œ≤) : filter Œ≥ :=
{ sets := {s | ‚àÉ u v, u ‚àà f ‚àß v ‚àà g ‚àß image2 m u v ‚äÜ s},
  univ_sets := ‚ü®univ, univ, univ_sets _, univ_sets _, subset_univ _‚ü©,
  sets_of_superset := Œª s t hs hst,
    Exists‚ÇÇ.imp (Œª u v, and.imp_right $ and.imp_right $ Œª h, subset.trans h hst) hs,
  inter_sets := Œª s t,
  begin
    simp only [exists_prop, mem_set_of_eq, subset_inter_iff],
    rintro ‚ü®s‚ÇÅ, s‚ÇÇ, hs‚ÇÅ, hs‚ÇÇ, hs‚ü© ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, ht‚ü©,
    exact ‚ü®s‚ÇÅ ‚à© t‚ÇÅ, s‚ÇÇ ‚à© t‚ÇÇ, inter_sets f hs‚ÇÅ ht‚ÇÅ, inter_sets g hs‚ÇÇ ht‚ÇÇ,
      (image2_subset (inter_subset_left _ _) $ inter_subset_left _ _).trans hs,
      (image2_subset (inter_subset_right _ _) $ inter_subset_right _ _).trans ht‚ü©,
  end }

@[simp] lemma mem_map‚ÇÇ_iff : u ‚àà map‚ÇÇ m f g ‚Üî ‚àÉ s t, s ‚àà f ‚àß t ‚àà g ‚àß image2 m s t ‚äÜ u := iff.rfl

lemma image2_mem_map‚ÇÇ (hs : s ‚àà f) (ht : t ‚àà g) : image2 m s t ‚àà map‚ÇÇ m f g :=
‚ü®_, _, hs, ht, subset.rfl‚ü©

-- lemma image2_mem_map‚ÇÇ_iff (hm : injective2 m) : image2 m s t ‚àà map‚ÇÇ m f g ‚Üî s ‚àà f ‚àß t ‚àà g :=
-- ‚ü®by { rintro ‚ü®u, v, hu, hv, h‚ü©, rw image2_subset_image2_iff hm at h,
--   exact ‚ü®mem_of_superset hu h.1, mem_of_superset hv h.2‚ü© }, Œª h, image2_mem_map‚ÇÇ h.1 h.2‚ü©

lemma map‚ÇÇ_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) : map‚ÇÇ m f‚ÇÅ g‚ÇÅ ‚â§ map‚ÇÇ m f‚ÇÇ g‚ÇÇ :=
Œª _ ‚ü®s, t, hs, ht, hst‚ü©, ‚ü®s, t, hf hs, hg ht, hst‚ü©

lemma map‚ÇÇ_mono_left (h : g‚ÇÅ ‚â§ g‚ÇÇ) : map‚ÇÇ m f g‚ÇÅ ‚â§ map‚ÇÇ m f g‚ÇÇ := map‚ÇÇ_mono subset.rfl h
lemma map‚ÇÇ_mono_right (h : f‚ÇÅ ‚â§ f‚ÇÇ) : map‚ÇÇ m f‚ÇÅ g ‚â§ map‚ÇÇ m f‚ÇÇ g := map‚ÇÇ_mono h subset.rfl

@[simp] lemma le_map‚ÇÇ_iff {h : filter Œ≥} :
  h ‚â§ map‚ÇÇ m f g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí image2 m s t ‚àà h :=
‚ü®Œª H s hs t ht, H $ image2_mem_map‚ÇÇ hs ht, Œª H u ‚ü®s, t, hs, ht, hu‚ü©, mem_of_superset (H hs ht) hu‚ü©

@[simp] lemma map‚ÇÇ_bot_left : map‚ÇÇ m ‚ä• g = ‚ä• :=
empty_mem_iff_bot.1 ‚ü®‚àÖ, univ, trivial, univ_mem, (image2_empty_left).subset‚ü©

@[simp] lemma map‚ÇÇ_bot_right : map‚ÇÇ m f ‚ä• = ‚ä• :=
empty_mem_iff_bot.1 ‚ü®univ, ‚àÖ, univ_mem, trivial, (image2_empty_right).subset‚ü©

@[simp] lemma map‚ÇÇ_eq_bot_iff : map‚ÇÇ m f g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• :=
begin
  simp only [‚Üêempty_mem_iff_bot, mem_map‚ÇÇ_iff, subset_empty_iff, image2_eq_empty_iff],
  split,
  { rintro ‚ü®s, t, hs, ht, rfl | rfl‚ü©,
    { exact or.inl hs },
    { exact or.inr ht } },
  { rintro (h | h),
    { exact ‚ü®_, _, h, univ_mem, or.inl rfl‚ü© },
    { exact ‚ü®_, _, univ_mem, h, or.inr rfl‚ü© } }
end

@[simp] lemma map‚ÇÇ_ne_bot_iff : (map‚ÇÇ m f g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot :=
by { simp_rw ne_bot_iff, exact map‚ÇÇ_eq_bot_iff.not.trans not_or_distrib }

lemma ne_bot.map‚ÇÇ (hf : f.ne_bot) (hg : g.ne_bot) : (map‚ÇÇ m f g).ne_bot :=
map‚ÇÇ_ne_bot_iff.2 ‚ü®hf, hg‚ü©

lemma map‚ÇÇ_sup_left : map‚ÇÇ m (f‚ÇÅ ‚äî f‚ÇÇ) g = map‚ÇÇ m f‚ÇÅ g ‚äî map‚ÇÇ m f‚ÇÇ g :=
begin
  ext u,
  split,
  { rintro ‚ü®s, t, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, ht, hu‚ü©,
    exact ‚ü®mem_of_superset (image2_mem_map‚ÇÇ h‚ÇÅ ht) hu,
      mem_of_superset (image2_mem_map‚ÇÇ h‚ÇÇ ht) hu‚ü© },
  { rintro ‚ü®‚ü®s‚ÇÅ, t‚ÇÅ, hs‚ÇÅ, ht‚ÇÅ, hu‚ÇÅ‚ü©, s‚ÇÇ, t‚ÇÇ, hs‚ÇÇ, ht‚ÇÇ, hu‚ÇÇ‚ü©,
    refine ‚ü®s‚ÇÅ ‚à™ s‚ÇÇ, t‚ÇÅ ‚à© t‚ÇÇ, union_mem_sup hs‚ÇÅ hs‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, _‚ü©,
    rw image2_union_left,
    exact union_subset ((image2_subset_left $ inter_subset_left _ _).trans hu‚ÇÅ)
      ((image2_subset_left $ inter_subset_right _ _).trans hu‚ÇÇ) }
end

lemma map‚ÇÇ_sup_right : map‚ÇÇ m f (g‚ÇÅ ‚äî g‚ÇÇ) = map‚ÇÇ m f g‚ÇÅ ‚äî map‚ÇÇ m f g‚ÇÇ :=
begin
  ext u,
  split,
  { rintro ‚ü®s, t, hs, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, hu‚ü©,
    exact ‚ü®mem_of_superset (image2_mem_map‚ÇÇ hs h‚ÇÅ) hu,
      mem_of_superset (image2_mem_map‚ÇÇ hs h‚ÇÇ) hu‚ü© },
  { rintro ‚ü®‚ü®s‚ÇÅ, t‚ÇÅ, hs‚ÇÅ, ht‚ÇÅ, hu‚ÇÅ‚ü©, s‚ÇÇ, t‚ÇÇ, hs‚ÇÇ, ht‚ÇÇ, hu‚ÇÇ‚ü©,
    refine ‚ü®s‚ÇÅ ‚à© s‚ÇÇ, t‚ÇÅ ‚à™ t‚ÇÇ, inter_mem hs‚ÇÅ hs‚ÇÇ, union_mem_sup ht‚ÇÅ ht‚ÇÇ, _‚ü©,
    rw image2_union_right,
    exact union_subset ((image2_subset_right $ inter_subset_left _ _).trans hu‚ÇÅ)
      ((image2_subset_right $ inter_subset_right _ _).trans hu‚ÇÇ) }
end

lemma map‚ÇÇ_inf_subset_left : map‚ÇÇ m (f‚ÇÅ ‚äì f‚ÇÇ) g ‚â§ map‚ÇÇ m f‚ÇÅ g ‚äì map‚ÇÇ m f‚ÇÇ g :=
le_inf (map‚ÇÇ_mono_right inf_le_left) (map‚ÇÇ_mono_right inf_le_right)

lemma map‚ÇÇ_inf_subset_right : map‚ÇÇ m f (g‚ÇÅ ‚äì g‚ÇÇ) ‚â§ map‚ÇÇ m f g‚ÇÅ ‚äì map‚ÇÇ m f g‚ÇÇ :=
le_inf (map‚ÇÇ_mono_left inf_le_left) (map‚ÇÇ_mono_left inf_le_right)

@[simp] lemma map‚ÇÇ_pure_left : map‚ÇÇ m (pure a) g = g.map (Œª b, m a b) :=
filter.ext $ Œª u, ‚ü®Œª ‚ü®s, t, hs, ht, hu‚ü©,
  mem_of_superset (image_mem_map ht) ((image_subset_image2_right $ mem_pure.1 hs).trans hu),
    Œª h, ‚ü®{a}, _, singleton_mem_pure, h, by rw [image2_singleton_left, image_subset_iff]‚ü©‚ü©

@[simp] lemma map‚ÇÇ_pure_right : map‚ÇÇ m f (pure b) = f.map (Œª a, m a b) :=
filter.ext $ Œª u, ‚ü®Œª ‚ü®s, t, hs, ht, hu‚ü©,
  mem_of_superset (image_mem_map hs) ((image_subset_image2_left $ mem_pure.1 ht).trans hu),
    Œª h, ‚ü®_, {b}, h, singleton_mem_pure, by rw [image2_singleton_right, image_subset_iff]‚ü©‚ü©

lemma map‚ÇÇ_pure : map‚ÇÇ m (pure a) (pure b) = pure (m a b) := by rw [map‚ÇÇ_pure_right, map_pure]

lemma map‚ÇÇ_swap (m : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (f : filter Œ±) (g : filter Œ≤) :
  map‚ÇÇ m f g = map‚ÇÇ (Œª a b, m b a) g f :=
by { ext u, split; rintro ‚ü®s, t, hs, ht, hu‚ü©; refine ‚ü®t, s, ht, hs, by rwa image2_swap‚ü© }

@[simp] lemma map‚ÇÇ_left (h : g.ne_bot) : map‚ÇÇ (Œª x y, x) f g = f :=
begin
  ext u,
  refine ‚ü®_, Œª hu, ‚ü®_, _, hu, univ_mem, (image2_left $ h.nonempty_of_mem univ_mem).subset‚ü©‚ü©,
  rintro ‚ü®s, t, hs, ht, hu‚ü©,
  rw image2_left (h.nonempty_of_mem ht) at hu,
  exact mem_of_superset hs hu,
end

@[simp] lemma map‚ÇÇ_right (h : f.ne_bot) : map‚ÇÇ (Œª x y, y) f g = g := by rw [map‚ÇÇ_swap, map‚ÇÇ_left h]

/-- The image of a ternary function `m : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥` as a function
`filter Œ± ‚Üí filter Œ≤ ‚Üí filter Œ≥ ‚Üí filter Œ¥`. Mathematically this should be thought of as the image
of the corresponding function `Œ± √ó Œ≤ √ó Œ≥ ‚Üí Œ¥`. -/
def map‚ÇÉ (m : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (f : filter Œ±) (g : filter Œ≤) (h : filter Œ≥) : filter Œ¥ :=
{ sets := {s | ‚àÉ u v w, u ‚àà f ‚àß v ‚àà g ‚àß w ‚àà h ‚àß image3 m u v w ‚äÜ s},
  univ_sets := ‚ü®univ, univ, univ, univ_sets _, univ_sets _, univ_sets _, subset_univ _‚ü©,
  sets_of_superset := Œª s t hs hst, Exists‚ÇÉ.imp
    (Œª u v w, and.imp_right $ and.imp_right $ and.imp_right $ Œª h, subset.trans h hst) hs,
  inter_sets := Œª s t,
  begin
    simp only [exists_prop, mem_set_of_eq, subset_inter_iff],
    rintro ‚ü®s‚ÇÅ, s‚ÇÇ, s‚ÇÉ, hs‚ÇÅ, hs‚ÇÇ, hs‚ÇÉ, hs‚ü© ‚ü®t‚ÇÅ, t‚ÇÇ, t‚ÇÉ, ht‚ÇÅ, ht‚ÇÇ, ht‚ÇÉ, ht‚ü©,
    exact ‚ü®s‚ÇÅ ‚à© t‚ÇÅ, s‚ÇÇ ‚à© t‚ÇÇ, s‚ÇÉ ‚à© t‚ÇÉ, inter_mem hs‚ÇÅ ht‚ÇÅ, inter_mem hs‚ÇÇ ht‚ÇÇ, inter_mem hs‚ÇÉ ht‚ÇÉ,
      (image3_mono (inter_subset_left _ _) (inter_subset_left _ _) $ inter_subset_left _ _).trans
        hs,
      (image3_mono (inter_subset_right _ _) (inter_subset_right _ _) $ inter_subset_right _ _).trans
        ht‚ü©,
  end }

-- @[simp] lemma mem_map‚ÇÉ : d ‚àà map‚ÇÉ g f g h ‚Üî ‚àÉ a b c, a ‚àà f ‚àß b ‚àà g ‚àß c ‚àà h ‚àß g a b c = d :=
-- iff.rfl

-- @[congr] lemma map‚ÇÉ_congr (h : ‚àÄ (a ‚àà f) (b ‚àà g) (c ‚àà h), g a b c = g' a b c) :
--   map‚ÇÉ g f g h = map‚ÇÉ g' f g h :=
-- by { ext x, split;
--   rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©; exact ‚ü®a, b, c, ha, hb, hc, by rw h a ha b hb c hc‚ü© }

-- /-- A common special case of `map‚ÇÉ_congr` -/
-- lemma map‚ÇÉ_congr' (h : ‚àÄ a b c, g a b c = g' a b c) : map‚ÇÉ g f g h = map‚ÇÉ g' f g h :=
-- map‚ÇÉ_congr (Œª a _ b _ c _, h a b c)

lemma map‚ÇÇ_map‚ÇÇ_left (m : Œ¥ ‚Üí Œ≥ ‚Üí Œµ) (n : Œ± ‚Üí Œ≤ ‚Üí Œ¥) :
  map‚ÇÇ m (map‚ÇÇ n f g) h = map‚ÇÉ (Œª a b c, m (n a b) c) f g h :=
begin
  ext w,
  split,
  { rintro ‚ü®s, t, ‚ü®u, v, hu, hv, hs‚ü©, ht, hw‚ü©,
    refine ‚ü®u, v, t, hu, hv, ht, _‚ü©,
    rw ‚Üêimage2_image2_left,
    exact (image2_subset_right hs).trans hw },
  { rintro ‚ü®s, t, u, hs, ht, hu, hw‚ü©,
    exact ‚ü®_, u, image2_mem_map‚ÇÇ hs ht, hu, by rwa image2_image2_left‚ü© }
end

lemma map‚ÇÇ_map‚ÇÇ_right (m : Œ± ‚Üí Œ¥ ‚Üí Œµ) (n : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) :
  map‚ÇÇ m f (map‚ÇÇ n g h) = map‚ÇÉ (Œª a b c, m a (n b c)) f g h :=
begin
  ext w,
  split,
  { rintro ‚ü®s, t, hs, ‚ü®u, v, hu, hv, ht‚ü©, hw‚ü©,
    refine ‚ü®s, u, v, hs, hu, hv, _‚ü©,
    rw ‚Üêimage2_image2_right,
    exact (image2_subset_left ht).trans hw },
  { rintro ‚ü®s, t, u, hs, ht, hu, hw‚ü©,
    exact ‚ü®s, _, hs, image2_mem_map‚ÇÇ ht hu, by rwa image2_image2_right‚ü© }
end

lemma map‚ÇÇ_assoc {Œµ'} {m : Œ¥ ‚Üí Œ≥ ‚Üí Œµ} {n : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {m' : Œ± ‚Üí Œµ' ‚Üí Œµ} {n' : Œ≤ ‚Üí Œ≥ ‚Üí Œµ'}
  {h : filter Œ≥} (h_assoc : ‚àÄ a b c, m (n a b) c = m' a (n' b c)) :
  map‚ÇÇ m (map‚ÇÇ n f g) h = map‚ÇÇ m' f (map‚ÇÇ n' g h) :=
by simp only [map‚ÇÇ_map‚ÇÇ_left, map‚ÇÇ_map‚ÇÇ_right, h_assoc]

lemma map‚ÇÇ_comm {n : Œ≤ ‚Üí Œ± ‚Üí Œ≥} (h_comm : ‚àÄ a b, m a b = n b a) : map‚ÇÇ m f g = map‚ÇÇ n g f :=
(map‚ÇÇ_swap _ _ _).trans $ by simp_rw h_comm

lemma map‚ÇÇ_left_comm {Œ¥'} {m : Œ± ‚Üí Œ¥ ‚Üí Œµ} {n : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {m' : Œ± ‚Üí Œ≥ ‚Üí Œ¥'} {n' : Œ≤ ‚Üí Œ¥' ‚Üí Œµ}
  (h_left_comm : ‚àÄ a b c, m a (n b c) = n' b (m' a c)) :
  map‚ÇÇ m f (map‚ÇÇ n g h) = map‚ÇÇ n' g (map‚ÇÇ m' f h) :=
by { rw [map‚ÇÇ_swap m', map‚ÇÇ_swap m], exact map‚ÇÇ_assoc (Œª _ _ _, h_left_comm _ _ _) }

lemma map‚ÇÇ_right_comm {Œ¥'} {m : Œ¥ ‚Üí Œ≥ ‚Üí Œµ} {n : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {m' : Œ± ‚Üí Œ≥ ‚Üí Œ¥'} {n' : Œ¥' ‚Üí Œ≤ ‚Üí Œµ}
  (h_right_comm : ‚àÄ a b c, m (n a b) c = n' (m' a c) b) :
  map‚ÇÇ m (map‚ÇÇ n f g) h = map‚ÇÇ n' (map‚ÇÇ m' f h) g :=
by { rw [map‚ÇÇ_swap n, map‚ÇÇ_swap n'], exact map‚ÇÇ_assoc (Œª _ _ _, h_right_comm _ _ _) }

lemma map_map‚ÇÇ (m : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (n : Œ≥ ‚Üí Œ¥) : (map‚ÇÇ m f g).map n = map‚ÇÇ (Œª a b, n (m a b)) f g :=
filter.ext $ Œª u, exists‚ÇÇ_congr $ Œª s t, by rw [‚Üêimage_subset_iff, image_image2]

lemma map‚ÇÇ_map_left (m : Œ≥ ‚Üí Œ≤ ‚Üí Œ¥) (n : Œ± ‚Üí Œ≥) :
  map‚ÇÇ m (f.map n) g = map‚ÇÇ (Œª a b, m (n a) b) f g :=
begin
  ext u,
  split,
  { rintro ‚ü®s, t, hs, ht, hu‚ü©,
    refine ‚ü®_, t, hs, ht, _‚ü©,
    rw ‚Üêimage2_image_left,
    exact (image2_subset_right $ image_preimage_subset _ _).trans hu, },
  { rintro ‚ü®s, t, hs, ht, hu‚ü©,
    exact ‚ü®_, t, image_mem_map hs, ht, by rwa image2_image_left‚ü© }
end

lemma map‚ÇÇ_map_right (m : Œ± ‚Üí Œ≥ ‚Üí Œ¥) (n : Œ≤ ‚Üí Œ≥) :
  map‚ÇÇ m f (g.map n) = map‚ÇÇ (Œª a b, m a (n b)) f g :=
by rw [map‚ÇÇ_swap, map‚ÇÇ_map_left, map‚ÇÇ_swap]

lemma map_map‚ÇÇ_distrib {Œ±' Œ≤'} {n : Œ≥ ‚Üí Œ¥} {m' : Œ±' ‚Üí Œ≤' ‚Üí Œ¥} {n‚ÇÅ : Œ± ‚Üí Œ±'} {n‚ÇÇ : Œ≤ ‚Üí Œ≤'}
  (h_distrib : ‚àÄ a b, n (m a b) = m' (n‚ÇÅ a) (n‚ÇÇ b)) :
  (map‚ÇÇ m f g).map n = map‚ÇÇ m' (f.map n‚ÇÅ) (g.map n‚ÇÇ) :=
by simp_rw [map_map‚ÇÇ, map‚ÇÇ_map_left, map‚ÇÇ_map_right, h_distrib]

lemma map_map‚ÇÇ_distrib_left {Œ±'} {n : Œ≥ ‚Üí Œ¥} {m' : Œ±' ‚Üí Œ≤ ‚Üí Œ¥} {n' : Œ± ‚Üí Œ±'}
  (h_distrib : ‚àÄ a b, n (m a b) = m' (n' a) b) :
  (map‚ÇÇ m f g).map n = map‚ÇÇ m' (f.map n') g :=
map_map‚ÇÇ_distrib h_distrib

lemma map_map‚ÇÇ_distrib_right {Œ≤'} {n : Œ≥ ‚Üí Œ¥} {m' : Œ± ‚Üí Œ≤' ‚Üí Œ¥} {n' : Œ≤ ‚Üí Œ≤'}
  (h_distrib : ‚àÄ a b, n (m a b) = m' a (n' b)) :
  (map‚ÇÇ m f g).map n = map‚ÇÇ m' f (g.map n') :=
map_map‚ÇÇ_distrib h_distrib

end map

/-! ### Filter addition/multiplication -/

section mul
variables [has_mul Œ±] [has_mul Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±}

@[to_additive] instance : has_mul (filter Œ±) := ‚ü®map‚ÇÇ (*)‚ü©

@[simp, to_additive] lemma map‚ÇÇ_mul : map‚ÇÇ (*) f g = f * g := rfl
@[to_additive] lemma mem_mul_iff : s ‚àà f * g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma mul_mem_mul : s ‚àà f ‚Üí t ‚àà g ‚Üí s * t ‚àà f * g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_mul : ‚ä• * g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma mul_bot : f * ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma mul_eq_bot_iff : f * g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma mul_ne_bot_iff : (f * g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.mul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f * g) := ne_bot.map‚ÇÇ
@[simp, to_additive] lemma le_mul_iff : h ‚â§ f * g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s * t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_mul : covariant_class (filter Œ±) (filter Œ±) (*) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] instance covariant_swap_mul : covariant_class (filter Œ±) (filter Œ±) (swap (*)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©

@[to_additive]
protected lemma map_mul [mul_hom_class F Œ± Œ≤] (m : F) : (f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m :=
map_map‚ÇÇ_distrib $ map_mul m

end mul

@[to_additive]
instance [semigroup Œ±] : semigroup (filter Œ±) :=
{ mul := (*),
  mul_assoc := Œª f g h, map‚ÇÇ_assoc mul_assoc }

@[to_additive]
instance [comm_semigroup Œ±] : comm_semigroup (filter Œ±) :=
{ mul_comm := Œª f g, map‚ÇÇ_comm mul_comm,
  ..filter.semigroup }

@[to_additive]
instance [mul_one_class Œ±] : mul_one_class (filter Œ±) :=
{ one := 1,
  mul := (*),
  one_mul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_left, one_mul, map_id'],
  mul_one := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_right, mul_one, map_id'] }

@[to_additive]
instance [monoid Œ±] : monoid (filter Œ±) := { ..filter.mul_one_class, ..filter.semigroup }

@[to_additive]
instance [comm_monoid Œ±] : comm_monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.comm_semigroup }

section map

variables [mul_one_class Œ±] [mul_one_class Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ±}

/-- If `œÜ : Œ± ‚Üí* Œ≤` then `map_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí* filter Œ≤` induced by `map œÜ`. -/
@[to_additive "If `œÜ : Œ± ‚Üí+ Œ≤` then `map_add_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí+ filter Œ≤` induced by `map œÜ`."]
def map_monoid_hom [monoid_hom_class F Œ± Œ≤] (œÜ : F) : filter Œ± ‚Üí* filter Œ≤ :=
{ to_fun := map œÜ,
  map_one' := filter.map_one œÜ,
  map_mul' := Œª _ _, filter.map_mul œÜ }

-- The other direction does not hold in general.
@[to_additive]
lemma comap_mul_comap_le [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ f‚ÇÇ : filter Œ≤} :
  f‚ÇÅ.comap m * f‚ÇÇ.comap m ‚â§ (f‚ÇÅ * f‚ÇÇ).comap m  :=
Œª s ‚ü®t, ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü©,
  ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÅ, ht‚ÇÅ, subset.rfl‚ü©, ‚ü®t‚ÇÇ, ht‚ÇÇ, subset.rfl‚ü©,
    (preimage_mul_preimage_subset _).trans $ (preimage_mono t‚ÇÅt‚ÇÇ).trans mt‚ü©

@[to_additive]
lemma tendsto.mul_mul [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : filter Œ±} {f‚ÇÇ g‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ * g‚ÇÅ) (f‚ÇÇ * g‚ÇÇ) :=
Œª hf hg, (filter.map_mul m).trans_le $ mul_le_mul' hf hg

end map

/-! ### Filter negation/inversion -/

section has_inv
variables [has_inv Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : filter Œ±} {s t : set Œ±}

@[simp, to_additive] lemma preimage_inv (s : set Œ±) : has_inv.inv ‚Åª¬π' s = s‚Åª¬π := rfl

/-- The inverse of a filter is the pointwise preimage under `‚Åª¬π` of its sets. -/
@[to_additive "The negation of a filter is the pointwise preimage under `-` of its sets."]
instance : has_inv (filter Œ±) := ‚ü®map has_inv.inv‚ü©

@[simp, to_additive] protected lemma map_inv : f.map has_inv.inv = f‚Åª¬π := rfl
@[to_additive] lemma mem_inv : s ‚àà f‚Åª¬π ‚Üî has_inv.inv ‚Åª¬π' s ‚àà f := iff.rfl
@[to_additive] protected lemma inv_le_inv (hf : f ‚â§ g) : f‚Åª¬π ‚â§ g‚Åª¬π := map_mono hf
@[simp, to_additive] lemma ne_bot_inv_iff : f‚Åª¬π.ne_bot ‚Üî ne_bot f := map_ne_bot_iff _
@[to_additive] lemma ne_bot.inv : f.ne_bot ‚Üí f‚Åª¬π.ne_bot := Œª h, h.map _

end has_inv

section has_involutive_inv
variables [has_involutive_inv Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : filter Œ±} {s t : set Œ±}

@[to_additive] lemma inv_mem_inv (hs : s ‚àà f) : s‚Åª¬π ‚àà f‚Åª¬π := by rwa [mem_inv, preimage_inv, inv_inv]

instance : has_involutive_inv (filter Œ±) :=
{ inv_inv := Œª f, map_map.trans $ by rw [inv_involutive.comp_self, map_id],
  ..filter.has_inv }

end has_involutive_inv

section group
variables [group Œ±] [group Œ≤]

@[to_additive]
lemma map_inv' [monoid_hom_class F Œ± Œ≤] (m : F) {f : filter Œ±} : f‚Åª¬π.map m = (f.map m)‚Åª¬π :=
map_comm (funext $ map_inv m) _

@[to_additive]
lemma tendsto.inv_inv [monoid_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ  : filter Œ±} {f‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m f‚ÇÅ‚Åª¬π f‚ÇÇ‚Åª¬π :=
Œª hf, (filter.map_inv' m).trans_le $ filter.inv_le_inv hf

end group

/-! ### Filter subtraction/division -/

section div
variables [has_div Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±}

@[to_additive] instance : has_div (filter Œ±) := ‚ü®map‚ÇÇ (/)‚ü©

@[simp, to_additive] lemma map‚ÇÇ_div : map‚ÇÇ (/) f g = f / g := rfl
@[to_additive] lemma mem_div : s ‚àà f / g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma div_mem_div : s ‚àà f ‚Üí t ‚àà g ‚Üí s / t ‚àà f / g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_div : ‚ä• / g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma div_bot : f / ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma div_eq_bot_iff : f / g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma div_ne_bot_iff : (f / g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.div : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f / g) := ne_bot.map‚ÇÇ
@[simp,to_additive] lemma le_div_iff : h ‚â§ f / g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s / t ‚àà h :=
le_map‚ÇÇ_iff
@[to_additive] protected lemma div_le_div : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ / g‚ÇÅ ‚â§ f‚ÇÇ / g‚ÇÇ := map‚ÇÇ_mono

@[to_additive] instance covariant_div : covariant_class (filter Œ±) (filter Œ±) (/) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] instance covariant_swap_div : covariant_class (filter Œ±) (filter Œ±) (swap (/)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©

end div

section group
variables [group Œ±] [group Œ≤] {f g  : filter Œ±} {f‚ÇÇ : filter Œ≤}

@[to_additive]
protected lemma map_div [monoid_hom_class F Œ± Œ≤] (m : F) : (f / g).map m = f.map m / g.map m :=
map_map‚ÇÇ_distrib $ map_div m

@[to_additive]
lemma tendsto.div_div [monoid_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : filter Œ±} {f‚ÇÇ g‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ / g‚ÇÅ) (f‚ÇÇ / g‚ÇÇ) :=
Œª hf hg, (filter.map_div m).trans_le $ filter.div_le_div hf hg

end group

/-TODO: The below instances are duplicate because there is no typeclass greater than
`div_inv_monoid` and `has_involutive_inv` but smaller than `group` and `group_with_zero`. -/

/-- `f / g = f * g‚Åª¬π` for all `f g : filter Œ±` if `a / b = a * b‚Åª¬π` for all `a b : Œ±`. -/
@[to_additive "`f - g = f + -g` for all `f g : filter Œ±` if `a - b = a + -b` for all `a b : Œ±`."]
instance div_inv_monoid [group Œ±] : div_inv_monoid (filter Œ±) :=
{ div_eq_mul_inv := Œª f g, map_map‚ÇÇ_distrib_right div_eq_mul_inv,
  ..filter.monoid, ..filter.has_inv, ..filter.has_div }

/-- `f / g = f * g‚Åª¬π` for all `f g : filter Œ±` if `a / b = a * b‚Åª¬π` for all `a b : Œ±`. -/
instance div_inv_monoid' [group_with_zero Œ±] : div_inv_monoid (filter Œ±) :=
{ div_eq_mul_inv := Œª f g, map_map‚ÇÇ_distrib_right div_eq_mul_inv,
  ..filter.monoid, ..filter.has_inv, ..filter.has_div }

/-! ### Scalar addition/multiplication of filters -/

section smul
variables [has_scalar Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ±} {g g‚ÇÅ g‚ÇÇ h : filter Œ≤} {s : set Œ±} {t : set Œ≤}

@[to_additive filter.has_vadd] instance : has_scalar (filter Œ±) (filter Œ≤) := ‚ü®map‚ÇÇ (‚Ä¢)‚ü©

@[simp, to_additive] lemma map‚ÇÇ_smul : map‚ÇÇ (‚Ä¢) f g = f ‚Ä¢ g := rfl
@[to_additive] lemma mem_smul : t ‚àà f ‚Ä¢ g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t := iff.rfl
@[to_additive] lemma smul_mem_smul : s ‚àà f ‚Üí t ‚àà g ‚Üí s ‚Ä¢ t ‚àà f ‚Ä¢ g :=  image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_smul : (‚ä• : filter Œ±) ‚Ä¢ g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma smul_bot : f ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma smul_eq_bot_iff : f ‚Ä¢ g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma smul_ne_bot_iff : (f ‚Ä¢ g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.smul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f ‚Ä¢ g) := ne_bot.map‚ÇÇ
@[simp, to_additive] lemma le_smul_iff : h ‚â§ f ‚Ä¢ g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s ‚Ä¢ t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_smul : covariant_class (filter Œ±) (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] protected lemma smul_le_smul : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g‚ÇÅ ‚â§ f‚ÇÇ ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono

end smul

@[to_additive]
instance [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (filter Œ±) (filter Œ≤) :=
{ one_smul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_smul, map‚ÇÇ_pure_left, one_smul, map_id'],
  mul_smul := Œª f g h, map‚ÇÇ_assoc mul_smul }

/-! ### Scalar subtraction of filters -/

section vsub
variables [has_vsub Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : filter Œ≤} {h : filter Œ±} {s t : set Œ≤}
include Œ±

instance : has_vsub (filter Œ±) (filter Œ≤) := ‚ü®map‚ÇÇ (-·µ•)‚ü©

@[simp] lemma map‚ÇÇ_vsub : map‚ÇÇ (-·µ•) f g = f -·µ• g := rfl
lemma mem_vsub {s : set Œ±} : s ‚àà f -·µ• g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s := iff.rfl
lemma vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=  image2_mem_map‚ÇÇ
@[simp] lemma bot_vsub : (‚ä• : filter Œ≤) -·µ• g = ‚ä• := map‚ÇÇ_bot_left
@[simp] lemma vsub_bot : f -·µ• (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp] lemma vsub_eq_bot_iff : f -·µ• g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp] lemma vsub_ne_bot_iff : (f -·µ• g : filter Œ±).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
lemma ne_bot.vsub : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f -·µ• g) := ne_bot.map‚ÇÇ
@[simp] lemma le_vsub_iff : h ‚â§ f -·µ• g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s -·µ• t ‚àà h := le_map‚ÇÇ_iff

protected lemma vsub_le_vsub : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ -·µ• g‚ÇÅ ‚â§ f‚ÇÇ -·µ• g‚ÇÇ := map‚ÇÇ_mono

end vsub

/-! ### Translation/scaling of filters -/

section smul
variables [has_scalar Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : filter Œ≤} {s : set Œ≤} {a : Œ±}

@[to_additive filter.has_vadd_filter]
instance has_scalar_filter : has_scalar Œ± (filter Œ≤) := ‚ü®Œª a, map ((‚Ä¢) a)‚ü©

@[simp, to_additive] lemma map_smul : map (Œª b, a ‚Ä¢ b) f = a ‚Ä¢ f := rfl
@[to_additive] lemma mem_smul_filter : s ‚àà a ‚Ä¢ f ‚Üî (‚Ä¢) a ‚Åª¬π' s ‚àà f := iff.rfl

@[to_additive] lemma smul_set_mem_smul_filter : s ‚àà f ‚Üí a ‚Ä¢ s ‚àà a ‚Ä¢ f := image_mem_map
@[simp, to_additive] lemma smul_filter_bot : a ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map_bot
@[simp, to_additive] lemma smul_filter_eq_bot_iff : a ‚Ä¢ f = ‚ä• ‚Üî f = ‚ä• := map_eq_bot_iff
@[simp, to_additive] lemma smul_filter_ne_bot_iff : (a ‚Ä¢ f).ne_bot ‚Üî f.ne_bot := map_ne_bot_iff _
@[to_additive] lemma ne_bot.smul_filter : f.ne_bot ‚Üí (a ‚Ä¢ f).ne_bot := Œª h, h.map _

@[to_additive]
protected lemma smul_filter_le_smul_filter (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : a ‚Ä¢ f‚ÇÅ ‚â§ a ‚Ä¢ f‚ÇÇ := map_mono hf

@[to_additive] instance covariant_smul_filter : covariant_class Œ± (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f, map_mono‚ü©

end smul

@[to_additive]
instance smul_comm_class_filter [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, map_map‚ÇÇ_distrib_right $ smul_comm a‚ü©

@[to_additive]
instance smul_comm_class_filter' [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) Œ≤ (filter Œ≥) :=
by haveI := smul_comm_class.symm Œ± Œ≤ Œ≥; exact smul_comm_class.symm _ _ _

@[to_additive]
instance smul_comm_class [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_left_comm smul_comm‚ü©

instance is_scalar_tower [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± Œ≤ (filter Œ≥) :=
‚ü®Œª a b f, by simp only [‚Üêmap_smul, map_map, smul_assoc]‚ü©

instance is_scalar_tower' [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, by { refine (map_map‚ÇÇ_distrib_left $ Œª _ _, _).symm, exact (smul_assoc a _ _).symm }‚ü©

instance is_scalar_tower'' [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_assoc smul_assoc‚ü©

instance is_central_scalar [has_scalar Œ± Œ≤] [has_scalar Œ±·µê·µí·µñ Œ≤] [is_central_scalar Œ± Œ≤] :
  is_central_scalar Œ± (filter Œ≤) :=
‚ü®Œª a f, congr_arg (Œª m, map m f) $ by exact funext (Œª _, op_smul_eq_smul _ _)‚ü©

end filter
