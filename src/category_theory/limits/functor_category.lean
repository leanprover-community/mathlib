/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import category_theory.limits.preserves.basic

open category_theory category_theory.category

namespace category_theory.limits

universes v v‚ÇÇ u -- declare the `v`'s first; see `category_theory.category` for an explanation

variables {C : Type u} [category.{v} C]

variables {J K : Type v} [small_category J] [category.{v‚ÇÇ} K]

/--
The evaluation functors jointly reflect limits: that is, to show a cone is a limit of `F`
it suffices to show that each evaluation cone is a limit. In other words, to prove a cone is
limiting you can show it's pointwise limiting.
-/
def evaluation_jointly_reflects_limits {F : J ‚•§ K ‚•§ C} (c : cone F)
  (t : Œ† (k : K), is_limit (((evaluation K C).obj k).map_cone c)) : is_limit c :=
{ lift := Œª s,
  { app := Œª k, (t k).lift ‚ü®s.X.obj k, whisker_right s.œÄ ((evaluation K C).obj k)‚ü©,
    naturality' := Œª X Y f, (t Y).hom_ext $ Œª j,
    begin
      rw [assoc, (t Y).fac _ j],
      simpa using ((t X).fac_assoc ‚ü®s.X.obj X, whisker_right s.œÄ ((evaluation K C).obj X)‚ü© j _).symm,
    end },
  fac' := Œª s j, nat_trans.ext _ _ $ funext $ Œª k, (t k).fac _ j,
  uniq' := Œª s m w, nat_trans.ext _ _ $ funext $ Œª x, (t x).hom_ext $ Œª j,
      (congr_app (w j) x).trans
        ((t x).fac ‚ü®s.X.obj _, whisker_right s.œÄ ((evaluation K C).obj _)‚ü© j).symm }

/--
Given a functor `F` and a collection of limit cones for each diagram `X ‚Ü¶ F X k`, we can stitch
them together to give a cone for the diagram `F`.
`combined_is_limit` shows that the new cone is limiting, and `eval_combined` shows it is
(essentially) made up of the original cones.
-/
@[simps] def combine_cones (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), limit_cone (F.flip.obj k)) :
  cone F :=
{ X :=
  { obj := Œª k, (c k).cone.X,
    map := Œª k‚ÇÅ k‚ÇÇ f, (c k‚ÇÇ).is_limit.lift ‚ü®_, (c k‚ÇÅ).cone.œÄ ‚â´ F.flip.map f‚ü©,
    map_id' := Œª k, (c k).is_limit.hom_ext (Œª j, by { dsimp, simp }),
    map_comp' := Œª k‚ÇÅ k‚ÇÇ k‚ÇÉ f‚ÇÅ f‚ÇÇ, (c k‚ÇÉ).is_limit.hom_ext (Œª j, by simp) },
  œÄ :=
  { app := Œª j, { app := Œª k, (c k).cone.œÄ.app j },
    naturality' := Œª j‚ÇÅ j‚ÇÇ g, nat_trans.ext _ _ $ funext $ Œª k, (c k).cone.œÄ.naturality g } }

/-- The stitched together cones each project down to the original given cones (up to iso). -/
def evaluate_combined_cones (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), limit_cone (F.flip.obj k)) (k : K) :
  ((evaluation K C).obj k).map_cone (combine_cones F c) ‚âÖ (c k).cone :=
cones.ext (iso.refl _) (by tidy)

/-- Stitching together limiting cones gives a limiting cone. -/
def combined_is_limit (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), limit_cone (F.flip.obj k)) :
  is_limit (combine_cones F c) :=
evaluation_jointly_reflects_limits _
  (Œª k, (c k).is_limit.of_iso_limit (evaluate_combined_cones F c k).symm)

/--
The evaluation functors jointly reflect colimits: that is, to show a cocone is a colimit of `F`
it suffices to show that each evaluation cocone is a colimit. In other words, to prove a cocone is
colimiting you can show it's pointwise colimiting.
-/
def evaluation_jointly_reflects_colimits {F : J ‚•§ K ‚•§ C} (c : cocone F)
  (t : Œ† (k : K), is_colimit (((evaluation K C).obj k).map_cocone c)) : is_colimit c :=
{ desc := Œª s,
  { app := Œª k, (t k).desc ‚ü®s.X.obj k, whisker_right s.Œπ ((evaluation K C).obj k)‚ü©,
    naturality' := Œª X Y f, (t X).hom_ext $ Œª j,
    begin
      rw [(t X).fac_assoc _ j],
      erw ‚Üê (c.Œπ.app j).naturality_assoc f,
      erw (t Y).fac ‚ü®s.X.obj _, whisker_right s.Œπ _‚ü© j,
      dsimp,
      simp,
    end },
  fac' := Œª s j, nat_trans.ext _ _ $ funext $ Œª k, (t k).fac _ j,
  uniq' := Œª s m w, nat_trans.ext _ _ $ funext $ Œª x, (t x).hom_ext $ Œª j,
      (congr_app (w j) x).trans
        ((t x).fac ‚ü®s.X.obj _, whisker_right s.Œπ ((evaluation K C).obj _)‚ü© j).symm }

/--
Given a functor `F` and a collection of colimit cocones for each diagram `X ‚Ü¶ F X k`, we can stitch
them together to give a cocone for the diagram `F`.
`combined_is_colimit` shows that the new cocone is colimiting, and `eval_combined` shows it is
(essentially) made up of the original cocones.
-/
@[simps] def combine_cocones (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), colimit_cocone (F.flip.obj k)) :
  cocone F :=
{ X :=
  { obj := Œª k, (c k).cocone.X,
    map := Œª k‚ÇÅ k‚ÇÇ f, (c k‚ÇÅ).is_colimit.desc ‚ü®_, F.flip.map f ‚â´ (c k‚ÇÇ).cocone.Œπ‚ü©,
    map_id' := Œª k, (c k).is_colimit.hom_ext (Œª j, by { dsimp, simp }),
    map_comp' := Œª k‚ÇÅ k‚ÇÇ k‚ÇÉ f‚ÇÅ f‚ÇÇ, (c k‚ÇÅ).is_colimit.hom_ext (Œª j, by simp) },
  Œπ :=
  { app := Œª j, { app := Œª k, (c k).cocone.Œπ.app j },
    naturality' := Œª j‚ÇÅ j‚ÇÇ g, nat_trans.ext _ _ $ funext $ Œª k, (c k).cocone.Œπ.naturality g } }

/-- The stitched together cocones each project down to the original given cocones (up to iso). -/
def evaluate_combined_cocones (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), colimit_cocone (F.flip.obj k)) (k : K) :
  ((evaluation K C).obj k).map_cocone (combine_cocones F c) ‚âÖ (c k).cocone :=
cocones.ext (iso.refl _) (by tidy)

/-- Stitching together colimiting cocones gives a colimiting cocone. -/
def combined_is_colimit (F : J ‚•§ K ‚•§ C) (c : Œ† (k : K), colimit_cocone (F.flip.obj k)) :
  is_colimit (combine_cocones F c) :=
evaluation_jointly_reflects_colimits _
  (Œª k, (c k).is_colimit.of_iso_colimit (evaluate_combined_cocones F c k).symm)

noncomputable theory

instance functor_category_has_limits_of_shape
  [has_limits_of_shape J C] : has_limits_of_shape J (K ‚•§ C) :=
{ has_limit := Œª F, has_limit.mk
  { cone := combine_cones F (Œª k, get_limit_cone _),
    is_limit := combined_is_limit _ _ } }

instance functor_category_has_colimits_of_shape
  [has_colimits_of_shape J C] : has_colimits_of_shape J (K ‚•§ C) :=
{ has_colimit := Œª F, has_colimit.mk
  { cocone := combine_cocones _ (Œª k, get_colimit_cocone _),
    is_colimit := combined_is_colimit _ _ } }

instance functor_category_has_limits [has_limits C] : has_limits (K ‚•§ C) :=
{ has_limits_of_shape := Œª J ùí•, by resetI; apply_instance }

instance functor_category_has_colimits [has_colimits C] : has_colimits (K ‚•§ C) :=
{ has_colimits_of_shape := Œª J ùí•, by resetI; apply_instance }

instance evaluation_preserves_limits_of_shape [has_limits_of_shape J C] (k : K) :
  preserves_limits_of_shape J ((evaluation K C).obj k) :=
{ preserves_limit :=
  Œª F, preserves_limit_of_preserves_limit_cone (combined_is_limit _ _) $
    is_limit.of_iso_limit (limit.is_limit _)
      (evaluate_combined_cones F _ k).symm }

instance evaluation_preserves_colimits_of_shape [has_colimits_of_shape J C] (k : K) :
  preserves_colimits_of_shape J ((evaluation K C).obj k) :=
{ preserves_colimit :=
  Œª F, preserves_colimit_of_preserves_colimit_cocone (combined_is_colimit _ _) $
    is_colimit.of_iso_colimit (colimit.is_colimit _)
      (evaluate_combined_cocones F _ k).symm }

instance evaluation_preserves_limits [has_limits C] (k : K) :
  preserves_limits ((evaluation K C).obj k) :=
{ preserves_limits_of_shape := Œª J ùí•, by resetI; apply_instance }

instance evaluation_preserves_colimits [has_colimits C] (k : K) :
  preserves_colimits ((evaluation K C).obj k) :=
{ preserves_colimits_of_shape := Œª J ùí•, by resetI; apply_instance }

end category_theory.limits
