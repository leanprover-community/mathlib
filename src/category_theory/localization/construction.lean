/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/

import category_theory.morphism_property
import category_theory.category.Quiv

/-!

# Construction of the localized category

This file constructs the localized category, obtained by formally inverting
a class of maps `W : morphism_property C` in a category `C`.

We first construct a quiver `loc_quiver W` whose objects are the same as those
of `C` and whose maps are the maps in `C` and placeholders for the formal
inverses of the maps in `W`.

The localized category `W.localization` is obtained by taking the quotient
of the path category of `loc_quiver W` by the congruence generated by four
types of relations.

The obvious functor `Q W : C ‚•§ W.localization` satisfies the universal property
of the localization. Indeed, if `G : C ‚•§ D` sends morphisms in `W` to isomorphisms
in `D` (i.e. we have `hG : W.is_inverted_by G`), then there exists a unique functor
`G' : W.localization ‚•§ D` such that `Q W ‚â´ G' = G`. This `G'` is `lift G hG`.
The expected property of `lift G hG` if expressed by the lemma `fac` and the
uniqueness is expressed by `uniq`.

TODO:
1) show that for any category `E`, the composition of functors gives
an equivalence of categories between `W.localization ‚•§ E` and the full
subcategory of `C ‚•§ E` consisting of functors inverting `W`. (This only
requires an extension property for natural transformations of functors.)

2) define a predicate `is_localization L W` for a functor `L : C ‚•§ D` and
a class of morphisms `W` in `C` expressing that it is a localization with respect
to `W`, i.e. that it inverts `W` and that the obvious functor `W.localization ‚•§ D`
induced by `L` is an equivalence of categories. (It is more straightforward
to define this predicate this way rather than by using a universal property which
may imply attempting at quantifying on all universes.)

3) implement a constructor for `is_localization L W` which would take
as an input a *strict* universal property (`lift`/`fac`/`uniq`) similar to
what is obtained here for `W.localization`. (Practically speaking, this is
the easiest way to show that a functor is a localization.)

4) when we have `is_localization L W`, then show that `D ‚•§ E` identifies
to the full subcategory of `C ‚•§ E` consisting of `W`-inverting functors.

5) provide an API for the lifting of functors `C ‚•§ E`, for which
`fac`/`uniq` assertions would be expressed as isomorphisms rather than
by equalities of functors.

## References

* [P. Gabriel, M. Zisman, *Calculus of fractions and homotopy theory*][gabriel-zisman-1967]

-/

noncomputable theory

open category_theory.category

namespace category_theory

variables {C D : Type*} [category C] [category D] (W : morphism_property C)

namespace localization

namespace construction

/-- If `W : morphism_property C`, `loc_quiver W` is a quiver with the same objects
as `C`, and whose morphisms are those in `C` and placeholders for formal
inverses of the morphisms in `W`. -/
@[nolint has_nonempty_instance]
structure loc_quiver (W : morphism_property C) := (obj : C)

instance : quiver (loc_quiver W) :=
{ hom := Œª A B, (A.obj ‚ü∂ B.obj) ‚äï { f : B.obj ‚ü∂ A.obj // W f} }

/-- The object in the path category of `loc_quiver W` attached to an object in
the category `C` -/
def Œπ_paths (X : C) : paths (loc_quiver W) := ‚ü®X‚ü©

/-- The morphism in the path category associated to a morphism in the original category. -/
@[simp]
def œà‚ÇÅ {X Y : C} (f : X ‚ü∂ Y) : Œπ_paths W X ‚ü∂ Œπ_paths W Y := paths.of.map (sum.inl f)

/-- The morphism in the path category corresponding to a formal inverse. -/
@[simp]
def œà‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : Œπ_paths W Y ‚ü∂ Œπ_paths W X :=
paths.of.map (sum.inr ‚ü®w, hw‚ü©)

/-- The relations by which we take the quotient in order to get the localized category. -/
inductive relations : hom_rel (paths (loc_quiver W))
| id (X : C) :
  relations (œà‚ÇÅ W (ùüô X)) (ùüô _)
| comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  relations (œà‚ÇÅ W (f ‚â´ g)) (œà‚ÇÅ W f ‚â´ œà‚ÇÅ W g)
| Winv‚ÇÅ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) :
  relations (œà‚ÇÅ W w ‚â´ œà‚ÇÇ W w hw) (ùüô _)
| Winv‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) :
  relations (œà‚ÇÇ W w hw ‚â´ œà‚ÇÅ W w) (ùüô _)

end construction

end localization

namespace morphism_property

open localization.construction

/-- The localized category obtained by formally inverting the morphisms
in `W : morphism_property C` -/
@[derive category, nolint has_nonempty_instance]
def localization := category_theory.quotient (localization.construction.relations W)

/-- The obvious functor `C ‚•§ W.localization` -/
def Q : C ‚•§ W.localization :=
{ obj := Œª X, (quotient.functor _).obj (paths.of.obj ‚ü®X‚ü©),
  map := Œª X Y f, (quotient.functor _).map (œà‚ÇÅ W f),
  map_id' := Œª X, quotient.sound _ (relations.id X),
  map_comp' := Œª X Z Y f g, quotient.sound _ (relations.comp f g), }

end morphism_property

namespace localization

namespace construction

/-- The isomorphism in `W.localization` associated to a morphism `w` in W -/
def Wiso {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : iso (W.Q.obj X) (W.Q.obj Y) :=
{ hom := W.Q.map w,
  inv := (quotient.functor _).map (paths.of.map (sum.inr ‚ü®w, hw‚ü©)),
  hom_inv_id' := quotient.sound _ (relations.Winv‚ÇÅ w hw),
  inv_hom_id' := quotient.sound _ (relations.Winv‚ÇÇ w hw), }

end construction

end localization

namespace localization

namespace construction

variables {W} (G : C ‚•§ D) (hG : W.is_inverted_by G)

include G hG

/-- The lifting of a functor to the path category of `loc_quiver W` -/
@[simps]
def lift_to_path_category : paths (loc_quiver W) ‚•§ D :=
Quiv.lift
{ obj := Œª X, G.obj X.obj,
  map := Œª X Y, begin
    rintro (f|‚ü®g, hg‚ü©),
    { exact G.map f, },
    { haveI := hG g hg,
      exact inv (G.map g), },
  end, }

/-- The lifting of a functor `C ‚•§ D` inverting `W` as a functor `W.localization ‚•§ D` -/
@[simps]
def lift : W.localization ‚•§ D :=
quotient.lift (relations W) (lift_to_path_category G hG)
begin
  rintro ‚ü®X‚ü© ‚ü®Y‚ü© f‚ÇÅ f‚ÇÇ r,
  rcases r,
  tidy,
end

@[simp]
lemma fac : W.Q ‚ãô lift G hG = G :=
functor.ext (Œª X, rfl)
begin
  intros X Y f,
  simp only [functor.comp_map, eq_to_hom_refl, comp_id, id_comp],
  dsimp [lift, lift_to_path_category, morphism_property.Q],
  rw compose_path_to_path,
end

omit G hG

lemma uniq (G‚ÇÅ G‚ÇÇ : W.localization ‚•§ D) (h : W.Q ‚ãô G‚ÇÅ = W.Q ‚ãô G‚ÇÇ) :
  G‚ÇÅ = G‚ÇÇ :=
begin
  suffices h' : quotient.functor _ ‚ãô G‚ÇÅ = quotient.functor _ ‚ãô G‚ÇÇ,
  { refine functor.ext _ _,
    { rintro ‚ü®‚ü®X‚ü©‚ü©,
      apply functor.congr_obj h, },
    { rintros ‚ü®‚ü®X‚ü©‚ü© ‚ü®‚ü®Y‚ü©‚ü© ‚ü®f‚ü©,
      apply functor.congr_hom h', }, },
  { refine paths.ext_functor _ _,
    { ext X,
      cases X,
      apply functor.congr_obj h, },
    { rintro ‚ü®X‚ü© ‚ü®Y‚ü© (f|‚ü®w, hw‚ü©),
      { simpa only using functor.congr_hom h f, },
      { have hw : W.Q.map w = (Wiso W w hw).hom := rfl,
        have hw' := functor.congr_hom h w,
        simp only [functor.comp_map, hw] at hw',
        refine functor.congr_inv_of_congr_hom _ _ _ _ _ hw',
        all_goals
        { apply functor.congr_obj h, }, }, }, },
end

end construction

end localization

end category_theory
