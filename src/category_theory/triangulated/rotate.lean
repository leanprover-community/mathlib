/-
Copyright (c) 2021 Luke Kershaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Luke Kershaw
-/
import category_theory.additive.basic
import category_theory.shift
import category_theory.abelian.additive_functor
import category_theory.natural_isomorphism
import category_theory.triangulated.basic

/-!
# Rotate

This file adds the ability to rotate triangles and triangle morphisms.
It also shows that rotation gives an equivalence on the category of triangles.

-/

noncomputable theory

open category_theory
open category_theory.preadditive
open category_theory.limits

universes v v‚ÇÄ v‚ÇÅ v‚ÇÇ u u‚ÇÄ u‚ÇÅ u‚ÇÇ

namespace category_theory.triangulated
open category_theory.category

/--
We work in an additive category C equipped with an additive shift.
-/
variables (C : Type u) [category.{v} C] [has_shift C] [additive_category C]
  [functor.additive (shift C).functor] [functor.additive (shift C).inverse]
variables (X : C)

/--
If you rotate a triangle, you get another triangle.
Given a triangle of the form:
```
      f       g       h
  X  ---> Y  ---> Z  ---> X[1]
```
applying `rotate` gives a triangle of the form:
```
      g        h       -f[1]
  Y  ---> Z  --->  X[1] ---> Y[1]
```
-/
@[simps]
def triangle.rotate (T : triangle C) : triangle C :=
{ obj‚ÇÅ := T.obj‚ÇÇ,
  obj‚ÇÇ := T.obj‚ÇÉ,
  obj‚ÇÉ := T.obj‚ÇÅ‚ü¶1‚üß,
  mor‚ÇÅ := T.mor‚ÇÇ,
  mor‚ÇÇ := T.mor‚ÇÉ,
  mor‚ÇÉ := -T.mor‚ÇÅ‚ü¶1‚üß' }

/--
Given a triangle of the form:
```
      f       g       h
  X  ---> Y  ---> Z  ---> X[1]
```
applying `inv_rotate` gives a triangle that can be thought of as:
```
        -h[-1]     f       g
  Z[-1]  --->  X  ---> Y  ---> Z
```
(note that this diagram doesn't technically fit the definition of triangle, as `Z[-1][1]` is
not necessarily equal to `Z`, but it is isomorphic, by the counit_iso of (shift C))
-/
@[simps]
def triangle.inv_rotate (T : triangle C) : triangle C :=
{ obj‚ÇÅ := T.obj‚ÇÉ‚ü¶-1‚üß,
  obj‚ÇÇ := T.obj‚ÇÅ,
  obj‚ÇÉ := T.obj‚ÇÇ,
  mor‚ÇÅ := -T.mor‚ÇÉ‚ü¶-1‚üß' ‚â´ (shift C).unit_iso.inv.app T.obj‚ÇÅ,
  mor‚ÇÇ := T.mor‚ÇÅ,
  mor‚ÇÉ := T.mor‚ÇÇ ‚â´ (shift C).counit_iso.inv.app T.obj‚ÇÉ }



namespace triangle_morphism
variables {T‚ÇÅ T‚ÇÇ T‚ÇÉ T‚ÇÑ: triangle C}
/--
You can also rotate a triangle morphism to get a morphism between the two rotated triangles.
Given a triangle morphism of the form:
```
      f       g       h
  X  ---> Y  ---> Z  ---> X[1]
  |       |       |        |
  |a      |b      |c       |a[1]
  V       V       V        V
  X' ---> Y' ---> Z' ---> X'[1]
      f'      g'      h'
```
applying `rotate` gives a triangle morphism of the form:
```
      g        h       -f[1]
  Y  ---> Z  --->  X[1] ---> Y[1]
  |       |         |         |
  |b      |c        |a[1]     |b[1]
  V       V         V         V
  Y' ---> Z' ---> X'[1] ---> Y'[1]
      g'      h'       -f'[1]
```
-/
@[simps]
def rotate (f : triangle_morphism T‚ÇÅ T‚ÇÇ) :
  triangle_morphism (T‚ÇÅ.rotate C) (T‚ÇÇ.rotate C):=
{ hom‚ÇÅ := f.hom‚ÇÇ,
  hom‚ÇÇ := f.hom‚ÇÉ,
  hom‚ÇÉ := f.hom‚ÇÅ‚ü¶1‚üß',
  comm‚ÇÉ' := begin
    repeat {rw triangle.rotate_mor‚ÇÉ},
    rw [comp_neg, neg_comp],
    repeat {rw ‚Üê functor.map_comp},
    rw f.comm‚ÇÅ,
  end }

/--
Given a triangle morphism of the form:
```
      f       g       h
  X  ---> Y  ---> Z  ---> X[1]
  |       |       |        |
  |a      |b      |c       |a[1]
  V       V       V        V
  X' ---> Y' ---> Z' ---> X'[1]
      f'      g'      h'
```
applying `inv_rotate` gives a triangle morphism that can be thought of as:
```
        -h[-1]      f         g
  Z[-1]  --->  X   --->  Y   --->  Z
    |          |         |         |
    |a         |b        |c        |a[1]
    V          V         V         V
  Z'[-1] --->  X'  --->  Y'  --->  Z'
        -h'[-1]     f'        g'
```
(note that this diagram doesn't technically fit the definition of triangle morphism,
as `Z[-1][1]` is not necessarily equal to `Z`, and `Z'[-1][1]` is not necessarily equal to `Z'`,
but they are isomorphic, by the `counit_iso` of `shift C`)
-/
@[simps]
def inv_rotate (f : triangle_morphism T‚ÇÅ T‚ÇÇ) :
  triangle_morphism (T‚ÇÅ.inv_rotate C) (T‚ÇÇ.inv_rotate C) :=
{ hom‚ÇÅ := f.hom‚ÇÉ‚ü¶-1‚üß',
  hom‚ÇÇ := f.hom‚ÇÅ,
  hom‚ÇÉ := f.hom‚ÇÇ,
  comm‚ÇÅ' := begin
    simp only [triangle.inv_rotate_mor‚ÇÅ],
    rw [comp_neg, neg_comp, ‚Üê assoc],
    dsimp,
    rw [‚Üê functor.map_comp (shift C ).inverse, ‚Üê f.comm‚ÇÉ, functor.map_comp],
    repeat {rw assoc},
    suffices h : (shift C).unit_iso.inv.app T‚ÇÅ.obj‚ÇÅ ‚â´ f.hom‚ÇÅ =
      (shift C).inverse.map ((shift C).functor.map f.hom‚ÇÅ) ‚â´ (shift C).unit_iso.inv.app T‚ÇÇ.obj‚ÇÅ,
    { rw h },
    { simp only [iso.hom_inv_id_app, assoc, equivalence.inv_fun_map,
        nat_iso.cancel_nat_iso_inv_left],
      exact (category.comp_id f.hom‚ÇÅ).symm }
  end,
  comm‚ÇÉ' := begin
    have h := f.comm‚ÇÇ,
    repeat {rw triangle.inv_rotate_mor‚ÇÉ},
    rw [‚Üê assoc f.hom‚ÇÇ _, ‚Üê f.comm‚ÇÇ],
    dsimp,
    repeat {rw assoc},
    simp only [equivalence.fun_inv_map, iso.inv_hom_id_app_assoc],
  end }

end triangle_morphism

/--
Rotating triangles gives an endofunctor on the category of triangles in C.
-/
@[simps]
def rotate : (triangle C) ‚•§ (triangle C) :=
{ obj := triangle.rotate C,
  map := Œª _ _ f, f.rotate C,
  map_id' := begin
    intro T‚ÇÅ,
    simp only [triangle_category_to_category_struct_id],
    unfold triangle_morphism.rotate,
    dsimp,
    ext,
    { refl },
    { refl },
    { simp only [triangle_morphism_id_hom‚ÇÉ, (shift C).functor.map_id],
      refl }
  end,
  map_comp' := begin
    intros T‚ÇÅ T‚ÇÇ T‚ÇÉ f g,
    unfold triangle_morphism.rotate,
    ext,
    { refl },
    { refl },
    { dsimp,
      rw (shift C).functor.map_comp }
  end
}

/--
The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.
-/
@[simps]
def inv_rotate : (triangle C) ‚•§ (triangle C) :=
{ obj := triangle.inv_rotate C,
  map := Œª _ _ f, f.inv_rotate C,
  map_id' := begin
    intro T‚ÇÅ,
    simp only [triangle_category_to_category_struct_id],
    ext,
    { simp only [triangle_morphism_id_hom‚ÇÉ, triangle_morphism.inv_rotate_hom‚ÇÅ,
        triangle_morphism_id_hom‚ÇÅ],
      dsimp,
      rw (shift C).inverse.map_id },
    { refl },
    { refl }
  end,
  map_comp' := begin
    intros T‚ÇÅ T‚ÇÇ T‚ÇÉ f g,
    unfold triangle_morphism.inv_rotate,
    ext,
    { simp only [triangle_morphism.comp_hom‚ÇÉ, triangle_morphism.comp_hom‚ÇÅ,
        triangle_category_to_category_struct_comp, functor.map_comp] },
    { refl },
    { refl }
  end
}

/--
There is a natural transformation between the identity functor on triangles,
and the composition of a rotation with an inverse rotation.
-/
@[simps]
def rot_comp_inv_rot_hom : ùü≠ (triangle C) ‚ü∂ (rotate C) ‚ãô (inv_rotate C) :=
{ app := begin
    intro T,
    rw [functor.id_obj, functor.comp_obj],
    let f : triangle_morphism T ((inv_rotate C).obj ((rotate C).obj T)) :=
    { hom‚ÇÅ := (shift C).unit.app T.obj‚ÇÅ,
      hom‚ÇÇ := ùüô T.obj‚ÇÇ,
      hom‚ÇÉ := ùüô T.obj‚ÇÉ,
      comm‚ÇÅ' := begin
        rw comp_id,
        dsimp,
        rw [comp_neg, functor.additive.map_neg (shift C).inverse, ‚Üê functor.comp_map],
        simp only [neg_comp, comp_neg, functor.comp_map, iso.hom_inv_id_app_assoc,
          iso.hom_inv_id_app, assoc, equivalence.inv_fun_map, neg_neg],
        dsimp,
        simp only [comp_id],
      end,
      comm‚ÇÉ' := begin
        rw id_comp,
        dsimp,
        rw equivalence.counit_inv_app_functor,
      end },
    exact f,
  end,
  naturality' := begin
    intros T‚ÇÅ T‚ÇÇ f,
    simp only [functor.id_obj, congr_arg_mpr_hom_left, functor.id_map, functor.comp_map,
      id_comp, eq_to_hom_refl, congr_arg_mpr_hom_right, comp_id, functor.comp_obj],
    ext,
    { dsimp,
      simp only [iso.hom_inv_id_app_assoc, equivalence.inv_fun_map] },
    { dsimp,
      simp only [id_comp, comp_id] },
    { dsimp,
      simp only [id_comp, comp_id] }
  end
}

/--
There is a natural transformation between the composition of a rotation with an inverse rotation
on triangles, and the identity functor.
-/
@[simps]
def rot_comp_inv_rot_inv : (rotate C) ‚ãô (inv_rotate C) ‚ü∂ ùü≠ (triangle C) :=
{ app := begin
    intro T,
    rw [functor.id_obj, functor.comp_obj],
    let f : triangle_morphism ((inv_rotate C).obj ((rotate C).obj T)) T :=
    { hom‚ÇÅ := (shift C).unit_inv.app T.obj‚ÇÅ,
      hom‚ÇÇ := ùüô T.obj‚ÇÇ,
      hom‚ÇÉ := ùüô T.obj‚ÇÉ,
      comm‚ÇÅ' := begin
        dsimp,
        simp only [neg_comp, iso.hom_inv_id_app, functor.additive.map_neg, assoc,
          equivalence.inv_fun_map, neg_neg, comp_id, nat_iso.cancel_nat_iso_inv_left],
        dsimp,
        simp only [comp_id],
      end },
    exact f
  end,
  naturality' := begin
    intros T‚ÇÅ T‚ÇÇ f,
    simp only [functor.id_obj, congr_arg_mpr_hom_left, functor.id_map, functor.comp_map,
      id_comp, eq_to_hom_refl, congr_arg_mpr_hom_right, comp_id, functor.comp_obj],
    dsimp,
    ext,
    { simp only [triangle_morphism.comp_hom‚ÇÅ,
        triangle_morphism.inv_rotate_hom‚ÇÅ, triangle_morphism.rotate_hom‚ÇÉ],
      dsimp,
      simp only [iso.hom_inv_id_app, assoc, equivalence.inv_fun_map,
        nat_iso.cancel_nat_iso_inv_left],
      dsimp,
      simp only [comp_id] },
    { simp only [triangle_morphism.comp_hom‚ÇÇ, triangle_morphism.inv_rotate_hom‚ÇÇ,
        triangle_morphism.rotate_hom‚ÇÅ, comp_id f.hom‚ÇÇ, id_comp f.hom‚ÇÇ] },
    { simp only [triangle_morphism.comp_hom‚ÇÉ, triangle_morphism.rotate_hom‚ÇÇ,
        triangle_morphism.inv_rotate_hom‚ÇÉ, comp_id f.hom‚ÇÉ, id_comp f.hom‚ÇÉ] }
  end
}

/--
The natural transformations between the identity functor on triangles and the composition
of a rotation with an inverse rotation are natural isomorphisms (they are isomorphisms in the
category of functors).
-/
@[simps]
def rot_comp_inv_rot : ùü≠ (triangle C) ‚âÖ (rotate C) ‚ãô (inv_rotate C) :=
{ hom := rot_comp_inv_rot_hom C,
  inv := rot_comp_inv_rot_inv C,
  hom_inv_id' := begin
    ext T,
    { simp only [functor.id_obj, congr_arg_mpr_hom_left, triangle_morphism.comp_hom‚ÇÅ,
        triangle_category_to_category_struct_comp, rot_comp_inv_rot_inv_app,
        rot_comp_inv_rot_hom_app, iso.hom_inv_id_app, category.id_comp,
        nat_trans.id_app, triangle_category_to_category_struct_id,
        triangle_morphism_id_hom‚ÇÅ, eq_to_hom_refl, congr_arg_mpr_hom_right,
        category.comp_id, functor.comp_obj, nat_trans.comp_app],
      dsimp,
      refl },
    { simp only [functor.id_obj, congr_arg_mpr_hom_left,
        triangle_category_to_category_struct_comp,
        rot_comp_inv_rot_inv_app, triangle_morphism.comp_hom‚ÇÇ, rot_comp_inv_rot_hom_app,
        category.id_comp, nat_trans.id_app, triangle_category_to_category_struct_id,
        triangle_morphism_id_hom‚ÇÇ, eq_to_hom_refl, congr_arg_mpr_hom_right,
        category.comp_id, functor.comp_obj, nat_trans.comp_app],
      dsimp,
      refl },
    { simp only [functor.id_obj, congr_arg_mpr_hom_left,
        triangle_category_to_category_struct_comp,
        rot_comp_inv_rot_inv_app, triangle_morphism.comp_hom‚ÇÉ, rot_comp_inv_rot_hom_app,
        category.id_comp, nat_trans.id_app, triangle_category_to_category_struct_id,
        triangle_morphism_id_hom‚ÇÉ, eq_to_hom_refl, congr_arg_mpr_hom_right,
        category.comp_id, functor.comp_obj, nat_trans.comp_app],
      dsimp,
      refl }
  end,
  inv_hom_id' := begin
    ext T,
    { simp,
      refl },
    { simp,
      refl },
    { simp,
      refl }
  end -- (deterministic) timeout when replace simp with squeeze_simp
}

/--
There is a natural transformation between the composition of an inverse rotation with a rotation
on triangles, and the identity functor.
-/
@[simps]
def inv_rot_comp_rot_hom : (inv_rotate C) ‚ãô (rotate C) ‚ü∂ ùü≠ (triangle C) :=
{ app := begin
    intro T,
    rw [functor.id_obj, functor.comp_obj],
    let f : triangle_morphism ((rotate C).obj((inv_rotate C).obj T)) T :=
    { hom‚ÇÅ := ùüô T.obj‚ÇÅ,
      hom‚ÇÇ := ùüô T.obj‚ÇÇ,
      hom‚ÇÉ := (shift C).counit.app T.obj‚ÇÉ },
    exact f
  end,
  naturality' := begin
    intros T‚ÇÅ T‚ÇÇ f,
    simp,
    dsimp,
    ext,
    { simp,
      dsimp,
      simp },
    { simp,
      dsimp,
      simp },
    { simp,
      dsimp,
      simp,
      dsimp,
      rw comp_id }
  end
}

/--
There is a natural transformation between the identity functor on triangles,
and  the composition of an inverse rotation with a rotation.
-/
@[simps]
def inv_rot_comp_rot_inv : ùü≠ (triangle C) ‚ü∂ (inv_rotate C) ‚ãô (rotate C) :=
{ app := begin
    intro T,
    rw [functor.id_obj, functor.comp_obj],
    let f : triangle_morphism T ((rotate C).obj ((inv_rotate C).obj T)) :=
    { hom‚ÇÅ := ùüô T.obj‚ÇÅ,
      hom‚ÇÇ := ùüô T.obj‚ÇÇ,
      hom‚ÇÉ := (shift C).counit_inv.app T.obj‚ÇÉ },
    exact f
  end,
  naturality' := begin
    intros T‚ÇÅ T‚ÇÇ f,
    simp,
    dsimp,
    ext,
    { simp },
    { simp },
    { simp,
      dsimp,
      simp }
  end
}

/--
The natural transformations between the composition of a rotation with an inverse rotation
on triangles, and the identity functor on triangles are natural isomorphisms
(they are isomorphisms in the category of functors).
-/
@[simps]
def inv_rot_comp_rot : (inv_rotate C) ‚ãô (rotate C) ‚âÖ ùü≠ (triangle C) :=
{
  hom := inv_rot_comp_rot_hom C,
  inv := inv_rot_comp_rot_inv C,
  hom_inv_id' := begin
    ext T,
    { dsimp,
      simp,
      dsimp,
      simp },
    { dsimp,
      simp,
      dsimp,
      simp },
    { simp,
      dsimp,
      simp }
  end,
  inv_hom_id' := begin
    ext T,
    { dsimp,
      simp,
      dsimp,
      simp },
    { dsimp,
      simp,
      dsimp,
      simp },
    { dsimp,
      simp,
      dsimp,
      simp,
      refl }
  end
}

/--
Rotating triangles gives an auto-equivalence on the category of triangles.
-/
def triangle_rotation : equivalence (triangle C) (triangle C) :=
{ functor := rotate C,
  inverse := inv_rotate C,
  unit_iso := rot_comp_inv_rot C,
  counit_iso := inv_rot_comp_rot C,
  functor_unit_iso_comp' := begin
    intro T,
    ext,
    { dsimp,
      simp,
      dsimp,
      simp },
    { dsimp,
      simp,
      dsimp,
      simp },
    { dsimp,
      simp,
      dsimp,
      simp }
  end
}

end category_theory.triangulated
