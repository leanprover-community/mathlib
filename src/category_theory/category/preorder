/-
Copyright (c) 2017 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Stephen Morgan, Scott Morrison, Johannes H√∂lzl, Reid Barton
-/

import category_theory.category.default
import order.category.Preorder

/-!
We now put a category instance on any preorder.

Because we do not allow the morphisms of a category to live in `Prop`,
unfortunately we need to use `plift` and `ulift` when defining the morphisms.

As convenience functions, we provide `hom_of_le` and `le_of_hom` to wrap and unwrap inequalities.
We also provide aliases `has_le.le.hom` and `quiver.hom.le` to use with dot notation.
-/

universes u v

namespace preorder

open category_theory

/--
The category structure coming from a preorder. There is a morphism `X ‚ü∂ Y` if and only if `X ‚â§ Y`.

Because we don't allow morphisms to live in `Prop`,
we have to define `X ‚ü∂ Y` as `ulift (plift (X ‚â§ Y))`.
See `category_theory.hom_of_le` and `category_theory.le_of_hom`.

See https://stacks.math.columbia.edu/tag/00D3.
-/
@[priority 100] -- see Note [lower instance priority]
instance small_category (Œ± : Type u) [preorder Œ±] : small_category Œ± :=
{ hom  := Œª U V, ulift (plift (U ‚â§ V)),
  id   := Œª X, ‚ü® ‚ü® le_refl X ‚ü© ‚ü©,
  comp := Œª X Y Z f g, ‚ü® ‚ü® le_trans _ _ _ f.down.down g.down.down ‚ü© ‚ü© }

end preorder

namespace category_theory

variables {Œ± : Type u} [preorder Œ±]

/--
Express an inequality as a morphism in the corresponding preorder category.
-/
def hom_of_le {U V : Œ±} (h : U ‚â§ V) : U ‚ü∂ V := ulift.up (plift.up h)

alias hom_of_le ‚Üê has_le.le.hom

@[simp] lemma hom_of_le_refl {U : Œ±} : (le_refl U).hom = ùüô U := rfl
@[simp] lemma hom_of_le_comp {U V W : Œ±} (h : U ‚â§ V) (k : V ‚â§ W) :
  h.hom ‚â´ k.hom = (h.trans k).hom := rfl

/--
Extract the underlying inequality from a morphism in a preorder category.
-/
lemma le_of_hom {U V : Œ±} (h : U ‚ü∂ V) : U ‚â§ V := h.down.down

alias le_of_hom ‚Üê quiver.hom.le

@[simp] lemma le_of_hom_hom_of_le {a b : Œ±} (h : a ‚â§ b) : h.hom.le = h := rfl
@[simp] lemma hom_of_le_le_of_hom {a b : Œ±} (h : a ‚ü∂ b) : h.le.hom = h :=
by { cases h, cases h, refl, }

end category_theory

namespace function

open category_theory

variables (X : Type u) (Y : Type v) [preorder X] [preorder Y]

def monotone.functor {f : X ‚Üí Y} (h : monotone f) : X ‚•§ Y :=
{ obj := f,
  map := Œª x‚ÇÅ x‚ÇÇ g, (h g.le).hom }
