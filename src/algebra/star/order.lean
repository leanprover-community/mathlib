/-
Copyright (c) 2023 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/

import algebra.star.basic
import group_theory.submonoid.basic

/-! # Star ordered rings

We define the class `star_ordered_ring R`, which says that the order on `R` respects the
star operation, i.e. an element `r` is nonnegative iff it is in the `add_submonoid` generated by
elements of the form `star s * s`. In many cases, including all C⋆-algebras, this can be reduced to
`0 ≤ r ↔ ∃ s, r = star s * s`. However, this generality is slightly more convenient (e.g., it
allows us to register a `star_ordered_ring` instance for `ℚ`), and more closely resembles the
literature (see the seminal paper [*The positive cone in Banach algebras*][kelleyVaught1953])

## TODO

* In a Banach star algebra without a well-defined square root, the natural ordering is given by the
positive cone which is the closure of the sums of elements `star r * r`. A weaker version of
`star_ordered_ring` could be defined for this case (again, see
[*The positive cone in Banach algebras*][kelleyVaught1953]). Note that the current definition has
the advantage of not requiring a topology.
-/

universe u
variable {R : Type*}

/--
An ordered `*`-ring is a ring which is both an `ordered_add_comm_group` and a `*`-ring,
and `0 ≤ r ↔ ∃ s, r = star s * s`.
-/
class star_ordered_ring (R : Type u) [non_unital_semiring R] [partial_order R]
  extends star_ring R :=
(add_le_add_left       : ∀ a b : R, a ≤ b → ∀ c : R, c + a ≤ c + b)
(nonneg_iff            : ∀ x : R, 0 ≤ x ↔ x ∈ add_submonoid.closure {(star s * s) | (s : R)})

namespace star_ordered_ring

@[priority 100] -- see note [lower instance priority]
instance [non_unital_ring R] [partial_order R] [star_ordered_ring R] : ordered_add_comm_group R :=
{ ..show non_unital_ring R, by apply_instance,
  ..show partial_order R, by apply_instance,
  ..show star_ordered_ring R, by apply_instance }

end star_ordered_ring

section non_unital_semiring

variables [non_unital_semiring R] [partial_order R] [star_ordered_ring R]

lemma star_mul_self_nonneg (r : R) : 0 ≤ star r * r :=
(star_ordered_ring.nonneg_iff _).mpr $ add_submonoid.subset_closure ⟨r, rfl⟩

lemma star_mul_self_nonneg' (r : R) : 0 ≤ r * star r :=
by { nth_rewrite_rhs 0 [←star_star r], exact star_mul_self_nonneg (star r) }

lemma conjugate_nonneg {a : R} (ha : 0 ≤ a) (c : R) : 0 ≤ star c * a * c :=
begin
  rw star_ordered_ring.nonneg_iff at ha,
  refine add_submonoid.closure_induction ha (λ x hx, _) (by rw [mul_zero, zero_mul])
    (λ x y hx hy, _),
  { obtain ⟨x, rfl⟩ := hx,
    convert star_mul_self_nonneg (x * c) using 1,
    rw [star_mul, ←mul_assoc, mul_assoc _ _ c] },
  { calc 0 ≤ star c * x * c + 0 : by rw [add_zero]; exact hx
     ...   ≤ star c * x * c + star c * y * c : star_ordered_ring.add_le_add_left _ _ hy _
     ...   ≤ _ : by rw [mul_add, add_mul] }
end

lemma conjugate_nonneg' {a : R} (ha : 0 ≤ a) (c : R) : 0 ≤ c * a * star c :=
by simpa only [star_star] using conjugate_nonneg ha (star c)

end non_unital_semiring

section non_unital_ring

variables [non_unital_ring R] [partial_order R] [star_ordered_ring R]

lemma conjugate_le_conjugate {a b : R} (hab : a ≤ b) (c : R) : star c * a * c ≤ star c * b * c :=
begin
  rw ←sub_nonneg at hab ⊢,
  convert conjugate_nonneg hab c,
  simp only [mul_sub, sub_mul],
end

lemma conjugate_le_conjugate' {a b : R} (hab : a ≤ b) (c : R) : c * a * star c ≤ c * b * star c :=
by simpa only [star_star] using conjugate_le_conjugate hab (star c)

end non_unital_ring
