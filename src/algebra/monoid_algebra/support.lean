/-
Copyright (c) 2022 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa
-/
import algebra.monoid_algebra.basic

/-!
#  Lemmas about the support of a finitely supported function
-/

universes u₁ u₂ u₃
namespace monoid_algebra

open finset finsupp
variables {k : Type u₁} {G : Type u₂} {R : Type u₃} [semiring k]

lemma support_mul [has_mul G] [decidable_eq G] (a b : monoid_algebra k G) :
  (a * b).support ⊆ a.support.bUnion (λa₁, b.support.bUnion $ λa₂, {a₁ * a₂}) :=
subset.trans support_sum $ bUnion_mono $ assume a₁ _,
  subset.trans support_sum $ bUnion_mono $ assume a₂ _, support_single_subset

lemma support_mul_single [right_cancel_semigroup G]
  (f : monoid_algebra k G) (r : k) (hr : ∀ y, y * r = 0 ↔ y = 0) (x : G) :
  (f * single x r).support = f.support.map (mul_right_embedding x) :=
begin
  ext y, simp only [mem_support_iff, mem_map, exists_prop, mul_right_embedding_apply],
  by_cases H : ∃ a, a * x = y,
  { rcases H with ⟨a, rfl⟩,
    rw [mul_single_apply_aux f (λ _, mul_left_inj x)],
    simp [hr] },
  { push_neg at H,
    classical,
    simp [mul_apply, H] }
end

lemma support_single_mul [left_cancel_semigroup G]
  (f : monoid_algebra k G) (r : k) (hr : ∀ y, r * y = 0 ↔ y = 0) (x : G) :
  (single x r * f : monoid_algebra k G).support = f.support.map (mul_left_embedding x) :=
begin
  ext y, simp only [mem_support_iff, mem_map, exists_prop, mul_left_embedding_apply],
  by_cases H : ∃ a, x * a = y,
  { rcases H with ⟨a, rfl⟩,
    rw [single_mul_apply_aux f (λ _, mul_right_inj x)],
    simp [hr] },
  { push_neg at H,
    classical,
    simp [mul_apply, H] }
end
section span

variables [mul_one_class G]

/-- An element of `monoid_algebra R M` is in the subalgebra generated by its support. -/
lemma mem_span_support (f : monoid_algebra k G) :
  f ∈ submodule.span k (of k G '' (f.support : set G)) :=
by rw [of, monoid_hom.coe_mk, ← finsupp.supported_eq_span_single, finsupp.mem_supported]

end span


end monoid_algebra

namespace add_monoid_algebra

open finset finsupp mul_opposite
variables {k : Type u₁} {G : Type u₂} {R : Type u₃} [semiring k]

lemma support_mul [decidable_eq G] [has_add G] (a b : add_monoid_algebra k G) :
  (a * b).support ⊆ a.support.bUnion (λa₁, b.support.bUnion $ λa₂, {a₁ + a₂}) :=
@monoid_algebra.support_mul k (multiplicative G) _ _ _ _ _

lemma support_mul_single [add_right_cancel_semigroup G]
  (f : add_monoid_algebra k G) (r : k) (hr : ∀ y, y * r = 0 ↔ y = 0) (x : G) :
  (f * single x r : add_monoid_algebra k G).support = f.support.map (add_right_embedding x) :=
@monoid_algebra.support_mul_single k (multiplicative G) _ _ _ _ hr _

lemma support_single_mul [add_left_cancel_semigroup G]
  (f : add_monoid_algebra k G) (r : k) (hr : ∀ y, r * y = 0 ↔ y = 0) (x : G) :
  (single x r * f : add_monoid_algebra k G).support = f.support.map (add_left_embedding x) :=
@monoid_algebra.support_single_mul k (multiplicative G) _ _ _ _ hr _

section span

/-- An element of `add_monoid_algebra R M` is in the submodule generated by its support. -/
lemma mem_span_support [add_zero_class G] (f : add_monoid_algebra k G) :
  f ∈ submodule.span k (of k G '' (f.support : set G)) :=
by rw [of, monoid_hom.coe_mk, ← finsupp.supported_eq_span_single, finsupp.mem_supported]

/-- An element of `add_monoid_algebra R M` is in the subalgebra generated by its support, using
unbundled inclusion. -/
lemma mem_span_support' (f : add_monoid_algebra k G) :
  f ∈ submodule.span k (of' k G '' (f.support : set G)) :=
by rw [of', ← finsupp.supported_eq_span_single, finsupp.mem_supported]

end span

end add_monoid_algebra
