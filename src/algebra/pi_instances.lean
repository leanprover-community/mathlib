-- /-
-- Copyright (c) 2018 Simon Hudon. All rights reserved.
-- Released under Apache 2.0 license as described in the file LICENSE.
-- Authors: Simon Hudon, Patrick Massot
-- -/
-- import algebra.module.basic
-- import ring_theory.subring
-- import ring_theory.prod

-- open_locale big_operators

-- /-!
-- # Pi instances for algebraic structures

-- ## Implementation notes

-- We don't use `by pi_instance` directly because currently instances generated by this tactic have
-- slightly wrong definitions (extra `id`s and `group.mul` instead of `has_mul.mul`). These little
-- bugs prevent Lean from applying a `simp` lemma about `pi.has_one` to `1` coming from `pi.group`.

-- ## TODO

-- Properly fix `tactic.pi_instance`.
-- -/

-- universes u v w
-- variable {I : Type u}     -- The indexing type
-- variable (f : I → Type v) -- The family of types already equipped with instances
-- variables [Π i, semiring (f i)]
-- variables [Π i, add_monoid (f i)]



-- -- namespace prod

-- -- variables {α : Type*} {β : Type*} {γ : Type*} {δ : Type*} {p q : α × β}
-- -- @[to_additive is_add_monoid_hom]
-- -- lemma fst.is_monoid_hom [monoid α] [monoid β] : is_monoid_hom (prod.fst : α × β → α) :=
-- -- { map_mul := λ _ _, rfl, map_one := rfl }
-- -- @[to_additive is_add_monoid_hom]
-- -- lemma snd.is_monoid_hom [monoid α] [monoid β] : is_monoid_hom (prod.snd : α × β → β) :=
-- -- { map_mul := λ _ _, rfl, map_one := rfl }

-- -- @[to_additive is_add_group_hom]
-- -- lemma fst.is_group_hom [group α] [group β] : is_group_hom (prod.fst : α × β → α) :=
-- -- { map_mul := λ _ _, rfl }
-- -- @[to_additive is_add_group_hom]
-- -- lemma snd.is_group_hom [group α] [group β] : is_group_hom (prod.snd : α × β → β) :=
-- -- { map_mul := λ _ _, rfl }

-- -- attribute [instance] fst.is_monoid_hom fst.is_add_monoid_hom snd.is_monoid_hom snd.is_add_monoid_hom
-- -- fst.is_group_hom fst.is_add_group_hom snd.is_group_hom snd.is_add_group_hom

-- -- @[to_additive]
-- -- lemma fst_prod [comm_monoid α] [comm_monoid β] {t : finset γ} {f : γ → α × β} :
-- --   (∏ c in t, f c).1 = ∏ c in t, (f c).1 :=
-- -- (monoid_hom.fst α β).map_prod f t

-- -- @[to_additive]
-- -- lemma snd_prod [comm_monoid α] [comm_monoid β] {t : finset γ} {f : γ → α × β} :
-- --   (∏ c in t, f c).2 = ∏ c in t, (f c).2 :=
-- -- (monoid_hom.snd α β).map_prod f t

-- -- instance fst.is_semiring_hom [semiring α] [semiring β] : is_semiring_hom (prod.fst : α × β → α) :=
-- -- (ring_hom.fst α β).is_semiring_hom
-- -- instance snd.is_semiring_hom [semiring α] [semiring β] : is_semiring_hom (prod.snd : α × β → β) :=
-- -- (ring_hom.snd α β).is_semiring_hom

-- -- instance fst.is_ring_hom [ring α] [ring β] : is_ring_hom (prod.fst : α × β → α) :=
-- -- (ring_hom.fst α β).is_ring_hom
-- -- instance snd.is_ring_hom [ring α] [ring β] : is_ring_hom (prod.snd : α × β → β) :=
-- -- (ring_hom.snd α β).is_ring_hom

-- /-- Left injection function for the inner product
-- From a vector space (and also group and module) perspective the product is the same as the sum of
-- two vector spaces. `inl` and `inr` provide the corresponding injection functions.
-- -/
-- -- def inl [has_zero β] (a : α) : α × β := (a, 0)

-- -- /-- Right injection function for the inner product -/
-- -- def inr [has_zero α] (b : β) : α × β := (0, b)

-- -- lemma inl_injective [has_zero β] : function.injective (inl : α → α × β) :=
-- -- assume x y h, (prod.mk.inj_iff.mp h).1

-- -- lemma inr_injective [has_zero α] : function.injective (inr : β → α × β) :=
-- -- assume x y h, (prod.mk.inj_iff.mp h).2

-- -- @[simp] lemma inl_eq_inl [has_zero β] {a₁ a₂ : α} : (inl a₁ : α × β) = inl a₂ ↔ a₁ = a₂ :=
-- -- iff.intro (assume h, inl_injective h) (assume h, h ▸ rfl)

-- -- @[simp] lemma inr_eq_inr [has_zero α] {b₁ b₂ : β} : (inr b₁ : α × β) = inr b₂ ↔ b₁ = b₂ :=
-- -- iff.intro (assume h, inr_injective h) (assume h, h ▸ rfl)

-- -- @[simp] lemma inl_eq_inr [has_zero α] [has_zero β] {a : α} {b : β} :
-- --   inl a = inr b ↔ a = 0 ∧ b = 0 :=
-- -- by constructor; simp [inl, inr] {contextual := tt}

-- -- @[simp] lemma inr_eq_inl [has_zero α] [has_zero β] {a : α} {b : β} :
-- --   inr b = inl a ↔ a = 0 ∧ b = 0 :=
-- -- by constructor; simp [inl, inr] {contextual := tt}

-- -- @[simp] lemma fst_inl [has_zero β] (a : α) : (inl a : α × β).1 = a := rfl
-- -- @[simp] lemma snd_inl [has_zero β] (a : α) : (inl a : α × β).2 = 0 := rfl
-- -- @[simp] lemma fst_inr [has_zero α] (b : β) : (inr b : α × β).1 = 0 := rfl
-- -- @[simp] lemma snd_inr [has_zero α] (b : β) : (inr b : α × β).2 = b := rfl

-- -- instance [has_scalar α β] [has_scalar α γ] : has_scalar α (β × γ) := ⟨λa p, (a • p.1, a • p.2)⟩

-- -- @[simp] theorem smul_fst [has_scalar α β] [has_scalar α γ]
-- --   (a : α) (x : β × γ) : (a • x).1 = a • x.1 := rfl
-- -- @[simp] theorem smul_snd [has_scalar α β] [has_scalar α γ]
-- --   (a : α) (x : β × γ) : (a • x).2 = a • x.2 := rfl
-- -- @[simp] theorem smul_mk [has_scalar α β] [has_scalar α γ]
-- --   (a : α) (b : β) (c : γ) : a • (b, c) = (a • b, a • c) := rfl

-- -- instance {r : semiring α} [add_comm_monoid β] [add_comm_monoid γ]
-- --   [semimodule α β] [semimodule α γ] : semimodule α (β × γ) :=
-- -- { smul_add  := assume a p₁ p₂, mk.inj_iff.mpr ⟨smul_add _ _ _, smul_add _ _ _⟩,
-- --   add_smul  := assume a p₁ p₂, mk.inj_iff.mpr ⟨add_smul _ _ _, add_smul _ _ _⟩,
-- --   mul_smul  := assume a₁ a₂ p, mk.inj_iff.mpr ⟨mul_smul _ _ _, mul_smul _ _ _⟩,
-- --   one_smul  := assume ⟨b, c⟩, mk.inj_iff.mpr ⟨one_smul _ _, one_smul _ _⟩,
-- --   zero_smul := assume ⟨b, c⟩, mk.inj_iff.mpr ⟨zero_smul _ _, zero_smul _ _⟩,
-- --   smul_zero := assume a, mk.inj_iff.mpr ⟨smul_zero _, smul_zero _⟩,
-- --   .. prod.has_scalar }

-- -- section substructures
-- -- variables (s : set α) (t : set β)

-- -- @[to_additive is_add_submonoid]
-- -- instance [monoid α] [monoid β] [is_submonoid s] [is_submonoid t] :
-- --   is_submonoid (s.prod t) :=
-- -- { one_mem := by rw set.mem_prod; split; apply is_submonoid.one_mem,
-- --   mul_mem := by intros; rw set.mem_prod at *; split; apply is_submonoid.mul_mem; tauto }

-- -- @[to_additive prod.is_add_subgroup.prod]
-- -- instance is_subgroup.prod [group α] [group β] [is_subgroup s] [is_subgroup t] :
-- --   is_subgroup (s.prod t) :=
-- -- { inv_mem := by intros; rw set.mem_prod at *; split; apply is_subgroup.inv_mem; tauto,
-- --   .. prod.is_submonoid s t }

-- -- instance is_subring.prod [ring α] [ring β] [is_subring s] [is_subring t] :
-- --   is_subring (s.prod t) :=
-- -- { .. prod.is_submonoid s t, .. prod.is_add_subgroup.prod s t }

-- -- end substructures

-- -- end prod

-- namespace finset



-- end finset
