/-
Copyright (c) 2022 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/

import data.zmod.quotient
import linear_algebra.free_module.finite.rank
import linear_algebra.free_module.pid
import linear_algebra.free_module.strong_rank_condition
import linear_algebra.quotient_pi
import ring_theory.norm

/-! # Ideals in free modules over PIDs

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main results

 - `ideal.quotient_equiv_pi_span`: `S ⧸ I`, if `S` is finite free as a module over a PID `R`,
   can be written as a product of quotients of `R` by principal ideals.

-/

namespace ideal

open_locale big_operators direct_sum polynomial

variables {R S ι : Type*} [comm_ring R] [comm_ring S] [algebra R S]
variables [is_domain R] [is_principal_ideal_ring R] [is_domain S] [fintype ι]

/-- We can write the quotient of an ideal over a PID as a product of quotients by principal ideals.
-/
noncomputable def quotient_equiv_pi_span
  (I : ideal S) (b : basis ι R S) (hI : I ≠ ⊥) :
  (S ⧸ I) ≃ₗ[R] Π i, (R ⧸ span ({I.smith_coeffs b hI i} : set R)) :=
begin
  -- Choose `e : S ≃ₗ I` and a basis `b'` for `S` that turns the map
  -- `f := ((submodule.subtype I).restrict_scalars R).comp e` into a diagonal matrix:
  -- there is an `a : ι → ℤ` such that `f (b' i) = a i • b' i`.
  let a := I.smith_coeffs b hI,
  let b' := I.ring_basis b hI,
  let ab := I.self_basis b hI,
  have ab_eq := I.self_basis_def b hI,
  let e : S ≃ₗ[R] I := b'.equiv ab (equiv.refl _),
  let f : S →ₗ[R] S := (I.subtype.restrict_scalars R).comp (e : S →ₗ[R] I),
  let f_apply : ∀ x, f x = b'.equiv ab (equiv.refl _) x := λ x, rfl,
  have ha : ∀ i, f (b' i) = a i • b' i,
  { intro i, rw [f_apply, b'.equiv_apply, equiv.refl_apply, ab_eq] },
  have mem_I_iff : ∀ x, x ∈ I ↔ ∀ i, a i ∣ b'.repr x i,
  { intro x, simp_rw [ab.mem_ideal_iff', ab_eq],
    have : ∀ (c : ι → R) i, b'.repr (∑ (j : ι), c j • a j • b' j) i = a i * c i,
    { intros c i,
      simp only [← mul_action.mul_smul, b'.repr_sum_self, mul_comm] },
    split,
    { rintro ⟨c, rfl⟩ i, exact ⟨c i, this c i⟩ },
    { rintros ha,
      choose c hc using ha, exact ⟨c, b'.ext_elem (λ i, trans (hc i) (this c i).symm)⟩ } },

  -- Now we map everything through the linear equiv `S ≃ₗ (ι → R)`,
  -- which maps `I` to `I' := Π i, a i ℤ`.
  let I' : submodule R (ι → R) := submodule.pi set.univ (λ i, span ({a i} : set R)),
  have : submodule.map (b'.equiv_fun : S →ₗ[R] (ι → R)) (I.restrict_scalars R) = I',
  { ext x,
    simp only [submodule.mem_map, submodule.mem_pi, mem_span_singleton, set.mem_univ,
               submodule.restrict_scalars_mem, mem_I_iff, smul_eq_mul, forall_true_left,
               linear_equiv.coe_coe, basis.equiv_fun_apply],
    split,
    { rintros ⟨y, hy, rfl⟩ i, exact hy i },
    { rintros hdvd,
      refine ⟨∑ i, x i • b' i, λ i, _, _⟩; rwa b'.repr_sum_self,
      { exact hdvd i } } },
  refine ((submodule.quotient.restrict_scalars_equiv R I).restrict_scalars R).symm.trans _,
  any_goals { apply ring_hom.id }, any_goals { apply_instance },
  refine (submodule.quotient.equiv (I.restrict_scalars R) I' b'.equiv_fun this).trans _,
  any_goals { apply ring_hom.id }, any_goals { apply_instance },
  classical,
  let := submodule.quotient_pi (show Π i, submodule R R, from λ i, span ({a i} : set R)),
  exact this
end

/-- Ideal quotients over a free finite extension of `ℤ` are isomorphic to a direct product of
`zmod`. -/
noncomputable def quotient_equiv_pi_zmod
  (I : ideal S) (b : basis ι ℤ S) (hI : I ≠ ⊥) :
  (S ⧸ I) ≃+ Π i, (zmod (I.smith_coeffs b hI i).nat_abs) :=
let a := I.smith_coeffs b hI,
    e := I.quotient_equiv_pi_span b hI,
    e' : (Π (i : ι), (ℤ ⧸ span ({a i} : set ℤ))) ≃+ Π (i : ι), zmod (a i).nat_abs :=
  add_equiv.Pi_congr_right (λ i, ↑(int.quotient_span_equiv_zmod (a i)))
in (↑(e : (S ⧸ I) ≃ₗ[ℤ] _) : (S ⧸ I ≃+ _)).trans e'

/-- A nonzero ideal over a free finite extension of `ℤ` has a finite quotient.

Can't be an instance because of the side condition `I ≠ ⊥`, and more importantly,
because the choice of `fintype` instance is non-canonical.
-/
noncomputable def fintype_quotient_of_free_of_ne_bot [module.free ℤ S] [module.finite ℤ S]
  (I : ideal S) (hI : I ≠ ⊥) :
  fintype (S ⧸ I) :=
let b := module.free.choose_basis ℤ S,
    a := I.smith_coeffs b hI,
    e := I.quotient_equiv_pi_zmod b hI
in by haveI : ∀ i, ne_zero (a i).nat_abs :=
    (λ i, ⟨int.nat_abs_ne_zero_of_ne_zero (smith_coeffs_ne_zero b I hI i)⟩); classical;
  exact fintype.of_equiv (Π i, zmod (a i).nat_abs) e.symm

section comm_ring

variables (F : Type*) [comm_ring F] [algebra F R] [algebra F S] [is_scalar_tower F R S]
  (b : basis ι R S) {I : ideal S} (hI : I ≠ ⊥)

/-- Decompose `S⧸I` as a direct sum of cyclic `R`-modules
  (quotients by the ideals generated by Smith coefficients of `I`). -/
noncomputable def quotient_equiv_direct_sum :
  (S ⧸ I) ≃ₗ[F] ⨁ i, R ⧸ span ({I.smith_coeffs b hI i} : set R) :=
begin
  apply ((I.quotient_equiv_pi_span b _).restrict_scalars F).trans
    (direct_sum.linear_equiv_fun_on_fintype _ _ _).symm,
  exact linear_map.is_scalar_tower.compatible_smul
  -- why doesn't it automatically apply?
  -- even after `change linear_map.compatible_smul _ (Π i, R ⧸ span _) F R`
end

lemma finrank_quotient_eq_sum [nontrivial F]
  [∀ i, module.free F (R ⧸ span ({I.smith_coeffs b hI i} : set R))]
  [∀ i, module.finite F (R ⧸ span ({I.smith_coeffs b hI i} : set R))] :
  finite_dimensional.finrank F (S ⧸ I)
    = ∑ i, finite_dimensional.finrank F (R ⧸ span ({I.smith_coeffs b hI i} : set R)) :=
begin
  rw [linear_equiv.finrank_eq $ quotient_equiv_direct_sum F b hI,
      finite_dimensional.finrank_direct_sum]
  -- slow, and dot notation doesn't work
end

/-- For a nonzero element `f` in an algebra `S` over a principal ideal domain `R` that is finite and
free as an `R`-module, the norm of `f` relative to `R` is associated to the product of the Smith
coefficients of the ideal generated by `f`. -/
lemma associated_norm_prod_smith {f : S} (hf : f ≠ 0) :
  associated (algebra.norm R f) (∏ i, smith_coeffs b _ (span_singleton_eq_bot.not.2 hf) i) :=
begin
  have hI := span_singleton_eq_bot.not.2 hf,
  let b' := ring_basis b (span {f}) hI,
  classical,
  rw [← matrix.det_diagonal, ← linear_map.det_to_lin b'],
  let e := (b'.equiv ((span {f}).self_basis b hI) $ equiv.refl _).trans
    ((linear_equiv.coord S S f hf).restrict_scalars R),
  refine (linear_map.associated_det_of_eq_comp e _ _ _).symm,
  dsimp only [e, linear_equiv.trans_apply],
  simp_rw [← linear_equiv.coe_to_linear_map, ← linear_map.comp_apply, ← linear_map.ext_iff],
  refine b'.ext (λ i, _),
  simp_rw [linear_map.comp_apply, linear_equiv.coe_to_linear_map, matrix.to_lin_apply,
    basis.repr_self, finsupp.single_eq_pi_single, matrix.diagonal_mul_vec_single, pi.single_apply,
    ite_smul, zero_smul, finset.sum_ite_eq', mul_one, if_pos (finset.mem_univ _), b'.equiv_apply],
  change _ = f * _,
  rw [mul_comm, ← smul_eq_mul, linear_equiv.restrict_scalars_apply, linear_equiv.coord_apply_smul,
    ideal.self_basis_def],
  refl
end

end comm_ring

section field

variables {F : Type*} [field F] [algebra F[X] S]

instance (b : basis ι F[X] S) {I : ideal S} (hI : I ≠ ⊥) (i : ι) :
  finite_dimensional F (F[X] ⧸ span ({I.smith_coeffs b hI i} : set F[X])) :=
(adjoin_root.power_basis $ I.smith_coeffs_ne_zero b hI i).finite_dimensional

open polynomial

/-- For a nonzero element `f` in a `F[X]`-module `S`, the dimension of $S/\langle f \rangle$ as an
`F`-vector space is the degree of the norm of `f` relative to `F[X]`. -/
@[nolint fintype_finite] lemma finrank_quotient_span_eq_nat_degree_norm [algebra F S]
  [is_scalar_tower F F[X] S] (b : basis ι F[X] S) {f : S} (hf : f ≠ 0) :
  finite_dimensional.finrank F (S ⧸ span ({f} : set S)) = (algebra.norm F[X] f).nat_degree :=
begin
  have h := span_singleton_eq_bot.not.2 hf,
  rw [nat_degree_eq_of_degree_eq (degree_eq_degree_of_associated $ associated_norm_prod_smith b hf),
      nat_degree_prod _ _ (λ i _, smith_coeffs_ne_zero b _ h i), finrank_quotient_eq_sum F b h],
  -- finrank_quotient_eq_sum slow
  congr' with i,
  exact (adjoin_root.power_basis $ smith_coeffs_ne_zero b _ h i).finrank
end

end field

end ideal
