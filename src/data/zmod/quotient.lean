/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/
import data.zmod.basic
import group_theory.quotient_group
import ring_theory.int.basic

/-!
# `zmod n` and quotient groups / rings

This file relates `zmod n` to the quotient group
`quotient_add_group.quotient (add_subgroup.gmultiples n)` and to the quotient ring
`(ideal.span {n}).quotient`.

## Main definitions

 - `zmod.quotient_gmultiples_nat_equiv_zmod` and `zmod.quotient_gmultiples_equiv_zmod`:
   `zmod n` is the group quotient of `ℤ` by `n ℤ := add_subgroup.gmultiples (n)`,
   (where `n : ℕ` and `n : ℤ` respectively)
 - `zmod.quotient_span_nat_equiv_zmod` and `zmod.quotient_span_equiv_zmod`:
   `zmod n` is the ring quotient of `ℤ` by `n ℤ : ideal.span {n}`
   (where `n : ℕ` and `n : ℤ` respectively)
 - `zmod.lift n f` is the map from `zmod n` induced by `f : ℤ →+ A` that maps `n` to `0`.

## Tags

zmod, quotient group, quotient ring, ideal quotient
-/

section lift

open quotient_add_group
open zmod

variables (n : ℕ) {A R : Type*} [add_group A] [ring R]

namespace int

/-- `ℤ` modulo multiples of `n : ℕ` is `zmod n`. -/
def quotient_gmultiples_nat_equiv_zmod :
  quotient (add_subgroup.gmultiples (n : ℤ)) ≃+ zmod n :=
(equiv_quotient_of_eq (zmod.ker_int_cast_add_hom _)).symm.trans $
quotient_ker_equiv_of_right_inverse (int.cast_add_hom (zmod n)) coe int_cast_zmod_cast

/-- `ℤ` modulo multiples of `a : ℤ` is `zmod a.nat_abs`. -/
def quotient_gmultiples_equiv_zmod (a : ℤ) :
  quotient (add_subgroup.gmultiples a) ≃+ zmod a.nat_abs :=
(equiv_quotient_of_eq (gmultiples_nat_abs a)).symm.trans
  (quotient_gmultiples_nat_equiv_zmod a.nat_abs)

/-- `ℤ` modulo the ideal generated by `n : ℕ` is `zmod n`. -/
def quotient_span_nat_equiv_zmod :
  (ideal.span {↑n}).quotient ≃+* zmod n :=
(ideal.quot_equiv_of_eq (zmod.ker_int_cast_ring_hom _)).symm.trans $
  ring_hom.quotient_ker_equiv_of_right_inverse $
  show function.right_inverse coe (int.cast_ring_hom (zmod n)),
  from int_cast_zmod_cast

/-- `ℤ` modulo the ideal generated by `a : ℤ` is `zmod a.nat_abs`. -/
def quotient_span_equiv_zmod (a : ℤ) :
  (ideal.span ({a} : set ℤ)).quotient ≃+* zmod a.nat_abs :=
(ideal.quot_equiv_of_eq (span_nat_abs a)).symm.trans
  (quotient_span_nat_equiv_zmod a.nat_abs)

end int

namespace zmod

/-- The map from `zmod n` induced by `f : ℤ →+ A` that maps `n` to `0`. -/
@[simps]
def lift (f : ℤ →+ A) (hf : f n = 0) : zmod n →+ A :=
(int.cast_add_hom (zmod n)).lift_of_right_inverse coe int_cast_zmod_cast ⟨f,
  by { rw ker_int_cast_add_hom,
       rintro _ ⟨x, rfl⟩,
       simp only [f.map_gsmul, hf, gsmul_zero, f.mem_ker] }⟩

@[simp] lemma lift_coe (f : ℤ →+ A) (hf : f n = 0) (x : ℤ) :
  lift n f hf (x : zmod n) = f x :=
add_monoid_hom.lift_of_right_inverse_comp_apply _ _ _ _ _

lemma lift_cast_add_hom (f : ℤ →+ A) (hf : f n = 0) (x : ℤ) :
  lift n f hf (int.cast_add_hom (zmod n) x) = f x :=
add_monoid_hom.lift_of_right_inverse_comp_apply _ _ _ _ _

@[simp] lemma lift_comp_coe (f : ℤ →+ A) (hf : f n = 0) :
  zmod.lift n f hf ∘ coe = f :=
funext $ lift_coe _ _ _

@[simp] lemma lift_comp_cast_add_hom (f : ℤ →+ A) (hf : f n = 0) :
  (zmod.lift n f hf).comp (int.cast_add_hom (zmod n)) = f :=
add_monoid_hom.ext $ lift_cast_add_hom _ _ _

end zmod

end lift
