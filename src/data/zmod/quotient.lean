/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/
import data.zmod.basic
import group_theory.quotient_group
import ring_theory.int.basic

/-!
# `zmod n` and quotient groups / rings

This file relates `zmod n` to the quotient group
`quotient_add_group.quotient (add_subgroup.gmultiples n)` and to the quotient ring
`(ideal.span {n}).quotient`.

## Main definitions

 - `zmod.quotient_gmultiples_nat_equiv_zmod` and `zmod.quotient_gmultiples_equiv_zmod`:
   `zmod n` is the group quotient of `ℤ` by `n ℤ := add_subgroup.gmultiples (n)`,
   (where `n : ℕ` and `n : ℤ` respectively)
 - `zmod.quotient_span_nat_equiv_zmod` and `zmod.quotient_span_equiv_zmod`:
   `zmod n` is the ring quotient of `ℤ` by `n ℤ : ideal.span {n}`
   (where `n : ℕ` and `n : ℤ` respectively)
 - `zmod.lift n f` is the map from `zmod n` induced by `f : ℤ →+ A` that maps `n` to `0`.

## Tags

parity, zmod, even, odd
-/

section lift

open quotient_add_group
open zmod

variables (n : ℕ) {A R : Type*} [add_group A] [ring R]

namespace int

/-- `ℤ` modulo multiples of `n : ℕ` is `zmod n`. -/
def quotient_gmultiples_nat_equiv_zmod :
  quotient (add_subgroup.gmultiples (n : ℤ)) ≃+ zmod n :=
{ to_fun := quotient_add_group.lift _ (cast_add_hom _)
    (λ x hx, show cast_add_hom (zmod n) x = 0,
      from (int_coe_zmod_eq_zero_iff_dvd _ _).mpr (mem_gmultiples_iff.mp hx)),
  inv_fun := mk' (add_subgroup.gmultiples (n : ℤ)) ∘ coe,
  left_inv := λ x, quot.induction_on x (λ x, eq_iff_sub_mem.mpr $
    by rw [lift_quot_mk, coe_cast_add_hom, mem_gmultiples_iff,
           ← int_coe_zmod_eq_zero_iff_dvd, cast_sub, int_cast_zmod_cast, sub_self]),
  right_inv := λ x,
    by rw [function.comp_app, quotient_add_group.mk'_apply, lift_mk, coe_cast_add_hom,
           int_cast_zmod_cast],
  .. quotient_add_group.lift _ _ _ }

/-- `ℤ` modulo multiples of `a : ℤ` is `zmod a.nat_abs`. -/
def quotient_gmultiples_equiv_zmod (a : ℤ) :
  quotient (add_subgroup.gmultiples a) ≃+ zmod a.nat_abs :=
(equiv_quotient_of_eq (gmultiples_nat_abs a)).symm.trans
  (quotient_gmultiples_nat_equiv_zmod a.nat_abs)

/-- `ℤ` modulo the ideal generated by `n : ℕ` is `zmod n`. -/
def quotient_span_nat_equiv_zmod :
  (ideal.span {↑n}).quotient ≃+* zmod n :=
{ to_fun := ideal.quotient.lift _ (cast_ring_hom _)
    (λ x hx, (int_coe_zmod_eq_zero_iff_dvd _ _).mpr (ideal.mem_span_singleton.mp hx)),
  inv_fun := (ideal.quotient.mk _) ∘ coe,
  left_inv := λ x, quotient.induction_on' x (λ x, ideal.quotient.eq.mpr $
    by rw [submodule.quotient.mk'_eq_mk, ideal.quotient.mk_eq_mk, ideal.quotient.lift_mk,
           coe_cast_ring_hom, ideal.mem_span_singleton, ← int_coe_zmod_eq_zero_iff_dvd,
           cast_sub, int_cast_zmod_cast, sub_self]),
  right_inv := λ x,
    by rw [function.comp_app, ideal.quotient.lift_mk, coe_cast_ring_hom, int_cast_zmod_cast],
  .. ideal.quotient.lift _ _ _ }

/-- `ℤ` modulo the ideal generated by `a : ℤ` is `zmod a.nat_abs`. -/
def quotient_span_equiv_zmod (a : ℤ) :
  (ideal.span ({a} : set ℤ)).quotient ≃+* zmod a.nat_abs :=
(ideal.quot_equiv_of_eq (span_nat_abs a)).symm.trans
  (quotient_span_nat_equiv_zmod a.nat_abs)

end int

/-- The map from `zmod n` induced by `f : ℤ →+ A` that maps `n` to `0`. -/
@[simps] def zmod.lift (f : ℤ →+ A) (hf : f n = 0) : zmod n →+ A :=
add_monoid_hom.comp
  (quotient_add_group.lift (add_subgroup.gmultiples (n : ℤ)) f $
    by { rintro _ ⟨x, rfl⟩, simp only [f.map_gsmul, hf, gsmul_zero] })
  (int.quotient_gmultiples_nat_equiv_zmod n).symm.to_add_monoid_hom

end lift
